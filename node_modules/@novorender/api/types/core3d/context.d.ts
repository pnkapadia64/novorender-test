import type { RenderModule, DerivedRenderState, RenderState, Core3DImports } from "./";
import type { UniformsProxy, TextureParamsCubeUncompressedMipMapped, TextureParamsCubeUncompressed, ShaderHeaderParams } from "../webgl2";
import { RenderBuffers } from "./buffers";
import type { WasmInstance } from "./wasm";
import type { ReadonlyVec3 } from "gl-matrix";
import { ResourceBin } from "./resource";
import type { DeviceProfile } from "./device";
/** The view specific context for rendering and picking.
 * @remarks
 * A render context describes a view into which a {@link RenderState} can be rendered.
 * It is tightly bound to a HTML canvas and WebGL2RenderingContext.
 * Consequently, it will be disposed if the gl context is lost and recreated when the gl context is restored.
 *
 * The render context must be {@link init | initialized} with an array of {@link RenderModule | render modules}.
 * Unused modules may be removed and custom ones inserted here.
 * Ordering the modules correctly is important as they are rendered in order.
 * The {@link TonemapModule} should be last, as it will copy the HDR render buffers into the output canvas to make things visible.
 *
 * Features such as async picking and shader linking requires {@link poll} to be called at regular intervals,
 * e.g. at the start of each frame.
 * Otherwise the promises will never be resolved.
 *
 * @category Render Module
 */
export declare class RenderContext {
    /** The device profile use for this context. */
    readonly deviceProfile: DeviceProfile;
    /** The HTML canvas used for this context. */
    readonly canvas: HTMLCanvasElement;
    /** Imported resources. */
    readonly imports: Core3DImports;
    /** WebGL2 render context associated with this object. */
    readonly gl: WebGL2RenderingContext;
    /** WebGL common GLSL code header used across shaders. */
    readonly commonChunk: string;
    /** WebGL basic fallback IBL textures to use while loading proper IBL textures. */
    readonly defaultIBLTextureParams: TextureParamsCubeUncompressed;
    /** Web assembly instance. */
    readonly wasm: WasmInstance;
    private static defaultModules;
    private modules;
    private cameraUniformsData;
    private clippingUniformsData;
    private outlinesUniformsData;
    private localSpaceTranslation;
    private readonly asyncPrograms;
    private readonly resourceBins;
    private readonly defaultResourceBin;
    private readonly iblResourceBin;
    private pickBuffersValid;
    private currentPick;
    private activeTimers;
    private currentFrameTime;
    private statistics;
    private prevFrame;
    private isOrtho;
    private viewClipMatrix;
    private viewWorldMatrix;
    private viewWorldMatrixNormal;
    private viewClipMatrixLastPoll;
    private viewWorldMatrixLastPoll;
    /** WebGL uniform buffer for camera related uniforms. */
    readonly cameraUniforms: WebGLBuffer;
    /** WebGL uniform buffer for clipping related uniforms. */
    readonly clippingUniforms: WebGLBuffer;
    /** WebGL uniform buffer for outline related uniforms. */
    readonly outlineUniforms: WebGLBuffer;
    /** WebGL GGX/PBR shading lookup table texture. */
    readonly lut_ggx: WebGLTexture;
    /** WebGL Sampler used to sample mipmapped diffuse IBL texture. */
    readonly samplerMip: WebGLSampler;
    /** WebGL Sampler used to sample other, non-mipmapped IBL textures. */
    readonly samplerSingle: WebGLSampler;
    /** {@link RenderState} used to render the previous frame, if any. */
    prevState: DerivedRenderState | undefined;
    /** {@link RenderState} used to make the newest state available during render. */
    currentState: DerivedRenderState | undefined;
    /** Set to true to force a re-render when state not contained in {@link RenderState} has changed, e.g. download complete etc. */
    changed: boolean;
    /** WebGL render and pick buffers
     * @remarks
     * Note that these buffers will be recreated whenever the {@link RenderState.output} size changes.
     */
    buffers: RenderBuffers;
    /** WebGL textures used for image based lighting ({@link https://en.wikipedia.org/wiki/Image-based_lighting | IBL}).
     * @remarks
     * Note that these buffers will be changed by the background module when download of the specified {@link RenderState.background.url} IBL textures completes.
     *
     * The process to create the textures are similar to that of {@link https://github.com/KhronosGroup/glTF-IBL-Sampler}/
     */
    iblTextures: {
        /** WebGL cubemap texture containing the irradiance/diffuse values of current IBL environment. */
        readonly diffuse: WebGLTexture;
        /** WebGL cubemap texture containing the radiance/specular values of current IBL environment. */
        readonly specular: WebGLTexture;
        /** # mip maps in current specular texture. */
        readonly numMipMaps: number;
        /** # True if these are the default IBL textures. */
        readonly default: boolean;
    };
    /** Initialize render context with specified render modules.
     * @remarks
     * The default/built-in render modules can be retrieved using {@link createDefaultModules}.
     * These will be used if no modules are specified.
     * Developers may introduce their own render modules here.
     * Note that the order of the modules matters, as this is the order by which they will be rendered.
     */
    init(modules?: readonly RenderModule[]): Promise<void>;
    private linkAsyncPrograms;
    /**
     * Dispose of the GPU resources used by this context, effectively destroying it and freeing up memory.
     * @remarks
     * Calling this method is optional as the garbage collection of the underlying WebGL render context will do the same thing.
     * This may take some time, however, so calling this function is recommended if you plan to create a new context shortly thereafter.
     */
    dispose(): void;
    /** Return the current pixel width of the drawing buffer. */
    get width(): number;
    /** Return the current pixel height of the drawing buffer. */
    get height(): number;
    /** Query if pick buffers are valid.
     * @remarks This could be useful for optimistic/non-async picking.
     */
    isPickBuffersValid(): boolean;
    /** Query whether the underlying WebGL render context is currently lost.
     * @remarks
     * This could occur when too many resources are allocated or when browser window is dragged across screens.
     * Loss and restoration of WebGL contexts is supported by this API automatically.
     */
    isContextLost(): boolean;
    /** Helper function to update WebGL uniform buffer from proxies. */
    updateUniformBuffer(uniformBuffer: WebGLBuffer, proxy: UniformsProxy): void;
    /** Explicitly update WebGL IBL textures from specified parameters. */
    updateIBLTextures(params: {
        readonly diffuse: TextureParamsCubeUncompressed;
        readonly specular: TextureParamsCubeUncompressedMipMapped;
    } | null): void;
    /**
     * Helper function to check for changes in render state.
     * @param state The parts of the render state to check for changes.
     * @returns True if any of the specified parts has changed since last frame.
     * @remarks
     * Since the render state is immutable, any changes will automatically trickle up to the container object as well.
     * Thus, this function does a shallow strict equality of the parts of the renderstate specified in the state parameter.
     * @example
     * Example of how to check for changes in either camera or output render state.
     * ```typescript
     * const {camera, output} = renderState;
     * if(renderContext.hasStateChanged({camera, output})) {
     *   // update related GPU state here...
     * }
     * ```
     */
    hasStateChanged(state: Partial<DerivedRenderState>): boolean;
    /** Create a new named resource bin. */
    resourceBin(name: string): ResourceBin;
    /** Compile WebGL/GLSL shader program asynchronously. */
    makeProgramAsync(resourceBin: ResourceBin, params: AsyncProgramParams): Promise<WebGLProgram>;
    private resetStatistics;
    /** Poll the status of WebGL pick fences and timers and resolve associated promises when possible. */
    poll(): void;
    private beginTimer;
    private pollTimers;
    /** Wait for the next frame to be ready for rendering.
     * @param context render context to wait for, if any.
     * @remarks Use this function instead of requestAnimationFrame()!
     */
    static nextFrame(context: RenderContext | undefined): Promise<number>;
    /**
     * Render a new frame using the specified render state.
     * @param state An object describing what the frame should look like.
     * @returns A promise to the performance related statistics involved in rendering this frame.
     */
    render(state: RenderState): Promise<RenderStatistics>;
    /**
* scan the pick buffer for deviation values
* @returns Return pixel coordinates and deviation values for any deviation on screen
*/
    getDeviations(): Promise<DeviationSample[]>;
    private updateCameraUniforms;
    private updateClippingUniforms;
    private extractPick;
    /**
     * Pick information about underlying object and geometry.
     * @param x Center x coordinate in CSS pixels.
     * @param y Center y coordinate in CSS pixels.
     * @param options More details of pick operation.
     * @returns A set of pick samples of the specified sample disc.
     */
    pick(x: number, y: number, options?: PickOptions): Promise<PickSample[]>;
}
/**
 * Deviation sampled from screen
 */
export interface DeviationSample {
    /** x coordinate in pixel space */
    readonly x: number;
    /** y coordinate in pixel space */
    readonly y: number;
    /** World space position of underlying pixel. */
    readonly position: ReadonlyVec3;
    /** The spatial deviation of underlying pixel.
     * @remarks This only applies to point clouds with precomputed deviation data.
     */
    readonly deviation: number;
}
/**
 * Pick Sample information
 */
export interface PickSample {
    /** relative x pixel offset (not css pixel) from pick center. */
    readonly x: number;
    /** relative y pixel offset (not css pixel) from pick center. */
    readonly y: number;
    /** World space position of underlying pixel. */
    readonly position: ReadonlyVec3;
    /** World space normal of underlying pixel. */
    readonly normal: ReadonlyVec3;
    /** The object id/index of underlying pixel. */
    readonly objectId: number;
    /** The spatial deviation of underlying pixel, if any.
     * @remarks This only applies to point clouds with precomputed deviation data.
     */
    readonly deviation?: number;
    /** The depth/distance from the view plane. */
    readonly depth: number;
    /** The picked pixel is part of clipping outline */
    readonly clippingOutline: boolean;
}
/** Extra pick options. */
export interface PickOptions {
    /** The radius of the sample disc (0 yields a single pixel). */
    readonly sampleDiscRadius?: number;
    /** True to wait for the pick buffers to be available, false to return whatever is in the current pick buffer synchronously.
     * @remarks The latter option is more error prone, but useful for e.g. mouse hover operations.
     */
    readonly async?: boolean;
    /** Return pick without depth. */
    readonly pickCameraPlane?: boolean;
    /** Return only picked pixels with clipping outline. */
    readonly pickOutline?: boolean;
}
/** Parameters for asynchronous shader compilation and linking. */
export interface AsyncProgramParams {
    /** Common GLSL header information to be inserted before the body code. */
    readonly header?: Partial<ShaderHeaderParams>;
    /** The vertex shader. */
    readonly vertexShader: string;
    /** The fragment shader (optional with transform feedback shaders). */
    readonly fragmentShader?: string;
    /** The names of the vertex attributes to be bound prior to linking using gl.bindAttribLocation(). */
    readonly attributes?: readonly string[];
    /** The names of the shader uniform blocks to be bound prior to linking using gl.uniformBlockBinding(), in the order which they appear */
    readonly uniformBufferBlocks?: readonly string[];
    /** Texture uniforms to be bound post-linking. */
    readonly textureUniforms?: readonly string[];
    /** Transform feedback buffers to be bound post-linking. */
    readonly transformFeedback?: {
        /** Should output attributes be written into a single interleaved buffer or separate buffers? */
        readonly bufferMode: "INTERLEAVED_ATTRIBS" | "SEPARATE_ATTRIBS";
        /** Name of output attribute names (varyings). */
        readonly varyings: readonly string[];
    };
}
/** Render frame performance and resource usage statistics. */
export interface RenderStatistics {
    /** Estimated # bytes used by WebGL buffers for this frame. */
    readonly bufferBytes: number;
    /** Estimated # bytes uses by WebGL textures for this frame. */
    readonly textureBytes: number;
    /** # of points drawn in this frame. */
    readonly points: number;
    /** # of lines drawn in this frame. */
    readonly lines: number;
    /** # of triangles drawn in this frame. */
    readonly triangles: number;
    /** # of draw calls in this frame. */
    readonly drawCalls: number;
    /** # of primitives (points+lines+triangles) drawn by static geometry for this frame. */
    readonly primitives: number;
    /** Time spent in the main thread. */
    readonly cpuTime: {
        /** # CPU milliseconds spent rendering. */
        readonly draw: number;
    };
    /** Time spent in the GPU. */
    readonly gpuTime: {
        /** # GPU milliseconds spent rendering, if supported by driver. */
        readonly draw: number | undefined;
    };
    /** Effective interval in milliseconds since last frame was drawn. */
    readonly frameInterval: number;
}
//# sourceMappingURL=context.d.ts.map