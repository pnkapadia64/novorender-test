import type { ReadonlyMat4, ReadonlyVec3 } from "gl-matrix";
import { vec3 } from "gl-matrix";
import type { ProductData } from "./brep";
import { GeometryFactory } from "./loader";
import { type PathInfo } from "./outline";
import { Downloader } from "./util";
import { type ParametricProduct } from "./parametric_product";
import { type PickInterface } from "./snaps";
import { RoadTool } from "./roads/scene";
import type { CameraValues, CollisionValues, CrossSlope, DrawObject, DuoMeasurementValues, EdgeValues, FaceValues, LoadStatus, ManholeMeasureValues, MeasureEntity, MeasureSettings, ObjectId, ParameterBounds, Profile, RoadCrossSection, RoadProfiles, SnapTolerance } from "..";
export declare const epsilon = 0.0001;
export declare class MeasureTool {
    downloader: Downloader;
    crossSectionTool: RoadTool;
    data: Map<number, ProductData | null>;
    snapObjects: PickInterface[];
    nextSnapIdx: number;
    static geometryFactory: GeometryFactory;
    constructor();
    init(wasm: string | ArrayBuffer): Promise<void>;
    loadScene(baseUrl: string): void;
    getSnapInterface(id: number, product: ProductData | undefined): Promise<PickInterface | undefined>;
    downloadBrep(name: string): Promise<ProductData | null>;
    private getProduct;
    getCameraValuesFromFace(id: ObjectId, faceIdx: number, instanceIdx: number, cameraDir: vec3): Promise<CameraValues | undefined>;
    getFaces(id: ObjectId, viewWorldMatrix: ReadonlyMat4): Promise<PathInfo[]>;
    getProductObject(productId: number): Promise<ParametricProduct | undefined>;
    getSnaps(productId: number): Promise<undefined>;
    getParameterBoundsForCurve(id: ObjectId, pathIdx: number, pathKind: "edge" | "curveSegment"): Promise<ParameterBounds | undefined>;
    evalCurve(id: ObjectId, pathIdx: number, instanceIdx: number, parameter: number, pathKind: "edge" | "curveSegment"): Promise<[ReadonlyVec3, ReadonlyVec3] | undefined>;
    getCylinderCurve(id: ObjectId, faceIdx: number, instanceIdx: number, setting?: MeasureSettings): Promise<[ParameterBounds, [ReadonlyVec3, ReadonlyVec3]] | undefined>;
    pickEntity(id: ObjectId, position: vec3, tolerance?: SnapTolerance): Promise<{
        entity: MeasureEntity;
        status: LoadStatus;
        connectionPoint?: vec3;
    }>;
    pickEntityOnCurrentObject(id: ObjectId, position: vec3, tolerance: SnapTolerance): Promise<{
        entity: MeasureEntity | undefined;
        status: LoadStatus;
        connectionPoint?: vec3;
    }>;
    getEdges(id: ObjectId, viewWorldMatrix: ReadonlyMat4): Promise<PathInfo[]>;
    getPaths(id: ObjectId, worldViewMatrix: ReadonlyMat4): Promise<PathInfo[]>;
    viableFollowPathEntity(id: ObjectId): Promise<MeasureEntity | undefined>;
    getTesselatedEdge(id: ObjectId, edgeIdx: number, instanceIdx: number): Promise<ReadonlyVec3[]>;
    tesselateCurveSegment(id: ObjectId, curveSegmentIdx: number, instanceIdx: number): Promise<ReadonlyVec3[]>;
    curveSegmentProfile(id: ObjectId, curveSegmentIdx: number, instanceIdx: number): Promise<Profile | undefined>;
    cylinderProfile(id: ObjectId, faceIdx: number, instanceIdx: number, setting?: MeasureSettings): Promise<Profile | undefined>;
    multiSelectProfile(products: ObjectId[], setting?: MeasureSettings): Promise<Profile | undefined | string>;
    getLineStripFromCylinders(products: ObjectId[], setting?: MeasureSettings): Promise<ReadonlyVec3[]>;
    cylindersToLinestrip(products: ObjectId[], setting?: MeasureSettings): Promise<ReadonlyVec3[]>;
    getFaceDrawObject(id: ObjectId, faceIdx: number, instanceIdx: number, setting?: MeasureSettings): Promise<DrawObject | undefined>;
    edgeToEdgeMeasure(idA: ObjectId, edgeIdxA: number, instanceIdxA: number, idB: ObjectId, edgeIdxB: number, instanceIdxB: number): Promise<DuoMeasurementValues | undefined>;
    edgeToPointMeasure(id: ObjectId, edgeIdx: number, instanceIdx: number, point: vec3): Promise<DuoMeasurementValues | undefined>;
    segmentToPointMeasure(id: ObjectId, segIdx: number, instanceIdx: number, point: vec3): Promise<DuoMeasurementValues | undefined>;
    faceToPointMeasure(id: ObjectId, faceIdx: number, instanceIdx: number, point: vec3, setting?: MeasureSettings): Promise<DuoMeasurementValues | undefined>;
    edgeToFaceMeasure(idA: ObjectId, edgeIdx: number, edgeInstanceIdx: number, idB: ObjectId, faceIdx: number, faceInstanceIdx: number, setting?: MeasureSettings): Promise<DuoMeasurementValues | undefined>;
    faceToFaceMeasure(idA: ObjectId, faceIdxA: number, instanceIdxA: number, idB: ObjectId, faceIdxB: number, instanceIdxB: number, settingA?: MeasureSettings, settingB?: MeasureSettings): Promise<DuoMeasurementValues | undefined>;
    segmentToSegmentMeasure(idA: ObjectId, segIdxA: number, instanceIdxA: number, idB: ObjectId, segIdxB: number, instanceIdxB: number): Promise<DuoMeasurementValues | undefined>;
    segmentToEdgeMeasure(idA: ObjectId, segIdx: number, segInstanceIdx: number, idB: ObjectId, edgeIdx: number, edgeInstanceIdx: number): Promise<DuoMeasurementValues | undefined>;
    segmentToFaceMeasure(idA: ObjectId, segIdx: number, segInstanceIdx: number, idB: ObjectId, faceIdx: number, faceInstanceIdx: number, setting?: MeasureSettings): Promise<DuoMeasurementValues | undefined>;
    getCurveValues(id: ObjectId, pathIdx: number, instanceIdx: number, pathKind: "edge" | "curveSegment"): Promise<EdgeValues | undefined>;
    getFaceValues(id: ObjectId, faceIdx: number, instanceIdx: number, setting?: MeasureSettings): Promise<FaceValues | undefined>;
    getManholeValues(id: ObjectId): Promise<ManholeMeasureValues | undefined>;
    getManholeDrawObject(entity: ManholeMeasureValues): Promise<DrawObject[]>;
    swapCylinder(id: ObjectId, faceIdx: number, instanceIdx: number, to: "inner" | "outer"): Promise<number | undefined>;
    faceToFaceCollision(idA: ObjectId, faceIdxA: number, instanceIdxA: number, idB: ObjectId, faceIdxB: number, instanceIdxB: number, setting?: MeasureSettings): Promise<CollisionValues | undefined>;
    getRoadProfile(roadId: string): Promise<RoadProfiles | undefined>;
    getRoadCrossSlope(roadId: string): Promise<CrossSlope | undefined>;
    getCrossSection(roadId: string, profileNumber: number): Promise<RoadCrossSection | undefined>;
}
//# sourceMappingURL=scene.d.ts.map