import { type ReadonlyVec3, vec3, type ReadonlyQuat } from "gl-matrix";
import { type RenderState, type RenderStateChanges, RenderContext, type SceneConfig, type RenderStatistics, type DeviceProfile, type PickSample, type PickOptions, type Core3DImports, type Core3DImportMap } from "../core3d";
import { ControllerInput, type BaseController, type PickContext, type BuiltinCameraControllerType } from "./controller";
import { MeasureView, type MeasureEntity, type MeasureImportMap, type MeasureImports } from "../measure";
import { type DeviationInspectionSettings, type DeviationInspections } from "./buffer_inspect";
/**
 * A view base class for Novorender content.
 * @template CameraControllerType Types of camera controllers used by this view.
 * @template CameraControllerKind The inferred camera controller kind string union.
 * @remarks
 * The view class wraps the complexities of the `Core3D` module into a high-level abstraction.
 * Notably, it implements a render loop in the {@link run} function, which deals with a number of issues, such as:
 * - Camera controllers.
 * - Rendering after {@link modifyRenderState | state changes}, saving energy and battery life.
 * - Adjust to resizing of canvas element.
 * - Managing idle vs active rendering, i.e. lower fidelity rendering while the camera is moving for better frame rates.
 * - Adaptive performance adjustment to maintain a target frame rate target.
 * - Post effects.
 *
 * In the likely event that you want to change or extend some of the default behaviour,
 * you should make a derived View class of your own and override the methods you need.
 * @category Render View
 */
export declare class View<CameraControllerTypes extends CameraControllers = BuiltinCameraControllerType, CameraControllerKind extends string = Extract<keyof CameraControllerTypes, string>> implements Disposable {
    /** The HTMLCanvasElement used for rendering. */
    readonly canvas: HTMLCanvasElement;
    readonly imports: Core3DImports & MeasureImports;
    /** Available camera controller types. */
    controllers: CameraControllerTypes;
    private _renderContext;
    private _run;
    private _deviceProfile;
    private _setDeviceProfile;
    private _stateChanges;
    private _activeController;
    private _statistics;
    private _measureViewPromise;
    private _drawContext2d;
    private readonly _resizeObserver;
    private resolutionModifier;
    private baseRenderResolution;
    private drsHighInterval;
    private drsLowInterval;
    private lastDrsAdjustTime;
    private resolutionTier;
    private activeOutline;
    private currentDetailBias;
    /**
     * @param canvas The HtmlCanvasElement used for rendering.
     * @param deviceProfile The device profile describing the host device's GPU performance characteristics and limitations.
     * @param imports Imported, non-javascript resources.
     * @remarks
     * Your browser must run in a {@link https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts | secure}
     * and {@link https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts | cross-origin isolated } context.
     */
    constructor(
    /** The HTMLCanvasElement used for rendering. */
    canvas: HTMLCanvasElement, deviceProfile: DeviceProfile, imports: Core3DImports & MeasureImports, controllersFactory?: CameraControllersFactory<CameraControllerTypes>);
    /** Dispose of the view's GPU resources. */
    [Symbol.dispose](): void;
    /** Dispose of the view's GPU resources. */
    dispose(): void;
    get measure(): Promise<MeasureView>;
    get activeController(): BaseController;
    get renderContext(): RenderContext | undefined;
    get renderState(): RenderState;
    get prevRenderState(): RenderState | undefined;
    get statistics(): {
        readonly render: RenderStatistics;
        readonly view: ViewStatistics;
    } | undefined;
    /**
     * The current device profile.
     * @remarks
     * Setting a new device profile will force a recreation of the entire render context and should generally be avoided.
     * Valid cases for doing so might be users manually overriding the GPU profile of their device, or for testing/diagnostics purposes.
     */
    get deviceProfile(): DeviceProfile;
    set deviceProfile(value: DeviceProfile);
    /** Determine if camera is looking straight down. */
    isTopDown(): boolean;
    /**
     * Convert 2D pixel position to 3D position.
     * @param x Pixel x coordinate, in CSS pixels.
     * @param y Pixel y coordinate, in CSS pixels.
     * @returns Corresponding 3D position at the view plane in world space, or undefined if there is no active render context.
     */
    worldPositionFromPixelPosition(x: number, y: number): vec3 | undefined;
    /**
     * Retrieve list of available background/IBL environments.
     * @public
     * @param indexUrl
     * The absolute url of the index.json file.
     * @returns A promise of a list of environments.
     */
    availableEnvironments(indexUrl: URL): Promise<EnvironmentDescription[]>;
    /**
     * Load a scene from a url.
    * @public
    * @param url The absolute url to the folder containing the scene.
    * @param abortSignal Optional abort controller.
    * @remarks
    * The url typically contains the scene id as the latter part of the path, i.e. `https://.../<scene_guid>/`.
    */
    loadSceneFromURL(url: URL, abortSignal?: AbortSignal): Promise<SceneConfig>;
    /**
     * Inspect the deviations that is on screen
     * @public
     * @param settings Deviation settings,
     * @returns Spaced out lables prioritizing the smallest or highest deviation values based on settings.
     * Also returns a line trough the points if it is able to project the points on a line and the option is given.
     */
    inspectDeviations(settings: DeviationInspectionSettings): Promise<DeviationInspections | undefined>;
    /**
     * Get all object ids currently on screen
     * @public
     * @returns returns a set of all object ids on the screen
     */
    getOutlineObjectsOnScreen(): Promise<Set<number> | undefined>;
    /**
     * Query parametric measure entity for the given coordinates
     * @param x Center x coordinate in css pixels.
     * @param y Center y coordinate in css pixels.
     * @param options Extra options.
     * @returns Parametric measure entity, if non exists in the current location, the poisiton will be retuned.
     */
    pickMeasureEntity(x: number, y: number, options?: PickOptions): Promise<MeasureEntity | undefined>;
    /**
     * Query object and geometry information for given view coordinate.
     * @param x Center x coordinate in css pixels.
     * @param y Center y coordinate in css pixels.
     * @param options Extra options.
     * @returns The sample within the sample disc that is closest to the camera, if any.
     */
    pick(x: number, y: number, options?: PickOptions): Promise<PickSampleExt | undefined>;
    /**
     * Switch to a new kind of camera controller.
     * @param kind The type of camera controller to switch to.
     * @param initialState Optional initial state for the new camera controller. Undefined properties will be copied/adapted from the current render state.
     * @param options Switch options.
     * @template T Kind of camera controller.
     * @returns The new camera controller.
     * @remarks
     * The function will also set the {@link RenderStateCamera.kind | camera projection model}.
     */
    switchCameraController<T extends CameraControllerKind>(kind: T, initialState?: CameraControllerInitialValues, options?: CameraControllerOptions): Promise<CameraControllerTypes[T]>;
    /**
     * Start the main render loop for the view.
     * @param abortSignal Signal to abort any pending downloads and exit render loop.
     * @remarks
     * This method will not exit until you call {@link exit}.
     */
    run(abortSignal?: AbortSignal): Promise<void>;
    /** Signal the render loop to exit.
     * @see {@link run}.
     * @deprecated Use {@link run} `abortSignal` instead.
     */
    exit(): void;
    /** Accumulate render state changes.
     * @param changes The changes to apply to the current view render state.
     * @remarks
     * These changes will be applied and a single call to the {@link modifyRenderState} function just prior to rendering each frame.
     */
    modifyRenderState(changes: RenderStateChanges): void;
    /**
     * Validate render state changes made since last rendered frame.
     * @param changes The render state changes to validate, or undefined to validate changes applied via {@link View.modifyRenderState} since last rendered frame.
     * @returns An array of validation errors, if any.
     * @see {@link View.modifyRenderState}
     * @remarks
     * Validation is useful for catching potential bugs and problems early.
     * It should not be performed in production code, however, since it is non-trivial in terms of performance, particularly on large sets of dynamic objects.
     */
    validateRenderState(changes?: RenderStateChanges): readonly Error[];
    /**
     * Override this in a derived class to modify render state just prior to rendering.
     * @param time The frame render timestamp in millisecond.
     * @virtual
     */
    animate?(time: number): void;
    /**
     * Override this in a derived class to handle render state validation.
     * @param newState The new render state about to be rendered
     * @param changes The changes that went into the new render state.
     * @virtual
     */
    validate?(newState: RenderState, changes: RenderStateChanges): void;
    /**
     * Override this in a derived class for custom rendering of e.g. 2D content, such as text and lines etc.
     * @param isIdleFrame Was the camera moving or not.
     * @virtual
     */
    render?(isIdleFrame: boolean): void;
    /**
     * Callback function to update render context.
     * @param context A new render context.
     * @remarks
     * A new render context may be set each time the underlying webgl context is lost and restored,
     * or when certain state changes are made that forces a recreation of the context, such as setting a new {@link deviceProfile}.
     * @virtual
     */
    protected readonly setRenderContext: (context: RenderContext) => void;
    private useDeviceProfile;
    private resize;
    private recalcBaseRenderResolution;
    private applyChanges;
    private createRenderState;
    private dynamicQualityAdjustment;
    private dynamicResolutionScaling;
    static downloadImports(map: ViewImportmap): Promise<ViewImports>;
}
/** Background/IBL environment description
 * @category Render View
 */
export interface EnvironmentDescription {
    /** Display name of environment */
    readonly name: string;
    /** Data URL. */
    readonly url: string;
    /** Thumbnail URL. */
    readonly thumnbnailURL: string;
}
/** View related render statistics.
 * @category Render View
 */
export interface ViewStatistics {
    /** Effective resolution factor. */
    readonly resolution: number;
    /** Effective detail bias factor. */
    readonly detailBias: number;
    /** Effective frames per second, if available. */
    readonly fps?: number;
}
/** Extended pick sample information.
 * @category Render View
 */
export interface PickSampleExt extends PickSample {
    /** Sample normal, in view space. */
    readonly normalVS: ReadonlyVec3;
    /** Whether sample lies on an edge, corner or surface. */
    readonly sampleType: "edge" | "corner" | "surface";
}
/** @ignore */
export type CameraControllers<T extends string = string> = {
    readonly [P in T]: BaseController;
};
/** Camera controller factory function signature type.
 * @template T dude
 */
export type CameraControllersFactory<T extends CameraControllers> = (input: ControllerInput, pick: PickContext) => T;
/** Optional values to initialize camera controller. */
export interface CameraControllerInitialValues {
    /** The camera position. */
    readonly position?: ReadonlyVec3;
    /** The camera rotation. */
    readonly rotation?: ReadonlyQuat;
    /** The camera field of view.
     * @see {@link RenderStateCamera.fov}.
     */
    readonly fov?: number;
}
/** Camera controller switch options.
 * @category Camera Controller
 * @category Render View
 */
export interface CameraControllerOptions {
    /** Whether to attempt an auto initializion of camera position or not.
     * @remarks
     * This is a heuristic won't work well for scenes with clusters of geometry scattered far apart.
     * Georeferenced autocad models that contains "meta" geometry at origo are often problematic and may require you to supply a position manually.
     */
    readonly autoInit?: boolean;
}
export type ViewImports = Core3DImports & MeasureImports;
export type ViewImportmap = Core3DImportMap & MeasureImportMap;
//# sourceMappingURL=view.d.ts.map