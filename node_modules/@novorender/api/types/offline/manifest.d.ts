import type { OfflineDirectory } from "./storage";
/** An scene manifest entry tuple, consisting of [filename/hash, byteSize]. */
export type SceneManifestEntry = readonly [name: string, size: number];
/** A collection of scene manifest entry tuples, used to construct a scene manifest. */
export type SceneManifestData = Iterable<SceneManifestEntry>;
/** A file manifest for a scene.
 * @remarks
 * A fundamental assumption here is that the file names in the manifest are hashes of the actual content, i.e. same name = same content.
 * If this condition is not met, synchronization will not work!
 */
export declare class SceneManifest {
    /** A map of manifest filenames and their respective byte sizes. */
    private readonly _files;
    get files(): IterableIterator<SceneManifestEntry>;
    /** The total byte size of all the files in this manifest. */
    readonly totalByteSize: number;
    /** The number of files. */
    readonly numFiles: number;
    /**
     * @param data The entries of this manifest.
     */
    constructor(data: SceneManifestData);
}
/**
 * Get an offline file manifest.
 * @param dir The offline directory containing the file manifest.
 * @returns A scene manifest.
 * If the offline directory contains a manifest file, it will be read and returned as a complete manifest.
 * If not, the files in the directory will be enumerated and used to create a partial manifest.
 * The latter case indicates some prior error and is not ideal, but still better than re-downloading every file from scratch.
 */
export declare function readManifest(dir: OfflineDirectory): Promise<SceneManifest>;
/**
 * Fetch file manifest online.
 * @param request The fetch() API request for the online "manifest.json" file.
 */
export declare function fetchManifest(request: Request): Promise<SceneManifest>;
//# sourceMappingURL=manifest.d.ts.map