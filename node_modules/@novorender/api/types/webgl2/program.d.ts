export type ShaderExtensionName = "GL_ANGLE_multi_draw";
export declare function glShaderExtensions(gl: WebGL2RenderingContext): IterableIterator<ShaderExtension>;
export declare function glCompile(gl: WebGL2RenderingContext, params: ShaderParams): WebGLShader;
export declare function glCreateProgramAsync(gl: WebGL2RenderingContext, params: ProgramAsyncParams): {
    readonly program: WebGLProgram;
    readonly vertex: WebGLShader;
    readonly fragment: WebGLShader;
};
export declare function glCheckProgram(gl: WebGL2RenderingContext, params: ReturnType<typeof glCreateProgramAsync>): {
    readonly link: string | null;
    readonly vertex: string | null;
    readonly fragment: string | null;
} | undefined;
export declare function glCreateProgram(gl: WebGL2RenderingContext, params: ProgramParams): WebGLProgram;
export interface ProgramAsyncParams {
    readonly header?: string | Partial<ShaderHeaderParams>;
    readonly vertexShader: string;
    readonly fragmentShader: string | undefined;
}
export interface VertexShaderParams {
    readonly kind: "VERTEX_SHADER";
    readonly shader: string;
}
export interface FragmentShaderParams {
    readonly kind: "FRAGMENT_SHADER";
    readonly shader: string;
}
export type ShaderParams = VertexShaderParams | FragmentShaderParams;
export interface ShaderExtension {
    readonly name: ShaderExtensionName | string;
    readonly behaviour: "enable" | "require" | "warn" | "disable";
}
export interface ShaderDefine {
    readonly name: string;
    readonly value?: string;
}
export type ShaderPrecision = "high" | "medium" | "low";
export interface ShaderDefaultPrecisions {
    readonly float: ShaderPrecision;
    readonly int: ShaderPrecision;
    readonly sampler2D: ShaderPrecision;
    readonly samplerCube: ShaderPrecision;
    readonly sampler3D: ShaderPrecision;
    readonly samplerCubeShadow: ShaderPrecision;
    readonly sampler2DShadow: ShaderPrecision;
    readonly sampler2DArray: ShaderPrecision;
    readonly sampler2DArrayShadow: ShaderPrecision;
    readonly isampler2D: ShaderPrecision;
    readonly isampler3D: ShaderPrecision;
    readonly isamplerCube: ShaderPrecision;
    readonly isampler2DArray: ShaderPrecision;
    readonly usampler2D: ShaderPrecision;
    readonly usampler3D: ShaderPrecision;
    readonly usamplerCube: ShaderPrecision;
    readonly usampler2DArray: ShaderPrecision;
}
export interface ShaderHeaderParams {
    readonly version: "300 es";
    readonly extensions: readonly ShaderExtension[];
    readonly defaultPrecisions: Partial<ShaderDefaultPrecisions>;
    readonly flags: readonly string[];
    readonly defines: readonly ShaderDefine[];
    readonly commonChunk: string;
}
export interface ProgramParams {
    readonly vertexShader: string;
    readonly fragmentShader?: string;
    readonly headerChunk?: string;
    readonly flags?: readonly string[];
    readonly commonChunk?: string;
    readonly uniformBufferBlocks?: string[];
    readonly textureUniforms?: readonly string[];
    readonly transformFeedback?: {
        readonly bufferMode: "INTERLEAVED_ATTRIBS" | "SEPARATE_ATTRIBS";
        readonly varyings: readonly string[];
    };
}
//# sourceMappingURL=program.d.ts.map