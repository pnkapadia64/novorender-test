var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// /projects/Novorender/ts/node_modules/gl-matrix/esm/common.js
var common_exports = {};
__export(common_exports, {
  ARRAY_TYPE: () => ARRAY_TYPE,
  EPSILON: () => EPSILON,
  RANDOM: () => RANDOM,
  equals: () => equals,
  setMatrixArrayType: () => setMatrixArrayType,
  toRadian: () => toRadian
});
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a) {
  return a * degree;
}
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// /projects/Novorender/ts/node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  out[3] = a[3] + b[3] * scale7;
  out[4] = a[4] + b[4] * scale7;
  out[5] = a[5] + b[5] * scale7;
  out[6] = a[6] + b[6] * scale7;
  out[7] = a[7] + b[7] * scale7;
  out[8] = a[8] + b[8] * scale7;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract;

// /projects/Novorender/ts/node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len5 = Math.hypot(x, y, z);
  var s, c, t;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x *= len5;
  y *= len5;
  z *= len5;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len5 = Math.hypot(x0, x1, x2);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len5 = Math.hypot(y0, y1, y2);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y2 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  out[3] = a[3] + b[3] * scale7;
  out[4] = a[4] + b[4] * scale7;
  out[5] = a[5] + b[5] * scale7;
  out[6] = a[6] + b[6] * scale7;
  out[7] = a[7] + b[7] * scale7;
  out[8] = a[8] + b[8] * scale7;
  out[9] = a[9] + b[9] * scale7;
  out[10] = a[10] + b[10] * scale7;
  out[11] = a[11] + b[11] * scale7;
  out[12] = a[12] + b[12] * scale7;
  out[13] = a[13] + b[13] * scale7;
  out[14] = a[14] + b[14] * scale7;
  out[15] = a[15] + b[15] * scale7;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract2;

// /projects/Novorender/ts/node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone5,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set5,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// /projects/Novorender/ts/node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set3,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set3(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len5 = x * x + y * y + z * z;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a[0] * len5;
  out[1] = a[1] * len5;
  out[2] = a[2] * len5;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale7;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale7;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract3;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// /projects/Novorender/ts/node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set4(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  out[3] = a[3] + b[3] * scale7;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len5 = x * x + y * y + z * z + w * w;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x * len5;
  out[1] = y * len5;
  out[2] = z * len5;
  out[3] = w * len5;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross2(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0], B = v[0] * w[2] - v[2] * w[0], C = v[0] * w[3] - v[3] * w[0], D = v[1] * w[2] - v[2] * w[1], E = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale7) {
  scale7 = scale7 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale7 * v1;
  out[1] = scale7 * v2;
  out[2] = scale7 * v3 * d;
  out[3] = scale7 * v4 * d;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals5(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract4;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// /projects/Novorender/ts/node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot5 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone5 = clone4;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set5 = set4;
var add5 = add4;
var mul5 = multiply5;
var scale5 = scale4;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize3 = normalize2;
var exactEquals5 = exactEquals4;
var equals6 = equals5;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a, b) {
    var dot5 = dot(a, b);
    if (dot5 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// /projects/Novorender/ts/node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone6,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals7,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone6(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues6(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set6(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add6(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply6(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale6(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize4(out, a) {
  var x = a[0], y = a[1];
  var len5 = x * x + y * y;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a[0] * len5;
  out[1] = a[1] * len5;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross3(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a, b, t) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function random4(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale7;
  out[1] = Math.sin(r) * scale7;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate3(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals6(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals7(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len4 = length4;
var sub5 = subtract5;
var mul6 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var sqrLen4 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// /projects/Novorender/ts/dist/webgl2/blit.ts
function glBlit(gl, params) {
  const w = gl.drawingBufferWidth;
  const h = gl.drawingBufferHeight;
  let mask = 0;
  if (params.color)
    mask |= gl.COLOR_BUFFER_BIT;
  if (params.depth)
    mask |= gl.DEPTH_BUFFER_BIT;
  if (params.stencil)
    mask |= gl.STENCIL_BUFFER_BIT;
  const filter = gl[params.filter ?? "NEAREST"];
  const srcX0 = params.srcX0 ?? 0;
  const srcY0 = params.srcY0 ?? 0;
  const srcX1 = params.srcX1 ?? w;
  const srcY1 = params.srcY1 ?? h;
  const dstX0 = params.dstX0 ?? 0;
  const dstY0 = params.dstY0 ?? 0;
  const dstX1 = params.dstX1 ?? w;
  const dstY1 = params.dstY1 ?? h;
  const src = params.source == null ? null : params.source;
  const dst = params.destination == null ? null : params.destination;
  gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
  gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
  gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

// /projects/Novorender/ts/dist/webgl2/buffer.ts
function glCreateBuffer(gl, params) {
  const target = gl[params.kind];
  const usage = gl[params.usage ?? "STATIC_DRAW"];
  const buffer = gl.createBuffer();
  gl.bindBuffer(target, buffer);
  if ("byteSize" in params) {
    gl.bufferData(target, params.byteSize, usage);
  } else {
    gl.bufferData(target, params.srcData, usage);
  }
  gl.bindBuffer(target, null);
  return buffer;
}
function glUpdateBuffer(gl, params) {
  const target = gl[params.kind];
  const srcOffset = params.srcElementOffset ?? 0;
  const targetOffset = params.dstByteOffset ?? 0;
  const src = params.srcData;
  const srcData = ArrayBuffer.isView(src) ? src : new Uint8Array(src);
  gl.bindBuffer(target, params.targetBuffer);
  gl.bufferSubData(target, targetOffset, srcData, srcOffset, params.byteSize);
  gl.bindBuffer(target, null);
}

// /projects/Novorender/ts/dist/webgl2/clear.ts
function glClear(gl, params) {
  const { kind } = params;
  switch (kind) {
    case "back_buffer": {
      let bits = 0;
      if (params.color != void 0) {
        gl.clearColor(...params.color);
        bits |= gl.COLOR_BUFFER_BIT;
      }
      if (params.depth != void 0) {
        gl.clearDepth(params.depth);
        bits |= gl.DEPTH_BUFFER_BIT;
      }
      if (params.stencil != void 0) {
        gl.clearStencil(params.stencil);
        bits |= gl.STENCIL_BUFFER_BIT;
      }
      if (bits) {
        gl.clear(bits);
      }
      break;
    }
    case "DEPTH":
    case "STENCIL":
    case "DEPTH_STENCIL": {
      const { drawBuffer } = params;
      const depth = "depth" in params ? params.depth : 1;
      const stencil = "stencil" in params ? params.stencil : 0;
      gl.clearBufferfi(gl[kind], drawBuffer ?? 0, depth, stencil);
      break;
    }
    case "COLOR": {
      const { drawBuffer } = params;
      const type = params.type ?? "Float";
      const target = gl.COLOR;
      const color = params.color ?? [0, 0, 0, 0];
      switch (type) {
        case "Float":
          gl.clearBufferfv(target, drawBuffer ?? 0, color);
          break;
        case "Int":
          gl.clearBufferiv(target, drawBuffer ?? 0, color);
          break;
        case "Uint":
          gl.clearBufferuiv(target, drawBuffer ?? 0, color);
          break;
        default:
          exhaustiveColorCheck(type);
      }
      break;
    }
    default:
      exhaustiveBufferCheck(kind);
  }
}
function exhaustiveBufferCheck(value) {
  throw new Error(`Unknown buffer type: ${value}!`);
}
function exhaustiveColorCheck(value) {
  throw new Error(`Unknown clear color type: ${value}!`);
}

// /projects/Novorender/ts/dist/webgl2/extensions.ts
function glExtensions(gl, refresh = false) {
  let ext = glExtensionsMap.get(gl);
  if (!ext || refresh) {
    ext = getWebGL2Extensions(gl);
    glExtensionsMap.set(gl, ext);
  }
  return ext;
}
function getWebGL2Extensions(gl) {
  return {
    colorBufferFloat: gl.getExtension("EXT_color_buffer_float"),
    // also includes half floats
    parallelShaderCompile: gl.getExtension("KHR_parallel_shader_compile"),
    loseContext: gl.getExtension("WEBGL_lose_context"),
    multiDraw: gl.getExtension("WEBGL_MULTI_DRAW"),
    drawBuffersIndexed: gl.getExtension("OES_draw_buffers_indexed"),
    disjointTimerQuery: gl.getExtension("EXT_disjoint_timer_query_webgl2"),
    provokingVertex: gl.getExtension("WEBGL_provoking_vertex")
  };
}
var glExtensionsMap = /* @__PURE__ */ new WeakMap();

// /projects/Novorender/ts/dist/webgl2/draw.ts
function glDraw(gl, params) {
  let numPrimitives = 0;
  const mode = params.mode ?? "TRIANGLES";
  const primitiveType = gl[mode];
  if (isMultiDraw(params)) {
    const { multiDraw } = glExtensions(gl);
    if (multiDraw) {
      const { drawCount, counts, countsOffset } = params;
      switch (params.kind) {
        case "arrays_multidraw":
          const { firstsList, firstsOffset } = params;
          multiDraw.multiDrawArraysWEBGL(primitiveType, firstsList, firstsOffset ?? 0, counts, countsOffset ?? 0, drawCount);
          break;
        case "elements_multidraw":
          const { byteOffsets, byteOffsetsOffset, indexType } = params;
          multiDraw.multiDrawElementsWEBGL(primitiveType, counts, countsOffset ?? 0, gl[indexType], byteOffsets, byteOffsetsOffset ?? 0, drawCount);
          break;
      }
      const offs = countsOffset ?? 0;
      for (let i = 0; i < drawCount; i++) {
        numPrimitives += calcNumPrimitives(counts[i + offs], mode);
      }
    } else {
      console.warn("no multi_draw gl extension!");
    }
  } else {
    const { count } = params;
    if (isInstanced(params)) {
      const { instanceCount } = params;
      numPrimitives = calcNumPrimitives(count, mode) * instanceCount;
      if (isElements(params)) {
        gl.drawElementsInstanced(primitiveType, count, gl[params.indexType], params.byteOffset ?? 0, instanceCount);
      } else {
        gl.drawArraysInstanced(primitiveType, params.first ?? 0, count, instanceCount);
      }
    } else {
      numPrimitives = calcNumPrimitives(count, mode);
      if (isElements(params)) {
        if (isRange(params)) {
          gl.drawRangeElements(primitiveType, params.minIndex, params.maxIndex, count, gl[params.indexType], params.byteOffset ?? 0);
        } else {
          gl.drawElements(primitiveType, count, gl[params.indexType], params.byteOffset ?? 0);
        }
      } else {
        gl.drawArrays(primitiveType, params.first ?? 0, count);
      }
    }
  }
  if (primitiveType >= gl.TRIANGLES) {
    return { points: 0, lines: 0, triangles: numPrimitives };
  } else if (primitiveType >= gl.LINES) {
    return { points: 0, lines: numPrimitives, triangles: 0 };
  } else {
    return { points: numPrimitives, lines: 0, triangles: 0 };
  }
}
function calcNumPrimitives(vertexCount, primitiveType) {
  switch (primitiveType) {
    case "TRIANGLES":
      return vertexCount / 3;
    case "TRIANGLE_STRIP":
    case "TRIANGLE_FAN":
      return vertexCount - 2;
    case "LINES":
      return vertexCount / 2;
    case "LINE_STRIP":
      return vertexCount - 1;
    default:
      return vertexCount;
  }
}
function isInstanced(params) {
  return "instanceCount" in params && params.instanceCount != void 0;
}
function isElements(params) {
  return "indexType" in params && params.indexType != void 0;
}
function isRange(params) {
  return "start" in params && "end" in params && params.start != void 0;
}
function isMultiDraw(params) {
  return "drawCount" in params && params.drawCount != void 0;
}

// /projects/Novorender/ts/dist/webgl2/limits.ts
function glLimits(gl) {
  let ext = glLimitsMap.get(gl);
  if (!ext) {
    ext = getWebGL2Limits(gl);
    glLimitsMap.set(gl, ext);
  }
  return ext;
}
var glLimitsMap = /* @__PURE__ */ new WeakMap();
function getWebGL2Limits(gl) {
  const names = [
    "MAX_TEXTURE_SIZE",
    "MAX_VIEWPORT_DIMS",
    "MAX_TEXTURE_IMAGE_UNITS",
    "MAX_VERTEX_UNIFORM_VECTORS",
    "MAX_VARYING_VECTORS",
    "MAX_VERTEX_ATTRIBS",
    "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
    "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
    "MAX_TEXTURE_IMAGE_UNITS",
    "MAX_FRAGMENT_UNIFORM_VECTORS",
    "MAX_CUBE_MAP_TEXTURE_SIZE",
    "MAX_RENDERBUFFER_SIZE",
    "MAX_3D_TEXTURE_SIZE",
    "MAX_ELEMENTS_VERTICES",
    "MAX_ELEMENTS_INDICES",
    "MAX_TEXTURE_LOD_BIAS",
    "MAX_FRAGMENT_UNIFORM_COMPONENTS",
    "MAX_VERTEX_UNIFORM_COMPONENTS",
    "MAX_ARRAY_TEXTURE_LAYERS",
    "MIN_PROGRAM_TEXEL_OFFSET",
    "MAX_PROGRAM_TEXEL_OFFSET",
    "MAX_VARYING_COMPONENTS",
    "MAX_VERTEX_OUTPUT_COMPONENTS",
    "MAX_FRAGMENT_INPUT_COMPONENTS",
    "MAX_SERVER_WAIT_TIMEOUT",
    "MAX_ELEMENT_INDEX",
    "MAX_DRAW_BUFFERS",
    "MAX_COLOR_ATTACHMENTS",
    "MAX_SAMPLES",
    "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS",
    "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS",
    "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS",
    "MAX_VERTEX_UNIFORM_BLOCKS",
    "MAX_FRAGMENT_UNIFORM_BLOCKS",
    "MAX_COMBINED_UNIFORM_BLOCKS",
    "MAX_UNIFORM_BUFFER_BINDINGS",
    "MAX_UNIFORM_BLOCK_SIZE",
    "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS",
    "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"
  ];
  const limits = {};
  for (const name of names) {
    limits[name] = gl.getParameter(gl[name]);
  }
  return limits;
}

// /projects/Novorender/ts/dist/webgl2/frameBuffer.ts
function glCreateFrameBuffer(gl, params) {
  const frameBuffer = gl.createFramebuffer();
  const limits = glLimits(gl);
  console.assert(params.color.length <= limits.MAX_COLOR_ATTACHMENTS);
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  function bind(binding, attachment) {
    const target = gl[binding.kind];
    if (isTextureAttachment(binding)) {
      const { texture } = binding;
      if (binding.layer === void 0) {
        const texTarget = gl[binding.texTarget ?? "TEXTURE_2D"];
        gl.framebufferTexture2D(target, attachment, texTarget, texture, binding.level ?? 0);
      } else {
        gl.framebufferTextureLayer(target, attachment, texture, binding.level ?? 0, binding.layer);
      }
    } else {
      const { renderBuffer } = binding;
      gl.framebufferRenderbuffer(target, attachment, gl.RENDERBUFFER, renderBuffer);
    }
  }
  if (params.depth)
    bind(params.depth, gl.DEPTH_ATTACHMENT);
  if (params.stencil)
    bind(params.stencil, gl.STENCIL_ATTACHMENT);
  let i = gl.COLOR_ATTACHMENT0;
  for (const color of params.color) {
    if (color) {
      bind(color, i);
    }
    i++;
  }
  const debug = false;
  if (debug) {
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    switch (status) {
      case gl.FRAMEBUFFER_COMPLETE:
        break;
      case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        throw new Error("Framebuffer incomplete attachment!");
      case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        throw new Error("Framebuffer missing attachment!");
      case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        throw new Error("Framebuffer incomplete dimensions!");
      case gl.FRAMEBUFFER_UNSUPPORTED:
        throw new Error("Framebuffer unsupported!");
      case gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
        throw new Error("Framebuffer incomplete multisample!");
      default:
        throw new Error("Unknown framebuffer error!");
    }
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  return frameBuffer;
}
function glInvalidateFrameBuffer(gl, params) {
  if (!params.frameBuffer) {
    return;
  }
  const attachments = [];
  if (params.depth && params.stencil) {
    attachments.push(gl.DEPTH_STENCIL_ATTACHMENT);
  } else if (params.depth) {
    attachments.push(gl.DEPTH_ATTACHMENT);
  } else if (params.stencil) {
    attachments.push(gl.STENCIL_ATTACHMENT);
  }
  let i = 0;
  for (const invalidate of params.color) {
    if (invalidate) {
      attachments.push(gl.COLOR_ATTACHMENT0 + i);
    }
    i++;
  }
  const { frameBuffer, kind } = params;
  const target = gl[kind];
  gl.bindFramebuffer(target, frameBuffer);
  gl.invalidateFramebuffer(target, attachments);
  gl.bindFramebuffer(target, null);
}
function isTextureAttachment(attachment) {
  return typeof attachment == "object" && "texture" in attachment;
}

// /projects/Novorender/ts/dist/webgl2/misc.ts
function getBufferViewType(type) {
  switch (type) {
    case "BYTE":
      return Int8Array;
    case "UNSIGNED_BYTE":
      return Uint8Array;
    case "SHORT":
      return Int16Array;
    case "UNSIGNED_SHORT_5_6_5":
    case "UNSIGNED_SHORT_4_4_4_4":
    case "UNSIGNED_SHORT_5_5_5_1":
    case "HALF_FLOAT":
    case "HALF_FLOAT_OES":
      return Uint16Array;
    case "UNSIGNED_INT":
    case "UNSIGNED_INT_24_8_WEBGL":
    case "UNSIGNED_INT_5_9_9_9_REV":
    case "UNSIGNED_INT_2_10_10_10_REV":
    case "UNSIGNED_INT_10F_11F_11F_REV":
      return Uint32Array;
    case "INT":
      return Int32Array;
    case "FLOAT":
      return Float32Array;
  }
  throw new Error(`Unknown buffer type: ${type}!`);
}

// /projects/Novorender/ts/dist/webgl2/program.ts
function* glShaderExtensions(gl) {
  if (glExtensions(gl).multiDraw) {
    yield {
      name: "GL_ANGLE_multi_draw",
      behaviour: "require"
    };
  }
}
function glCompile(gl, params) {
  const source = params.shader;
  const shader = gl.createShader(gl[params.kind]);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}
function glCreateProgramAsync(gl, params) {
  const { header } = params;
  const headerCode = formatHeader(gl, header);
  const vertex = glCompile(gl, { kind: "VERTEX_SHADER", shader: headerCode + params.vertexShader });
  const fragment = glCompile(gl, { kind: "FRAGMENT_SHADER", shader: headerCode + (params.fragmentShader ?? "void main() {}") });
  const program = gl.createProgram();
  gl.attachShader(program, vertex);
  gl.attachShader(program, fragment);
  return { program, vertex, fragment };
}
function glCheckProgram(gl, params) {
  const { program, vertex, fragment } = params;
  if (gl.getProgramParameter(program, gl.LINK_STATUS) || gl.isContextLost()) {
    console.assert(gl.getProgramParameter(program, gl.ATTACHED_SHADERS) == 2);
    gl.detachShader(program, vertex);
    gl.detachShader(program, fragment);
    gl.deleteShader(vertex);
    gl.deleteShader(fragment);
  } else {
    const status = { link: gl.getProgramInfoLog(program), vertex: gl.getShaderInfoLog(vertex), fragment: gl.getShaderInfoLog(fragment) };
    return status;
  }
}
function glCreateProgram(gl, params) {
  const { flags, transformFeedback, uniformBufferBlocks, textureUniforms, headerChunk, commonChunk } = params;
  const extensions = [];
  if (glExtensions(gl).multiDraw) {
    extensions.push("#extension GL_ANGLE_multi_draw : require\n");
  }
  const defaultHeader = `#version 300 es
${extensions.join("")}precision highp float;
precision highp int;
precision highp usampler2D;
`;
  const header = headerChunk ?? defaultHeader;
  const defines = flags?.map((flag) => `#define ${flag}
`)?.join("") ?? "";
  const common = commonChunk ?? "";
  const vs = header + defines + common + params.vertexShader;
  const fs = header + defines + common + (params.fragmentShader ?? "void main() {}");
  const vertexShader = compileShader(gl, "VERTEX_SHADER", vs);
  const fragmentShader = compileShader(gl, "FRAGMENT_SHADER", fs);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  if (transformFeedback) {
    const { varyings, bufferMode } = transformFeedback;
    gl.transformFeedbackVaryings(program, varyings, gl[bufferMode]);
  }
  gl.linkProgram(program);
  gl.validateProgram(program);
  gl.detachShader(program, vertexShader);
  gl.detachShader(program, fragmentShader);
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost())
    throw new Error(`Failed to compile link shaders!\r
${gl.getProgramInfoLog(program)}`);
  gl.useProgram(program);
  if (uniformBufferBlocks) {
    let idx = 0;
    for (const name of uniformBufferBlocks) {
      if (name) {
        const blockIndex = gl.getUniformBlockIndex(program, name);
        if (blockIndex != gl.INVALID_INDEX) {
          gl.uniformBlockBinding(program, blockIndex, idx);
        } else {
          console.warn(`Shader has no uniform block named: ${name}!`);
        }
      }
      idx++;
    }
  }
  if (textureUniforms) {
    let i = 0;
    for (const name of textureUniforms) {
      const location = gl.getUniformLocation(program, name);
      gl.uniform1i(location, i++);
    }
  }
  gl.useProgram(null);
  return program;
}
function compileShader(gl, type, source) {
  const shader = gl.createShader(gl[type]);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost()) {
    const typeName = type.split("_")[0].toLocaleLowerCase();
    const errorMsg = gl.getShaderInfoLog(shader);
    throw new Error(`: Failed to compile glsl ${typeName} shader!\r
${errorMsg}`);
  }
  return shader;
}
function defaultHeaderParams(gl) {
  return {
    version: "300 es",
    extensions: [...glShaderExtensions(gl)],
    defaultPrecisions: {
      float: "high",
      int: "high",
      sampler2D: "high",
      samplerCube: "high",
      sampler3D: "high",
      samplerCubeShadow: "high",
      sampler2DShadow: "high",
      sampler2DArray: "high",
      sampler2DArrayShadow: "high",
      isampler2D: "high",
      isampler3D: "high",
      isamplerCube: "high",
      isampler2DArray: "high",
      usampler2D: "high",
      usampler3D: "high",
      usamplerCube: "high",
      usampler2DArray: "high"
    },
    flags: [],
    defines: [],
    commonChunk: ""
  };
}
function formatHeader(gl, params) {
  if (!params)
    return "";
  if (typeof params == "string")
    return params;
  const p = { ...defaultHeaderParams(gl), ...params };
  const version3 = `#version ${p.version}
`;
  const extensions = p.extensions.map((ext) => `#extension ${ext.name} : ${ext.behaviour}
`).join("");
  const precisions = Object.entries(p.defaultPrecisions).map(([type, precision]) => `precision ${precision}p ${type};
`).join("");
  const flags = p.flags.map((flag) => `#define ${flag}
`).join("");
  const defines = p.defines.map((def) => `#define ${def.name} ${def.value}
`).join("");
  const common = p.commonChunk;
  const header = version3 + extensions + precisions + flags + defines + common;
  return header;
}

// /projects/Novorender/ts/dist/webgl2/read.ts
function glReadPixels(gl, params) {
  const x = params.x ?? 0;
  const y = params.y ?? 0;
  const width = params.width ?? gl.drawingBufferWidth;
  const height = params.height ?? gl.drawingBufferHeight;
  gl.bindFramebuffer(gl.FRAMEBUFFER, params.frameBuffer);
  for (const { buffer, attachment, format, type } of params.buffers) {
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
    gl.readBuffer(gl[attachment]);
    gl.readPixels(x, y, width, height, gl[format], gl[type], 0);
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  gl.readBuffer(gl.BACK);
}

// /projects/Novorender/ts/dist/webgl2/renderBuffer.ts
function glCreateRenderbuffer(gl, params) {
  const limits = glLimits(gl);
  const buffer = gl.createRenderbuffer();
  const { internalFormat, width, height } = params;
  const samples = params.samples == void 0 ? 1 : params.samples === "max" ? limits.MAX_SAMPLES : params.samples;
  console.assert(samples <= limits.MAX_SAMPLES);
  gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
  if (params.samples === void 0) {
    gl.renderbufferStorage(gl.RENDERBUFFER, gl[internalFormat], width, height);
  } else {
    gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl[internalFormat], width, height);
  }
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  return buffer;
}

// /projects/Novorender/ts/dist/webgl2/sampler.ts
function glCreateSampler(gl, params) {
  const sampler = gl.createSampler();
  gl.bindSampler(0, sampler);
  const { minificationFilter, magnificationFilter, minLOD, maxLOD, wrap: wrap2, compareFunction, compareMode } = params;
  if (minificationFilter)
    gl.samplerParameteri(sampler, gl.TEXTURE_MIN_FILTER, gl[minificationFilter]);
  if (magnificationFilter)
    gl.samplerParameteri(sampler, gl.TEXTURE_MAG_FILTER, gl[magnificationFilter]);
  if (wrap2) {
    const [s, t, r] = wrap2;
    gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_S, gl[s]);
    gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_T, gl[t]);
    if (r)
      gl.samplerParameteri(sampler, gl.TEXTURE_WRAP_R, gl[r]);
  }
  if (minLOD)
    gl.samplerParameterf(sampler, gl.TEXTURE_MIN_LOD, minLOD);
  if (maxLOD)
    gl.samplerParameterf(sampler, gl.TEXTURE_MAX_LOD, maxLOD);
  if (compareFunction)
    gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_FUNC, gl[compareFunction]);
  if (compareMode)
    gl.samplerParameteri(sampler, gl.TEXTURE_COMPARE_MODE, gl[compareMode]);
  return sampler;
}

// /projects/Novorender/ts/dist/webgl2/state.ts
function glState(gl, params) {
  if (!params) {
    const limits = glLimits(gl);
    params = glDefaultState(limits);
  }
  const { blend, cull, depth, polygon, sample, scissor, stencil, frameBuffer, vertexArrayObject, drawBuffers, attributeDefaults, textures, uniforms, uniformBuffers } = params;
  function setFlag(cap, value) {
    if (value !== void 0) {
      if (value) {
        gl.enable(gl[cap]);
      } else {
        gl.disable(gl[cap]);
      }
    }
  }
  function set7(setter, values, defaultValues, ...keys) {
    if (keys.some((key) => values[key] !== void 0)) {
      const args = keys.map((key) => {
        const v = values[key] ?? defaultValues[key];
        return typeof v == "string" ? gl[v] : v;
      });
      setter.apply(gl, args);
    }
  }
  setFlag("DITHER", params.ditherEnable);
  setFlag("RASTERIZER_DISCARD", params.rasterizerDiscard);
  set7((rgba) => {
    gl.colorMask(...rgba);
  }, params, "colorMask");
  set7((rect) => gl.viewport(rect.x ?? 0, rect.y ?? 0, rect.width, rect.height), params, defaultConstants, "viewport");
  if (blend) {
    const defaultValues = defaultConstants.blend;
    const { drawBuffersIndexed } = glExtensions(gl);
    if (drawBuffersIndexed) {
      if (blend.enable) {
        drawBuffersIndexed.enableiOES(gl.BLEND, 0);
      } else {
        drawBuffersIndexed.disableiOES(gl.BLEND, 0);
      }
      set7((modeRGB, modeAlpha) => drawBuffersIndexed.blendEquationSeparateiOES(0, modeRGB, modeAlpha), blend, defaultValues, "equationRGB", "equationAlpha");
      set7((srcRGB, dstRGB, srcAlpha, dstAlpha) => drawBuffersIndexed.blendFuncSeparateiOES(0, srcRGB, dstRGB, srcAlpha, dstAlpha), blend, defaultValues, "srcRGB", "dstRGB", "srcAlpha", "dstAlpha");
    } else {
      setFlag("BLEND", blend.enable);
      set7(gl.blendEquationSeparate, blend, defaultValues, "equationRGB", "equationAlpha");
      set7(gl.blendFuncSeparate, blend, defaultValues, "srcRGB", "dstRGB", "srcAlpha", "dstAlpha");
    }
    set7((rgba) => {
      gl.blendColor(...rgba);
    }, blend, defaultValues, "color");
  }
  if (cull) {
    const defaultValues = defaultConstants.cull;
    setFlag("CULL_FACE", cull.enable);
    set7(gl.cullFace, cull, defaultValues, "mode");
    set7(gl.frontFace, cull, defaultValues, "frontFace");
  }
  if (depth) {
    const defaultValues = defaultConstants.depth;
    setFlag("DEPTH_TEST", depth.test);
    set7(gl.depthFunc, depth, defaultValues, "func");
    set7(gl.depthMask, depth, defaultValues, "writeMask");
    set7((range) => gl.depthRange(...range), depth, defaultValues, "range");
  }
  if (polygon) {
    const defaultValues = defaultConstants.polygon;
    setFlag("POLYGON_OFFSET_FILL", polygon.offsetFill);
    set7(gl.polygonOffset, polygon, defaultValues, "offsetFactor", "offsetUnits");
  }
  if (sample) {
    const defaultValues = defaultConstants.sample;
    setFlag("SAMPLE_ALPHA_TO_COVERAGE", sample.alphaToCoverage);
    setFlag("SAMPLE_COVERAGE", sample.coverage);
    set7(gl.sampleCoverage, sample, defaultValues, "coverageValue", "coverageInvert");
  }
  if (scissor) {
    const defaultValues = defaultConstants.scissor;
    setFlag("SCISSOR_TEST", scissor.test);
    set7((rect) => gl.scissor(rect.x ?? 0, rect.y ?? 0, rect.width, rect.height), scissor, defaultValues, "box");
  }
  if (stencil) {
    const defaultValues = defaultConstants.stencil;
    setFlag("STENCIL_TEST", stencil.test);
    set7((func, ref, mask) => gl.stencilFuncSeparate(gl.FRONT, func, ref, mask), stencil, defaultValues, "func", "ref", "valueMask");
    set7((func, ref, mask) => gl.stencilFuncSeparate(gl.BACK, func, ref, mask), stencil, defaultValues, "backFunc", "backRef", "backValueMask");
  }
  if (vertexArrayObject !== void 0) {
    gl.bindVertexArray(vertexArrayObject);
  }
  if (frameBuffer !== void 0) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  }
  if (drawBuffers) {
    gl.drawBuffers(drawBuffers.map((b) => gl[b]));
  }
  const { program } = params;
  if (program !== void 0) {
    gl.useProgram(program);
  }
  if (attributeDefaults) {
    for (let i = 0; i < attributeDefaults.length; i++) {
      const defaults = attributeDefaults[i];
      if (defaults) {
        const { type, values } = defaults;
        gl[`vertexAttrib${type}v`](i, values);
      }
    }
  }
  if (textures) {
    const texture0 = gl.TEXTURE0;
    for (let i = 0; i < textures.length; i++) {
      const binding = textures[i];
      const texture = binding?.texture ?? null;
      gl.activeTexture(texture0 + i);
      gl.bindTexture(gl[binding?.kind ?? "TEXTURE_2D"], texture);
      const sampler = binding?.sampler ?? null;
      gl.bindSampler(i, sampler);
      gl.uniform1i(binding?.uniform ?? null, i);
    }
    gl.activeTexture(texture0);
  }
  if (uniforms) {
    let isMatrix3 = function(binding) {
      return binding.kind.startsWith("Matrix");
    }, isScalar2 = function(binding) {
      return binding.kind.startsWith("1");
    };
    var isMatrix2 = isMatrix3, isScalar = isScalar2;
    for (const binding of uniforms) {
      if (isMatrix3(binding)) {
        const methodName = `uniform${binding.kind}v`;
        gl[methodName](binding.location, binding.transpose ?? false, binding.value);
      } else if (isScalar2(binding)) {
        const methodName = `uniform${binding.kind}`;
        gl[methodName](binding.location, binding.value);
      } else {
        const methodName = `uniform${binding.kind}v`;
        gl[methodName](binding.location, binding.value);
      }
    }
  }
  if (uniformBuffers) {
    let idx = 0;
    for (const uniformBindingParams of uniformBuffers) {
      if (uniformBindingParams === void 0)
        continue;
      if (isUniformBufferBindingRange(uniformBindingParams)) {
        const { buffer, byteOffset, byteSize } = uniformBindingParams;
        gl.bindBufferRange(gl.UNIFORM_BUFFER, idx, buffer, byteOffset, byteSize);
      } else {
        gl.bindBufferBase(gl.UNIFORM_BUFFER, idx, uniformBindingParams);
      }
      idx++;
    }
  }
}
function glDefaultState(limits) {
  return {
    ...defaultConstants,
    drawBuffers: ["BACK"],
    attributeDefaults: Array(limits.MAX_VERTEX_ATTRIBS).fill({ type: "4f", values: [0, 0, 0, 1] }),
    textures: Array(limits.MAX_COMBINED_TEXTURE_IMAGE_UNITS).fill(null)
  };
}
function isUniformBufferBindingRange(params) {
  return params != null && "byteOffset" in params && "byteSize" in params;
}
var defaultConstants = {
  blend: {
    enable: false,
    // BLEND
    color: [0, 0, 0, 0],
    // BLEND_COLOR
    dstAlpha: "ZERO",
    // BLEND_DST_ALPHA
    dstRGB: "ZERO",
    // BLEND_DST_RGB
    equationAlpha: "FUNC_ADD",
    // BLEND_EQUATION_ALPHA
    equationRGB: "FUNC_ADD",
    // BLEND_EQUATION_RGB
    srcAlpha: "ONE",
    // BLEND_EQUATION_ALPHA
    srcRGB: "ONE"
    // BLEND_SRC_RGB
  },
  cull: {
    enable: false,
    // CULL_FACE
    mode: "BACK",
    // CULL_FACE_MODE
    frontFace: "CCW"
    // FRONT_FACE
  },
  depth: {
    test: false,
    // DEPTH_TEST
    func: "LESS",
    // DEPTH_FUNC
    writeMask: true,
    // DEPTH_WRITEMASK
    range: [0, 1]
    // DEPTH_RANGE
  },
  ditherEnable: true,
  // DITHER
  colorMask: [true, true, true, true],
  polygon: {
    offsetFill: false,
    // POLYGON_OFFSET_FILL
    offsetFactor: 0,
    // POLYGON_OFFSET_FACTOR
    offsetUnits: 0
    // POLYGON_OFFSET_UNITS
  },
  sample: {
    alphaToCoverage: false,
    // SAMPLE_ALPHA_TO_COVERAGE
    coverage: false,
    // SAMPLE_COVERAGE
    coverageValue: 1,
    // SAMPLE_COVERAGE_VALUE
    coverageInvert: false
    // SAMPLE_COVERAGE_INVERT
  },
  stencil: {
    test: false,
    // STENCIL_TEST
    func: "ALWAYS",
    // STENCIL_FUNC
    valueMask: 2147483647,
    // STENCIL_VALUE_MASK
    ref: 0,
    // STENCIL_REF
    backFunc: "ALWAYS",
    // STENCIL_BACK_FUNC
    backValueMask: 2147483647,
    // STENCIL_BACK_VALUE_MASK
    backRef: 0
    // STENCIL_BACK_REF
  },
  viewport: {
    // VIEWPORT
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  scissor: {
    test: false,
    // SCISSOR_TEST
    box: {
      // SCISSOR_BOX
      x: 0,
      y: 0,
      width: 0,
      height: 0
    }
  },
  rasterizerDiscard: false,
  // RASTERIZER_DISCARD
  frameBuffer: null,
  vertexArrayObject: null,
  program: null,
  uniforms: [],
  uniformBuffers: []
  // max length: MAX_UNIFORM_BUFFER_BINDINGS
};

// /projects/Novorender/ts/dist/webgl2/texture.ts
function glCreateTexture(gl, params) {
  const texture = gl.createTexture();
  const width = params.width ?? params.image.width;
  const height = params.height ?? params.image.height;
  const target = gl[params.kind];
  const depth = "depth" in params ? params.depth : void 0;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, texture);
  const { internalFormat, format, type, arrayType } = getFormatInfo(gl, params.internalFormat, "type" in params ? params.type : void 0);
  function textureImage(imgTarget, data, level, sizeX, sizeY, sizeZ = 0) {
    if (!data)
      return;
    const source = data;
    const view = ArrayBuffer.isView(source) ? source : void 0;
    const buffer = ArrayBuffer.isView(view) ? view.buffer : source;
    const byteOffset = view?.byteOffset ?? 0;
    const byteLength = view?.byteLength ?? buffer?.byteLength;
    const pixels = buffer === null ? null : new arrayType(buffer, byteOffset, byteLength / arrayType.BYTES_PER_ELEMENT);
    const offsetX = 0;
    const offsetY = 0;
    const offsetZ = 0;
    if (type) {
      if (sizeZ) {
        gl.texSubImage3D(imgTarget, level, offsetX, offsetY, offsetZ, sizeX, sizeY, sizeZ, format, type, pixels);
      } else {
        gl.texSubImage2D(imgTarget, level, offsetX, offsetY, sizeX, sizeY, format, type, pixels);
      }
    } else {
      if (sizeZ) {
        gl.compressedTexSubImage3D(imgTarget, level, offsetX, offsetY, offsetZ, sizeX, sizeY, sizeZ, internalFormat, pixels);
      } else {
        gl.compressedTexSubImage2D(imgTarget, level, offsetX, offsetY, sizeX, sizeY, internalFormat, pixels);
      }
    }
  }
  function textureMipLevel(level, image) {
    function isArray(img) {
      return Array.isArray(img);
    }
    const n = 1 << level;
    if (isArray(image)) {
      console.assert(target == gl.TEXTURE_CUBE_MAP);
      const cubeImages = image[level];
      if (cubeImages) {
        let side = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        for (let img of image) {
          textureImage(side++, img, level, width / n, height / n);
        }
      }
    } else {
      if (depth) {
        if (target == gl.TEXTURE_3D) {
          textureImage(gl.TEXTURE_3D, image, level, width / n, height / n, depth / n);
        } else {
          console.assert(target == gl.TEXTURE_2D_ARRAY);
          textureImage(gl.TEXTURE_3D, image, level, width / n, height / n, depth);
        }
      } else {
        console.assert(target == gl.TEXTURE_2D);
        textureImage(gl.TEXTURE_2D, image, level, width, height);
      }
    }
  }
  function textureStorage(levels = 1) {
    if (depth) {
      gl.texStorage3D(target, levels, internalFormat, width, height, depth);
    } else {
      gl.texStorage2D(target, levels, internalFormat, width, height);
    }
  }
  if ("mipMaps" in params) {
    const { mipMaps } = params;
    const isNumber = typeof mipMaps == "number";
    const levels = isNumber ? mipMaps : mipMaps.length;
    textureStorage(levels);
    if (!isNumber) {
      for (let level = 0; level < levels; level++) {
        const mipMap = mipMaps[level];
        if (mipMap) {
          textureMipLevel(level, mipMap);
        }
      }
    }
  } else if (isBufferSource(params.image)) {
    const generateMipMaps = "generateMipMaps" in params && params.generateMipMaps;
    if (generateMipMaps && !(isPowerOf2(width) && isPowerOf2(height) && type)) {
      throw new Error(`Cannot generate mip maps on a texture of non-power of two sizes (${width}, ${height})!`);
    }
    const levels = generateMipMaps ? Math.log2(Math.min(width, height)) : 1;
    textureStorage(levels);
    textureMipLevel(0, params.image);
    if (generateMipMaps && params.image) {
      gl.generateMipmap(target);
    }
  } else {
    const generateMipMaps = "generateMipMaps" in params && params.generateMipMaps;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, params.image);
    if (generateMipMaps && isPowerOf2(width) && isPowerOf2(height)) {
      gl.generateMipmap(target);
    }
  }
  gl.bindTexture(target, null);
  return texture;
}
function glUpdateTexture(gl, targetTexture, params) {
  const width = params.width ?? params.image.width;
  const height = params.height ?? params.image.height;
  const target = gl[params.kind];
  const depth = "depth" in params ? params.depth : void 0;
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(target, targetTexture);
  const { internalFormat, format, type, arrayType } = getFormatInfo(gl, params.internalFormat, "type" in params ? params.type : void 0);
  function textureImage(imgTarget, data, level, sizeX, sizeY, sizeZ = 0) {
    if (!data)
      return;
    const source = data;
    const view = ArrayBuffer.isView(source) ? source : void 0;
    const buffer = ArrayBuffer.isView(view) ? view.buffer : source;
    const byteOffset = view?.byteOffset ?? 0;
    const byteLength = view?.byteLength ?? buffer?.byteLength;
    const pixels = buffer === null ? null : new arrayType(buffer, byteOffset, byteLength / arrayType.BYTES_PER_ELEMENT);
    const offsetX = 0;
    const offsetY = 0;
    const offsetZ = 0;
    if (type) {
      if (sizeZ) {
        gl.texSubImage3D(imgTarget, level, offsetX, offsetY, offsetZ, sizeX, sizeY, sizeZ, format, type, pixels);
      } else {
        gl.texSubImage2D(imgTarget, level, offsetX, offsetY, sizeX, sizeY, format, type, pixels);
      }
    } else {
      if (sizeZ) {
        gl.compressedTexSubImage3D(imgTarget, level, offsetX, offsetY, offsetZ, sizeX, sizeY, sizeZ, internalFormat, pixels);
      } else {
        gl.compressedTexSubImage2D(imgTarget, level, offsetX, offsetY, sizeX, sizeY, internalFormat, pixels);
      }
    }
  }
  function textureMipLevel(level, image) {
    function isArray(img) {
      return Array.isArray(img);
    }
    const n = 1 << level;
    if (isArray(image)) {
      console.assert(target == gl.TEXTURE_CUBE_MAP);
      const cubeImages = image[level];
      if (cubeImages) {
        let side = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        for (let img of image) {
          textureImage(side++, img, level, width / n, height / n);
        }
      }
    } else {
      if (depth) {
        if (target == gl.TEXTURE_3D) {
          textureImage(gl.TEXTURE_3D, image, level, width / n, height / n, depth / n);
        } else {
          console.assert(target == gl.TEXTURE_2D_ARRAY);
          textureImage(gl.TEXTURE_3D, image, level, width / n, height / n, depth);
        }
      } else {
        console.assert(target == gl.TEXTURE_2D);
        textureImage(gl.TEXTURE_2D, image, level, width, height);
      }
    }
  }
  if ("mipMaps" in params) {
    const { mipMaps } = params;
    const isNumber = typeof mipMaps == "number";
    const levels = isNumber ? mipMaps : mipMaps.length;
    if (!isNumber) {
      for (let level = 0; level < levels; level++) {
        const mipMap = mipMaps[level];
        if (mipMap) {
          textureMipLevel(level, mipMap);
        }
      }
    }
  } else if (isBufferSource(params.image)) {
    const generateMipMaps = "generateMipMaps" in params && params.generateMipMaps;
    if (generateMipMaps && !(isPowerOf2(width) && isPowerOf2(height) && type)) {
      throw new Error(`Cannot generate mip maps on a texture of non-power of two sizes (${width}, ${height})!`);
    }
    const levels = generateMipMaps ? Math.log2(Math.min(width, height)) : 1;
    textureMipLevel(0, params.image);
    if (generateMipMaps && params.image) {
      gl.generateMipmap(target);
    }
  } else {
    const generateMipMaps = "generateMipMaps" in params && params.generateMipMaps;
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, params.image);
    if (generateMipMaps && isPowerOf2(width) && isPowerOf2(height)) {
      gl.generateMipmap(target);
    }
  }
  gl.bindTexture(target, null);
}
function isPowerOf2(value) {
  return (value & value - 1) == 0;
}
function isFormatCompressed(format) {
  return format.startsWith("COMPRESSED");
}
function isBufferSource(image) {
  return image == void 0 || Array.isArray(image) || image instanceof ArrayBuffer || ArrayBuffer.isView(image);
}
function getFormatInfo(gl, internalFormatString, typeString) {
  if (isFormatCompressed(internalFormatString)) {
    const internalFormat = compressedFormats[internalFormatString];
    const format = void 0;
    const type = void 0;
    const arrayType = Uint8Array;
    return { internalFormat, format, type, arrayType };
  } else {
    const internalFormat = gl[internalFormatString];
    const format = internalFormat2FormatLookup[internalFormat];
    const type = gl[typeString];
    const arrayType = getBufferViewType(typeString);
    return { internalFormat, format, type, arrayType };
  }
}
var internalFormat2FormatLookup = {
  [6407 /* RGB */]: 6407 /* RGB */,
  [6408 /* RGBA */]: 6408 /* RGBA */,
  [6410 /* LUMINANCE_ALPHA */]: 6410 /* LUMINANCE_ALPHA */,
  [6409 /* LUMINANCE */]: 6409 /* LUMINANCE */,
  [6406 /* ALPHA */]: 6406 /* ALPHA */,
  [33321 /* R8 */]: 6403 /* RED */,
  [36756 /* R8_SNORM */]: 6403 /* RED */,
  [33323 /* RG8 */]: 33319 /* RG */,
  [36757 /* RG8_SNORM */]: 33319 /* RG */,
  [32849 /* RGB8 */]: 6407 /* RGB */,
  [36758 /* RGB8_SNORM */]: 6407 /* RGB */,
  [36194 /* RGB565 */]: 6407 /* RGB */,
  [32854 /* RGBA4 */]: 6408 /* RGBA */,
  [32855 /* RGB5_A1 */]: 6408 /* RGBA */,
  [32856 /* RGBA8 */]: 6408 /* RGBA */,
  [36759 /* RGBA8_SNORM */]: 6408 /* RGBA */,
  [32857 /* RGB10_A2 */]: 6408 /* RGBA */,
  [36975 /* RGB10_A2UI */]: 36249 /* RGBA_INTEGER */,
  [35905 /* SRGB8 */]: 6407 /* RGB */,
  [35907 /* SRGB8_ALPHA8 */]: 6408 /* RGBA */,
  [33325 /* R16F */]: 6403 /* RED */,
  [33327 /* RG16F */]: 33319 /* RG */,
  [34843 /* RGB16F */]: 6407 /* RGB */,
  [34842 /* RGBA16F */]: 6408 /* RGBA */,
  [33326 /* R32F */]: 6403 /* RED */,
  [33328 /* RG32F */]: 33319 /* RG */,
  [34837 /* RGB32F */]: 6407 /* RGB */,
  [34836 /* RGBA32F */]: 6408 /* RGBA */,
  [35898 /* R11F_G11F_B10F */]: 6407 /* RGB */,
  [35901 /* RGB9_E5 */]: 6407 /* RGB */,
  [33329 /* R8I */]: 36244 /* RED_INTEGER */,
  [33330 /* R8UI */]: 36244 /* RED_INTEGER */,
  [33331 /* R16I */]: 36244 /* RED_INTEGER */,
  [33332 /* R16UI */]: 36244 /* RED_INTEGER */,
  [33333 /* R32I */]: 36244 /* RED_INTEGER */,
  [33334 /* R32UI */]: 36244 /* RED_INTEGER */,
  [33335 /* RG8I */]: 33320 /* RG_INTEGER */,
  [33336 /* RG8UI */]: 33320 /* RG_INTEGER */,
  [33337 /* RG16I */]: 33320 /* RG_INTEGER */,
  [33338 /* RG16UI */]: 33320 /* RG_INTEGER */,
  [33339 /* RG32I */]: 33320 /* RG_INTEGER */,
  [33340 /* RG32UI */]: 33320 /* RG_INTEGER */,
  [36239 /* RGB8I */]: 36248 /* RGB_INTEGER */,
  [36221 /* RGB8UI */]: 36248 /* RGB_INTEGER */,
  [36233 /* RGB16I */]: 36248 /* RGB_INTEGER */,
  [36215 /* RGB16UI */]: 36248 /* RGB_INTEGER */,
  [36227 /* RGB32I */]: 36248 /* RGB_INTEGER */,
  [36209 /* RGB32UI */]: 36248 /* RGB_INTEGER */,
  [36238 /* RGBA8I */]: 36249 /* RGBA_INTEGER */,
  [36220 /* RGBA8UI */]: 36249 /* RGBA_INTEGER */,
  [36232 /* RGBA16I */]: 36249 /* RGBA_INTEGER */,
  [36214 /* RGBA16UI */]: 36249 /* RGBA_INTEGER */,
  [36226 /* RGBA32I */]: 36249 /* RGBA_INTEGER */,
  [36208 /* RGBA32UI */]: 36249 /* RGBA_INTEGER */,
  [33189 /* DEPTH_COMPONENT16 */]: 6402 /* DEPTH_COMPONENT */,
  [33190 /* DEPTH_COMPONENT24 */]: 6402 /* DEPTH_COMPONENT */,
  [36012 /* DEPTH_COMPONENT32F */]: 6402 /* DEPTH_COMPONENT */,
  [35056 /* DEPTH24_STENCIL8 */]: 34041 /* DEPTH_STENCIL */,
  [36013 /* DEPTH32F_STENCIL8 */]: 34041 /* DEPTH_STENCIL */
};
var compressedFormats = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */,
  // WEBGL_compressed_texture_s3tc_srgb
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916 /* COMPRESSED_SRGB_S3TC_DXT1_EXT */,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT */,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT */,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919 /* COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT */,
  // WEBGL_compressed_texture_etc
  COMPRESSED_R11_EAC: 37488 /* COMPRESSED_R11_EAC */,
  COMPRESSED_SIGNED_R11_EAC: 37489 /* COMPRESSED_SIGNED_R11_EAC */,
  COMPRESSED_RG11_EAC: 37490 /* COMPRESSED_RG11_EAC */,
  COMPRESSED_SIGNED_RG11_EAC: 37491 /* COMPRESSED_SIGNED_RG11_EAC */,
  COMPRESSED_RGB8_ETC2: 37492 /* COMPRESSED_RGB8_ETC2 */,
  COMPRESSED_RGBA8_ETC2_EAC: 37493 /* COMPRESSED_RGBA8_ETC2_EAC */,
  COMPRESSED_SRGB8_ETC2: 37494 /* COMPRESSED_SRGB8_ETC2 */,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */,
  // WEBGL_compressed_texture_etc1    
  COMPRESSED_RGB_ETC1_WEBGL: 36196 /* COMPRESSED_RGB_ETC1_WEBGL */,
  // WEBGL_compressed_texture_astc    
  COMPRESSED_RGBA_ASTC_4x4_KHR: 37808 /* COMPRESSED_RGBA_ASTC_4x4_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: 37840 /* COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR */,
  COMPRESSED_RGBA_ASTC_5x4_KHR: 37809 /* COMPRESSED_RGBA_ASTC_5x4_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR: 37841 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR */,
  COMPRESSED_RGBA_ASTC_5x5_KHR: 37810 /* COMPRESSED_RGBA_ASTC_5x5_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR: 37842 /* COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR */,
  COMPRESSED_RGBA_ASTC_6x5_KHR: 37811 /* COMPRESSED_RGBA_ASTC_6x5_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR: 37843 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR */,
  COMPRESSED_RGBA_ASTC_6x6_KHR: 37812 /* COMPRESSED_RGBA_ASTC_6x6_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR: 37844 /* COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR */,
  COMPRESSED_RGBA_ASTC_8x5_KHR: 37813 /* COMPRESSED_RGBA_ASTC_8x5_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR: 37845 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR */,
  COMPRESSED_RGBA_ASTC_8x6_KHR: 37814 /* COMPRESSED_RGBA_ASTC_8x6_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR: 37846 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR */,
  COMPRESSED_RGBA_ASTC_8x8_KHR: 37815 /* COMPRESSED_RGBA_ASTC_8x8_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR: 37847 /* COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR */,
  COMPRESSED_RGBA_ASTC_10x5_KHR: 37816 /* COMPRESSED_RGBA_ASTC_10x5_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR: 37848 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR */,
  COMPRESSED_RGBA_ASTC_10x6_KHR: 37817 /* COMPRESSED_RGBA_ASTC_10x6_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR: 37849 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR */,
  COMPRESSED_RGBA_ASTC_10x10_KHR: 37819 /* COMPRESSED_RGBA_ASTC_10x10_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR: 37851 /* COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR */,
  COMPRESSED_RGBA_ASTC_12x10_KHR: 37820 /* COMPRESSED_RGBA_ASTC_12x10_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR: 37852 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR */,
  COMPRESSED_RGBA_ASTC_12x12_KHR: 37821 /* COMPRESSED_RGBA_ASTC_12x12_KHR */,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR: 37853 /* COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR */,
  // EXT_texture_compression_bptc    
  COMPRESSED_RGBA_BPTC_UNORM_EXT: 36492 /* COMPRESSED_RGBA_BPTC_UNORM_EXT */,
  COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT: 36493 /* COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT */,
  COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT: 36494 /* COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT */,
  COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT: 36495 /* COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT */,
  // EXT_texture_compression_rgtc    
  COMPRESSED_RED_RGTC1_EXT: 36283 /* COMPRESSED_RED_RGTC1_EXT */,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284 /* COMPRESSED_SIGNED_RED_RGTC1_EXT */,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285 /* COMPRESSED_RED_GREEN_RGTC2_EXT */,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286 /* COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT */
};

// /projects/Novorender/ts/dist/webgl2/timer.ts
function glCreateTimer(gl, cpuFallback = false) {
  const { disjointTimerQuery } = glExtensions(gl);
  if (disjointTimerQuery) {
    gl.getParameter(disjointTimerQuery.GPU_DISJOINT_EXT);
    const useTimestamps = gl.getQuery(disjointTimerQuery.TIMESTAMP_EXT, disjointTimerQuery.QUERY_COUNTER_BITS_EXT) ?? 0 > 0;
    if (useTimestamps)
      return new GPUTimerTS(gl, disjointTimerQuery);
    else
      return new GPUTimer(gl, disjointTimerQuery);
  } else {
    if (cpuFallback) {
      return new CPUTimer(gl);
    } else {
      return new NullTimer(gl);
    }
  }
}
var NullTimer = class {
  constructor(gl) {
    this.gl = gl;
    this.creationTime = performance.now();
    this.promise = Promise.resolve(void 0);
  }
  kind = "null";
  promise;
  creationTime;
  dispose() {
  }
  begin() {
  }
  end() {
  }
  poll() {
    return true;
  }
};
var CPUTimer = class {
  constructor(gl) {
    this.gl = gl;
    this.creationTime = performance.now();
    this.promise = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  kind = "cpu";
  promise;
  creationTime;
  beginTime = 0;
  endTime = 0;
  resolve;
  dispose() {
    this.resolve?.(void 0);
    this.resolve = void 0;
  }
  begin() {
    this.gl.getError();
    this.beginTime = performance.now();
  }
  end() {
    this.gl.getError();
    this.endTime = performance.now();
  }
  poll() {
    this.resolve?.(this.endTime - this.beginTime);
    this.resolve = void 0;
    return true;
  }
};
var GPUTimer = class {
  constructor(gl, ext) {
    this.gl = gl;
    this.ext = ext;
    this.creationTime = performance.now();
    this.query = gl.createQuery();
    this.promise = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  kind = "gpu_time_elapsed";
  promise;
  creationTime;
  query;
  resolve;
  dispose() {
    const { gl, query, resolve } = this;
    gl.deleteQuery(query);
    resolve?.(void 0);
    this.resolve = void 0;
  }
  begin() {
    const { gl, ext, query } = this;
    gl.beginQuery(ext.TIME_ELAPSED_EXT, query);
  }
  end() {
    const { gl, ext } = this;
    gl.endQuery(ext.TIME_ELAPSED_EXT);
  }
  poll() {
    const { gl, ext, query, resolve } = this;
    let disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
    if (!disjoint) {
      const available = gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE);
      if (available) {
        const timeElapsed = gl.getQueryParameter(query, gl.QUERY_RESULT);
        resolve?.(timeElapsed / 1e6);
        this.resolve = void 0;
        return true;
      }
    }
    if (performance.now() > this.creationTime + 1e3) {
      resolve?.(void 0);
      this.resolve = void 0;
      return true;
    }
    return false;
  }
};
var GPUTimerTS = class {
  constructor(gl, ext) {
    this.gl = gl;
    this.ext = ext;
    this.creationTime = performance.now();
    this.startQuery = gl.createQuery();
    this.endQuery = gl.createQuery();
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
    });
  }
  kind = "gpu_timestamp";
  promise;
  creationTime;
  startQuery;
  endQuery;
  resolve;
  dispose() {
    const { gl, startQuery, endQuery, resolve } = this;
    gl.deleteQuery(startQuery);
    gl.deleteQuery(endQuery);
    resolve?.(void 0);
    this.resolve = void 0;
  }
  begin() {
    const { ext, startQuery } = this;
    ext.queryCounterEXT(startQuery, ext.TIMESTAMP_EXT);
  }
  end() {
    const { ext, endQuery } = this;
    ext.queryCounterEXT(endQuery, ext.TIMESTAMP_EXT);
  }
  poll() {
    const { gl, ext, startQuery, endQuery, resolve } = this;
    let disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
    if (!disjoint) {
      const available = gl.getQueryParameter(endQuery, gl.QUERY_RESULT_AVAILABLE);
      if (available) {
        const timeStart = gl.getQueryParameter(startQuery, gl.QUERY_RESULT);
        const timeEnd = gl.getQueryParameter(endQuery, gl.QUERY_RESULT);
        const timeElapsed = timeEnd - timeStart;
        resolve?.(timeElapsed / 1e6);
        this.resolve = void 0;
        return true;
      }
    }
    if (performance.now() > this.creationTime + 1e3) {
      resolve?.(void 0);
      this.resolve = void 0;
      return true;
    }
    return false;
  }
};

// /projects/Novorender/ts/dist/webgl2/transformFeedback.ts
function glTransformFeedback(gl, params) {
  const { kind, transformFeedback, outputBuffers, count, first } = params;
  const mode = gl[kind];
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);
  for (let i = 0; i < outputBuffers.length; i++) {
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, outputBuffers[i]);
  }
  gl.beginTransformFeedback(mode);
  gl.enable(gl.RASTERIZER_DISCARD);
  gl.drawArrays(mode, first ?? 0, count);
  gl.disable(gl.RASTERIZER_DISCARD);
  gl.endTransformFeedback();
  gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
  for (let i = 0; i < outputBuffers.length; i++) {
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, null);
  }
}

// /projects/Novorender/ts/dist/webgl2/uniforms.ts
function glUniformLocations(gl, program, names, prefix) {
  const locations = {};
  for (const name of names) {
    locations[name] = gl.getUniformLocation(program, `${prefix ?? ""}${name}`);
  }
  return locations;
}
function glUBOProxy(values) {
  const offsetsMap = {};
  let offset = 0;
  for (const [key, value] of Object.entries(values)) {
    const { alignment, components, rows } = uniformTypes[value];
    const padding = alignment - 1 - (offset + alignment - 1) % alignment;
    offset += padding;
    const offsets = [];
    for (let row = 0; row < rows; row++) {
      for (let component = 0; component < components; component++) {
        offsets.push(offset++);
      }
      if (rows > 1) {
        offset = offset + 3 & ~3;
      }
    }
    offsetsMap[key] = offsets;
  }
  const byteSize = (offset + 3 & ~3) * 4;
  const buffer = new ArrayBuffer(byteSize);
  const views = {
    i32: new Int32Array(buffer),
    u32: new Uint32Array(buffer),
    f32: new Float32Array(buffer)
  };
  const validators = {
    i32: (value) => {
      if (!Number.isInteger(value)) {
        throw new Error("Uniform value not an integer!");
      }
    },
    u32: (value) => {
      if (value < 0 || !Number.isInteger(value)) {
        throw new Error("Uniform value not an unsigned integer!");
      }
    },
    f32: (value) => {
    }
  };
  const dirtyRange = new DirtyRange(byteSize);
  const proxy2 = {
    buffer,
    dirtyRange,
    values: {}
  };
  for (const [key, value] of Object.entries(values)) {
    const componentType = uniformTypes[value].type;
    const view = views[componentType];
    const validate = validators[componentType];
    const offsets = offsetsMap[key];
    const begin = offsets[0] * 4;
    const end = offsets[offsets.length - 1] * 4 + 4;
    const type = values[key];
    const get = type == "bool" ? () => {
      return view[offsets[0]] != 0;
    } : type == "int" || type == "uint" || type == "float" ? () => {
      return view[offsets[0]];
    } : () => {
      return offsets.map((o) => view[o]);
    };
    const set7 = type == "bool" ? (value2) => {
      view[offsets[0]] = value2 ? -1 : 0;
      dirtyRange.expand(begin, end);
    } : type == "int" || type == "uint" || type == "float" ? (value2) => {
      validate(value2);
      view[offsets[0]] = value2;
      dirtyRange.expand(begin, end);
    } : (values2) => {
      console.assert(values2.length == offsets.length);
      for (let i = 0; i < values2.length; i++) {
        validate(values2[i]);
        view[offsets[i]] = values2[i];
      }
      dirtyRange.expand(begin, end);
    };
    Reflect.defineProperty(proxy2.values, key, {
      configurable: false,
      enumerable: true,
      get,
      set: set7
    });
  }
  return proxy2;
}
var DirtyRange = class {
  constructor(size) {
    this.size = size;
    this.begin = 0;
    this.end = size;
  }
  begin;
  end;
  get isEmpty() {
    return this.begin >= this.end;
  }
  clear() {
    this.begin = this.size;
    this.end = 0;
  }
  reset() {
    this.begin = 0;
    this.end = this.size;
  }
  expand(begin, end) {
    if (this.begin > begin) {
      this.begin = begin;
    }
    if (this.end < end) {
      this.end = end;
    }
  }
};
var uniformTypes = {
  bool: { type: "i32", alignment: 1, components: 1, rows: 1 },
  int: { type: "i32", alignment: 1, components: 1, rows: 1 },
  uint: { type: "u32", alignment: 1, components: 1, rows: 1 },
  float: { type: "f32", alignment: 1, components: 1, rows: 1 },
  ivec2: { type: "i32", alignment: 2, components: 2, rows: 1 },
  uvec2: { type: "u32", alignment: 2, components: 2, rows: 1 },
  vec2: { type: "f32", alignment: 2, components: 2, rows: 1 },
  ivec3: { type: "i32", alignment: 4, components: 3, rows: 1 },
  uvec3: { type: "u32", alignment: 4, components: 3, rows: 1 },
  vec3: { type: "f32", alignment: 4, components: 3, rows: 1 },
  ivec4: { type: "i32", alignment: 4, components: 3, rows: 1 },
  uvec4: { type: "u32", alignment: 4, components: 3, rows: 1 },
  vec4: { type: "f32", alignment: 4, components: 4, rows: 1 },
  mat3: { type: "f32", alignment: 4, components: 3, rows: 3 },
  mat4: { type: "f32", alignment: 4, components: 4, rows: 4 }
};

// /projects/Novorender/ts/dist/webgl2/vao.ts
function glCreateVertexArray(gl, params) {
  const vao = gl.createVertexArray();
  const { MAX_VERTEX_ATTRIBS } = glLimits(gl);
  gl.bindVertexArray(vao);
  const { attributes } = params;
  for (let i = 0; i < MAX_VERTEX_ATTRIBS; i++) {
    const attribParams = attributes[i];
    if (attribParams) {
      const { size, isInteger, defaultComponentType } = shaderTypeInfo[attribParams.kind];
      const componentType = attribParams.componentType ?? defaultComponentType;
      const divisor = attribParams.divisor ?? 0;
      const byteStride = attribParams.byteStride ?? 0;
      const byteOffset = attribParams.byteOffset ?? 0;
      const componentCount = attribParams.componentCount ?? (isMatrix(size) ? size[0] : size);
      const normalized = attribParams.normalized ?? false;
      gl.bindBuffer(gl.ARRAY_BUFFER, attribParams.buffer);
      gl.enableVertexAttribArray(i);
      if (isInteger) {
        gl.vertexAttribIPointer(i, componentCount, gl[componentType], byteStride, byteOffset);
      } else {
        gl.vertexAttribPointer(i, componentCount, gl[componentType], normalized, byteStride, byteOffset);
      }
      gl.vertexAttribDivisor(i, divisor);
    } else {
      gl.disableVertexAttribArray(i);
    }
  }
  ;
  if (params.indices) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, params.indices);
  }
  gl.bindVertexArray(null);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  return vao;
}
function isMatrix(size) {
  return Array.isArray(size);
}
var shaderTypeInfo = {
  "INT": { size: 1, isInteger: true, defaultComponentType: "INT" },
  "INT_VEC2": { size: 2, isInteger: true, defaultComponentType: "INT" },
  "INT_VEC3": { size: 3, isInteger: true, defaultComponentType: "INT" },
  "INT_VEC4": { size: 4, isInteger: true, defaultComponentType: "INT" },
  "UNSIGNED_INT": { size: 1, isInteger: true, defaultComponentType: "UNSIGNED_INT" },
  "UNSIGNED_INT_VEC2": { size: 2, isInteger: true, defaultComponentType: "UNSIGNED_INT" },
  "UNSIGNED_INT_VEC3": { size: 3, isInteger: true, defaultComponentType: "UNSIGNED_INT" },
  "UNSIGNED_INT_VEC4": { size: 4, isInteger: true, defaultComponentType: "UNSIGNED_INT" },
  "FLOAT": { size: 1, isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_VEC2": { size: 2, isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_VEC3": { size: 3, isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_VEC4": { size: 4, isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT2": { size: [2, 2], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT3": { size: [3, 3], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT4": { size: [4, 4], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT2x3": { size: [2, 3], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT2x4": { size: [2, 4], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT3x2": { size: [3, 2], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT3x4": { size: [3, 4], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT4x2": { size: [4, 2], isInteger: false, defaultComponentType: "FLOAT" },
  "FLOAT_MAT4x3": { size: [4, 3], isInteger: false, defaultComponentType: "FLOAT" }
};

// /projects/Novorender/ts/dist/core3d/state/default.ts
function defaultRenderState() {
  const state = {
    output: {
      width: 512,
      height: 256,
      samplesMSAA: 1
    },
    background: {},
    camera: {
      kind: "pinhole",
      position: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      pivot: void 0,
      fov: 45,
      near: 0.1,
      far: 1e4
    },
    quality: {
      detail: 1
    },
    debug: {
      showNodeBounds: false
    },
    grid: {
      enabled: false,
      color1: [0.5, 0.5, 0.5],
      color2: [1, 1, 1],
      origin: [0, 0, 0],
      axisX: [1, 0, 0],
      axisY: [0, 0, 1],
      size1: 1,
      size2: 10,
      distance: 500
    },
    cube: {
      enabled: false,
      position: [0, 0, 0],
      scale: 1
    },
    scene: void 0,
    terrain: {
      elevationGradient: {
        knots: [
          { position: -10, color: [0, 0, 0.5] },
          { position: 0, color: [0.5, 0.5, 1] },
          { position: 0, color: [0, 0.5, 0] },
          { position: 10, color: [0.5, 1, 0.5] }
        ]
      },
      asBackground: false
    },
    dynamic: {
      objects: []
    },
    clipping: {
      enabled: false,
      draw: false,
      mode: 0,
      planes: []
    },
    highlights: {
      defaultAction: void 0,
      groups: []
    },
    outlines: {
      on: false,
      enabled: false,
      color: [10, 10, 10],
      // bright white (overexposed)
      plane: [0, 0, 1, 0]
    },
    tonemapping: {
      exposure: 0,
      mode: 0 /* color */
    },
    points: {
      size: {
        pixel: 1,
        maxPixel: void 0,
        metric: 0,
        toleranceFactor: 0
      },
      deviation: {
        index: 0,
        mixFactor: 0,
        colorGradient: {
          knots: [
            { position: -1, color: [1, 0, 0, 1] },
            { position: -0.5, color: [1, 1, 0, 1] },
            { position: -0.25, color: [0, 1, 0, 1] },
            { position: 0.25, color: [0, 1, 0, 1] },
            { position: 0.5, color: [1, 1, 0, 1] },
            { position: 1, color: [0, 1, 0, 1] }
          ]
        }
      },
      useProjectedPosition: false
    },
    toonOutline: {
      on: false,
      enabled: false,
      color: [0, 0, 0]
    },
    pick: {
      opacityThreshold: 1
    }
  };
  return state;
}

// /projects/Novorender/ts/dist/core3d/state/modify.ts
function modifyRenderState(state, changes) {
  const newState = mergeRecursive(state, changes);
  return newState;
}
function mergeRecursive(original, changes) {
  const clone7 = { ...original };
  for (const key in changes) {
    const originalValue = original ? original[key] : void 0;
    const changedValue = changes[key];
    if (changedValue != void 0 && typeof changedValue == "object" && !Array.isArray(changedValue) && !ArrayBuffer.isView(changedValue) && !(changedValue instanceof Set)) {
      clone7[key] = mergeRecursive(originalValue, changedValue);
    } else {
      clone7[key] = changedValue;
    }
  }
  return clone7;
}

// /projects/Novorender/ts/dist/core3d/state/validate.ts
function validateRenderState(newState, changes) {
  const validate = new ValidationContext();
  if (changes.background) {
    validate.background(newState.background);
  }
  if (changes.camera) {
    validate.camera(newState.camera);
  }
  if (changes.clipping) {
    validate.clipping(newState.clipping);
  }
  if (changes.dynamic) {
    validate.dynamic(newState.dynamic);
  }
  if (changes.grid) {
    validate.grid(newState.grid);
  }
  if (changes.highlights) {
    validate.highlights(newState.highlights);
  }
  if (changes.output) {
    validate.output(newState.output);
  }
  if (changes.pick) {
    validate.pick(newState.pick);
  }
  if (changes.points) {
    validate.points(newState.points);
  }
  if (changes.quality) {
    validate.quality(newState.quality);
  }
  if (changes.scene && newState.scene) {
    validate.scene(newState.scene);
  }
  if (changes.terrain) {
    validate.terrain(newState.terrain);
  }
  if (changes.toonOutline) {
    validate.toonOutline(newState.toonOutline);
  }
  if (changes.tonemapping) {
    validate.tonemapping(newState.tonemapping);
  }
  return validate.errors;
}
var ValidationContext = class {
  errors = [];
  background(state) {
    const { blur, url } = state;
    if (blur != void 0) {
      this.numeric(blur).rangeInclusive(0, 1).report("background.blur");
    }
    if (url != void 0) {
      this.url(url).valid().report("background.url");
    }
  }
  camera(state) {
    const { fov, near, far } = state;
    this.numeric(fov).rangeExclusive(0, 180).report("camera.fov");
    this.numeric(near).positive().report("camera.near");
    this.numeric(far).min(near, "camera.near").report("camera.far");
  }
  clipping(state) {
    const { planes } = state;
    this.numeric(planes.length).max(6).report("clipping.planes.length");
    for (let i = 0; i < planes.length; i++) {
      const plane = planes[i];
      this.plane(plane.normalOffset).valid().hasErrors()?.report(`clipping.planes[${i}].normalOffset`);
    }
  }
  dynamic(state) {
    const { objects } = state;
    for (let i = 0; i < objects.length; i++) {
      const obj = objects[i];
      if (obj.baseObjectId != void 0) {
        this.numeric(obj.baseObjectId).integer().min(4026531840).lessThan(4294967280).hasErrors()?.report(`dynamic.objects[${i}].baseObjectId`);
      }
      const { primitives } = obj.mesh;
      for (let j = 0; j < primitives.length; j++) {
        const primitive = primitives[j];
        const primitivePath = (name) => `dynamic.objects[${i}].mesh.primitives[${j}].${name}`;
        const { material, geometry } = primitive;
        if (material.kind == "ggx") {
          const metallicFactor = material.metallicFactor ?? 1;
          const roughnessFactor = material.roughnessFactor ?? 1;
          this.numeric(metallicFactor).rangeInclusive(0, 1).hasErrors()?.report(primitivePath("material.metallicFactor"));
          this.numeric(roughnessFactor).rangeInclusive(0, 1).hasErrors()?.report(primitivePath("material.roughnessFactor"));
        }
        var indices = typeof geometry.indices == "number" ? geometry.indices : geometry.indices.length;
        let numericValidator = this.numeric(indices).integer().positive();
        switch (geometry.primitiveType) {
          case "LINES": {
            numericValidator = numericValidator.divisibleBy(2);
            break;
          }
          case "LINE_STRIP": {
            numericValidator = numericValidator.min(2);
            break;
          }
          case "TRIANGLES": {
            numericValidator = numericValidator.divisibleBy(3);
            break;
          }
          case "TRIANGLE_STRIP":
          case "TRIANGLE_FAN": {
            numericValidator = numericValidator.min(3);
            break;
          }
        }
        numericValidator.hasErrors()?.report(primitivePath("geometry.indices"));
      }
    }
  }
  highlights(state) {
    const { groups } = state;
    this.numeric(groups.length).max(250).report("groups.length");
  }
  grid(state) {
    const { size1, size2, distance: distance4, axisX, axisY } = state;
    this.numeric(size1).positive().report("grid.size1");
    this.numeric(size2).positive().report("grid.size2");
    this.numeric(distance4).positive().report("grid.distance");
    this.vector3(axisX).normal().report("grid.axisX");
    this.vector3(axisY).normal().report("grid.axisY");
    this.vector3(axisX).perpendicularTo(axisY, "grid.axisY").report("grid.axisX");
  }
  outlines(state) {
    const { plane } = state;
    this.plane(plane).valid().report("outline.plane.normalOffset");
  }
  output(state) {
    const { width, height, samplesMSAA } = state;
    this.numeric(width).integer().positive().report("output.width");
    this.numeric(height).integer().positive().report("output.height");
    this.numeric(samplesMSAA).integer().rangeInclusive(1, 16).report("output.samplesMSAA");
  }
  pick(state) {
    const { opacityThreshold } = state;
    this.numeric(opacityThreshold).rangeInclusive(0, 1).report("pick.opacityThreshold");
  }
  points(state) {
    const { size, deviation } = state;
    if (size.pixel) {
      this.numeric(size.pixel).positive().report("points.size.pixel");
    }
    if (size.maxPixel) {
      this.numeric(size.maxPixel).positive().report("points.size.maxPixel");
    }
    if (size.metric) {
      this.numeric(size.metric).positive().report("points.size.metric");
    }
    this.numeric(deviation.index).rangeInclusive(0, 4).report("points.deviation.index");
    this.numeric(deviation.mixFactor).rangeInclusive(0, 1).report("points.deviation.mixFactor");
    this.gradient(deviation.colorGradient).valid().report("points.deviation.colorGradient");
  }
  quality(state) {
    const { detail } = state;
    this.numeric(detail).positive().report("quality.detail");
  }
  scene(state) {
    const { url } = state;
    if (url != void 0) {
      this.url(url).valid().report("scene.url");
    }
  }
  terrain(state) {
    const { elevationGradient } = state;
    this.gradient(elevationGradient).valid().report("terrain.elevationGradient");
  }
  toonOutline(state) {
  }
  tonemapping(state) {
  }
  numeric(value) {
    return new NumericValidator(this, value);
  }
  vector3(value) {
    return new Vector3Validator(this, value);
  }
  plane(value) {
    return new PlaneValidator(this, value);
  }
  gradient(value) {
    return new GradientValidator(this, value);
  }
  url(value) {
    return new UrlValidator(this, value);
  }
};
var BaseValidator = class {
  constructor(context, value) {
    this.context = context;
    this.value = value;
  }
  errors = [];
  error(message) {
    this.errors.push(message);
  }
  hasErrors() {
    return this.errors.length > 0 ? this : void 0;
  }
  report(path) {
    if (this.errors.length) {
      const message = `${path}=${this.formatValue()}: ${this.errors.join(" ")}`;
      this.context.errors.push(new Error(message));
    }
  }
  formatValue() {
    return this.value.toString();
  }
};
var NumericValidator = class extends BaseValidator {
  integer() {
    if (!Number.isInteger(this.value)) {
      this.error(`must be an integer!`);
    }
    return this;
  }
  positive() {
    if (this.value <= 0) {
      this.error(`must be larger than zero!`);
    }
    return this;
  }
  min(min4, minText) {
    if (this.value < min4) {
      this.error(`must be greater or equal to ${minText ?? min4}!`);
    }
    return this;
  }
  max(max4, maxText) {
    if (this.value > max4) {
      this.error(`must be less or equal to ${maxText ?? max4}!`);
    }
    return this;
  }
  greaterThan(ref, refText) {
    if (this.value <= ref) {
      this.error(`must be greater than ${refText ?? ref}!`);
    }
    return this;
  }
  lessThan(ref, refText) {
    if (this.value >= ref) {
      this.error(`must be less than ${refText ?? ref}!`);
    }
    return this;
  }
  rangeInclusive(min4 = 0, max4 = 1) {
    this.min(min4);
    this.max(max4);
    return this;
  }
  rangeExclusive(min4 = 0, max4 = 1) {
    this.greaterThan(min4);
    this.lessThan(max4);
    return this;
  }
  divisibleBy(divisor) {
    if (!Number.isInteger(this.value / divisor)) {
      this.error(`is not divisible by ${divisor}!`);
    }
    return this;
  }
};
var Vector3Validator = class extends BaseValidator {
  normal(epsilon = 1e-6) {
    const len5 = vec3_exports.length(this.value);
    if (len5 < 1 - epsilon || len5 > 1 + epsilon) {
      this.error(`must be normal, i.e. length = 1!`);
    }
    return this;
  }
  perpendicularTo(vec, vecText, epsilon = 1e-6) {
    const dp = vec3_exports.dot(this.value, vec);
    if (dp < -epsilon || dp > 1 + epsilon) {
      this.error(`must be perpendicular to ${vecText ?? vec.toString()}`);
    }
    return this;
  }
  nonZero() {
    if (vec3_exports.dot(this.value, this.value) == 0) {
      this.error(`must be non-zero!`);
    }
    return this;
  }
};
var PlaneValidator = class extends BaseValidator {
  valid(epsilon = 1e-6) {
    const [x, y, z] = this.value;
    const len5 = Math.sqrt(x * x + y * y + z * z);
    if (len5 < 1 - epsilon || len5 > 1 + epsilon) {
      this.error(`plane must have a valid normal, i.e. [xyz].length = 1!`);
    }
    return this;
  }
};
var GradientValidator = class extends BaseValidator {
  valid() {
    const { knots } = this.value;
    if (knots.length > 0) {
      var prevPos = knots[0].position;
      for (let i = 1; i < knots.length; i++) {
        const nextPos = knots[i].position;
        if (nextPos < prevPos) {
          this.error("must have knot positions in ascending order!");
        }
        prevPos = nextPos;
      }
    } else {
      this.error("must have more than zero knots!");
    }
    return this;
  }
};
var UrlValidator = class extends BaseValidator {
  valid() {
    try {
      new URL(this.value);
    } catch {
      this.error("is not a valid absolute url!");
    }
    return this;
  }
};

// /projects/Novorender/ts/dist/core3d/state/index.ts
var CoordSpace = /* @__PURE__ */ ((CoordSpace2) => {
  CoordSpace2[CoordSpace2["World"] = 0] = "World";
  CoordSpace2[CoordSpace2["View"] = 1] = "View";
  CoordSpace2[CoordSpace2["Clip"] = 2] = "Clip";
  return CoordSpace2;
})(CoordSpace || {});
var CubeId = 4294967288;
var ClippingMode = /* @__PURE__ */ ((ClippingMode2) => {
  ClippingMode2[ClippingMode2["intersection"] = 0] = "intersection";
  ClippingMode2[ClippingMode2["union"] = 1] = "union";
  return ClippingMode2;
})(ClippingMode || {});
var ClippingId = /* @__PURE__ */ ((ClippingId2) => {
  ClippingId2[ClippingId2["plane0"] = 4294967280] = "plane0";
  ClippingId2[ClippingId2["plane1"] = 4294967281] = "plane1";
  ClippingId2[ClippingId2["plane2"] = 4294967282] = "plane2";
  ClippingId2[ClippingId2["plane3"] = 4294967283] = "plane3";
  ClippingId2[ClippingId2["plane4"] = 4294967284] = "plane4";
  ClippingId2[ClippingId2["plane5"] = 4294967285] = "plane5";
  ClippingId2[ClippingId2["plane6"] = 4294967286] = "plane6";
  return ClippingId2;
})(ClippingId || {});
var TonemappingMode = /* @__PURE__ */ ((TonemappingMode2) => {
  TonemappingMode2[TonemappingMode2["color"] = 0] = "color";
  TonemappingMode2[TonemappingMode2["normal"] = 1] = "normal";
  TonemappingMode2[TonemappingMode2["depth"] = 2] = "depth";
  TonemappingMode2[TonemappingMode2["objectId"] = 3] = "objectId";
  TonemappingMode2[TonemappingMode2["deviation"] = 4] = "deviation";
  TonemappingMode2[TonemappingMode2["zbuffer"] = 5] = "zbuffer";
  return TonemappingMode2;
})(TonemappingMode || {});

// /projects/Novorender/ts/dist/core3d/matrices.ts
function index(from, to) {
  return from * 3 + to;
}
function matricesFromRenderState(state) {
  const { camera, output } = state;
  const { width, height } = output;
  const aspectRatio = width / height;
  const fovY = camera.fov * Math.PI / 180;
  const viewWorld = mat4_exports.fromRotationTranslation(mat4_exports.create(), camera.rotation, camera.position);
  const viewClip = mat4_exports.create();
  if (camera.kind == "orthographic") {
    const aspect = output.width / output.height;
    const halfHeight = camera.fov / 2;
    const halfWidth = halfHeight * aspect;
    mat4_exports.ortho(viewClip, -halfWidth, halfWidth, -halfHeight, halfHeight, camera.near, camera.far);
  } else {
    mat4_exports.perspective(viewClip, fovY, aspectRatio, camera.near, camera.far);
  }
  return new MatricesImpl(viewWorld, viewClip);
}
var MatricesImpl = class {
  _mtx4 = new Array(4 * 4);
  _mtx3 = new Array(4 * 4);
  constructor(viewWorld, viewClip) {
    this._mtx4[index(1 /* View */, 0 /* World */)] = viewWorld;
    this._mtx4[index(1 /* View */, 2 /* Clip */)] = viewClip;
    const worldView = this._mtx4[index(0 /* World */, 1 /* View */)] = mat4_exports.create();
    const clipView = this._mtx4[index(2 /* Clip */, 1 /* View */)] = mat4_exports.create();
    mat4_exports.invert(worldView, viewWorld);
    mat4_exports.invert(clipView, viewClip);
  }
  getMatrix(from, to) {
    console.assert(from != to);
    const idx = index(from, to);
    let m = this._mtx4[idx];
    if (!m) {
      this._mtx4[idx] = m = mat4_exports.create();
      if (to > from) {
        mat4_exports.multiply(m, this.getMatrix(to - 1, to), this.getMatrix(from, to - 1));
      } else {
        mat4_exports.multiply(m, this.getMatrix(from - 1, to), this.getMatrix(from, from - 1));
      }
    }
    return m;
  }
  getMatrixNormal(from, to) {
    console.assert(from != to);
    const idx = index(from, to);
    let m = this._mtx3[idx];
    if (!m) {
      this._mtx3[idx] = m = mat3_exports.create();
      mat3_exports.normalFromMat4(m, this.getMatrix(from, to));
    }
    return m;
  }
};

// /projects/Novorender/ts/dist/core3d/viewFrustum.ts
function createViewFrustum(state, matrices) {
  const { camera, output } = state;
  const { width, height } = output;
  const aspect = width / height;
  const halfHeight = camera.fov / 2;
  const halfWidth = halfHeight * aspect;
  const left = vec4_exports.create();
  const right = vec4_exports.create();
  const top = vec4_exports.create();
  const bottom = vec4_exports.create();
  const near = vec4_exports.create();
  const far = vec4_exports.create();
  const image = vec4_exports.create();
  vec4_exports.set(near, 0, 0, 1, -camera.near);
  vec4_exports.set(far, 0, 0, -1, camera.far);
  vec4_exports.set(image, 0, 0, -1, 0);
  if (camera.kind == "orthographic") {
    vec4_exports.set(left, -1, 0, 0, halfWidth);
    vec4_exports.set(right, 1, 0, 0, halfWidth);
    vec4_exports.set(top, 0, 1, 0, halfHeight);
    vec4_exports.set(bottom, 0, -1, 0, halfHeight);
  } else {
    const halfAngleY = common_exports.toRadian(camera.fov / 2);
    const halfAngleX = Math.atan(Math.tan(halfAngleY) * aspect);
    vec4_exports.set(left, -Math.cos(halfAngleX), 0, Math.sin(halfAngleX), 0);
    vec4_exports.set(right, Math.cos(halfAngleX), 0, Math.sin(halfAngleX), 0);
    vec4_exports.set(top, 0, Math.cos(halfAngleY), Math.sin(halfAngleY), 0);
    vec4_exports.set(bottom, 0, -Math.cos(halfAngleY), Math.sin(halfAngleY), 0);
  }
  const normal = vec3_exports.create();
  const position = vec3_exports.create();
  const matrix = matrices.getMatrix(1 /* View */, 0 /* World */);
  const matrixNormal = matrices.getMatrixNormal(1 /* View */, 0 /* World */);
  mat4_exports.getTranslation(position, matrix);
  const planes = [left, right, top, bottom, near, far, image];
  for (const plane of planes) {
    const [x, y, z, offset] = plane;
    vec3_exports.set(normal, x, y, z);
    vec3_exports.transformMat3(normal, normal, matrixNormal);
    const distance4 = offset + vec3_exports.dot(position, normal);
    vec4_exports.set(plane, normal[0], normal[1], normal[2], -distance4);
  }
  return { left, right, top, bottom, near, far, image, planes: [left, right, top, bottom, near, far] };
}

// /projects/Novorender/ts/dist/core3d/buffers.ts
var RenderBuffers = class {
  /** @internal */
  constructor(gl, width, height, samples, resourceBin) {
    this.gl = gl;
    this.width = width;
    this.height = height;
    this.samples = samples;
    this.resourceBin = resourceBin;
    const textures = this.textures = {
      // color: resourceBin.createTexture({ kind: "TEXTURE_2D", width, height, internalFormat: "RGBA16F", type: "HALF_FLOAT", image: null }),
      color: resourceBin.createTexture({ kind: "TEXTURE_2D", width, height, internalFormat: "R11F_G11F_B10F", type: "HALF_FLOAT", image: null }),
      pick: resourceBin.createTexture({ kind: "TEXTURE_2D", width, height, internalFormat: "RGBA32UI", type: "UNSIGNED_INT", image: null }),
      // TODO: Pack linearDepth into this buffer instead.
      depth: resourceBin.createTexture({ kind: "TEXTURE_2D", width, height, internalFormat: "DEPTH_COMPONENT32F", type: "FLOAT", image: null })
    };
    const renderBuffers = this.renderBuffers = {
      colorMSAA: samples > 1 ? resourceBin.createRenderBuffer({ internalFormat: "R11F_G11F_B10F", width, height, samples }) : null,
      depthMSAA: samples > 1 ? resourceBin.createRenderBuffer({ internalFormat: "DEPTH_COMPONENT32F", width, height, samples }) : null
    };
    this.frameBuffers = {
      color: resourceBin.createFrameBuffer({
        color: [
          { kind: "FRAMEBUFFER", texture: textures.color },
          null
          // Even without MSAA, we can't render pick buffer in the same pass as color buffer. This both due to transparency dithering and pick.opacityThreshold. We cannot selectively exclude one output channel only in frag shader.
        ],
        depth: { kind: "DRAW_FRAMEBUFFER", texture: textures.depth }
      }),
      colorMSAA: samples > 1 ? resourceBin.createFrameBuffer({
        color: [
          { kind: "DRAW_FRAMEBUFFER", renderBuffer: renderBuffers.colorMSAA }
        ],
        depth: { kind: "DRAW_FRAMEBUFFER", renderBuffer: renderBuffers.depthMSAA }
      }) : null,
      pick: resourceBin.createFrameBuffer({
        color: [
          null,
          { kind: "DRAW_FRAMEBUFFER", texture: textures.pick }
        ],
        depth: { kind: "DRAW_FRAMEBUFFER", texture: textures.depth }
      })
    };
    this.readBuffers = {
      pick: resourceBin.createBuffer({ kind: "PIXEL_PACK_BUFFER", byteSize: width * height * 16, usage: "STREAM_READ" })
    };
    this.typedArrays = {
      pick: new Uint32Array(width * height * 4)
    };
  }
  /** Flag to indicate the CPU/read buffers needs to be updated. */
  readBuffersNeedUpdate = true;
  /** Texture resources. */
  textures;
  /** Renderbuffer resources. */
  renderBuffers;
  /** Frame buffer resources. */
  frameBuffers;
  /** CPU/JS copy of pick buffers. */
  readBuffers;
  typedArrays;
  pickFence;
  /** @internal */
  resolveMSAA() {
    const { gl, frameBuffers, width, height } = this;
    const { colorMSAA, color } = frameBuffers;
    if (colorMSAA) {
      glBlit(gl, { source: colorMSAA, destination: color, color: true, srcX1: width, srcY1: height, dstX1: width, dstY1: height });
      glInvalidateFrameBuffer(gl, { kind: "FRAMEBUFFER", frameBuffer: colorMSAA, color: [true], depth: true });
    }
  }
  /** @internal */
  invalidate(frameBuffer, buffers) {
    const { gl, frameBuffers } = this;
    var color = (buffers & 1 /* color */) != 0;
    var pick = (buffers & 2 /* pick */) != 0;
    var depth = (buffers & 4 /* depth */) != 0;
    glInvalidateFrameBuffer(gl, { kind: "DRAW_FRAMEBUFFER", frameBuffer: frameBuffers[frameBuffer], color: [color, pick], depth });
  }
  // copy framebuffer into read buffers
  read() {
    const { gl, width, height, frameBuffers, readBuffers } = this;
    glReadPixels(gl, {
      width,
      height,
      frameBuffer: frameBuffers.pick,
      buffers: [
        { attachment: "COLOR_ATTACHMENT1", buffer: readBuffers.pick, format: "RGBA_INTEGER", type: "UNSIGNED_INT" }
      ]
    });
  }
  /** @internal */
  async pickBuffers() {
    if (this.readBuffersNeedUpdate && !this.pickFence) {
      const { gl } = this;
      this.read();
      this.readBuffersNeedUpdate = false;
      const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
      this.pickFence = { sync, promises: [] };
    }
    if (this.pickFence) {
      const { promises } = this.pickFence;
      let promiseCallbacks;
      const timeout = setTimeout(() => {
        for (let i = 0; i < promises.length; ++i) {
          if (promiseCallbacks == promises[i]) {
            promises.splice(i, 1);
            promiseCallbacks.resolve();
          }
        }
      }, 100);
      const promise = new Promise((resolve, reject) => {
        promiseCallbacks = {
          resolve: () => {
            clearTimeout(timeout);
            resolve();
          },
          reject
        };
        promises.push(promiseCallbacks);
      });
      await promise;
      return this.typedArrays;
    } else {
      return Promise.resolve(this.typedArrays);
    }
  }
  /** @internal */
  dispose() {
    this.deletePickFence();
    this.resourceBin.dispose();
  }
  /** @internal */
  pollPickFence() {
    const { gl, pickFence, readBuffers, typedArrays } = this;
    if (pickFence) {
      const { sync, promises } = pickFence;
      const status = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
      if (status == gl.WAIT_FAILED) {
        for (const promise of promises) {
          promise.reject("Pick failed!");
        }
        this.deletePickFence();
      } else if (status != gl.TIMEOUT_EXPIRED) {
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, readBuffers.pick);
        gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, typedArrays.pick);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
        for (const promise of promises) {
          promise.resolve();
        }
        this.deletePickFence();
      }
    }
  }
  /** @internal */
  deletePickFence() {
    this.gl.deleteSync(this.pickFence?.sync ?? null);
    this.pickFence = void 0;
  }
};

// /projects/Novorender/ts/dist/core3d/resource.ts
var ResourceBin = class {
  /** @internal */
  constructor(gl, name, collection) {
    this.gl = gl;
    this.name = name;
    this.collection = collection;
    this.collection.add(this);
  }
  resourceMap = /* @__PURE__ */ new Map();
  get resourceInfo() {
    const { resourceMap } = this;
    function* iterate() {
      for (const infos of resourceMap.values()) {
        for (const info of infos) {
          yield { ...info };
        }
      }
    }
    return iterate();
  }
  get size() {
    return this.resourceMap.size;
  }
  createBuffer(params) {
    return this.add(glCreateBuffer(this.gl, params), { kind: "Buffer", target: params.kind, byteSize: bufferBytes(params) });
  }
  createFrameBuffer(params) {
    return this.add(glCreateFrameBuffer(this.gl, params), { kind: "Framebuffer" });
  }
  createProgram(params) {
    return this.add(glCreateProgram(this.gl, params), { kind: "Program" });
  }
  createProgramAsync(params) {
    const ret = glCreateProgramAsync(this.gl, params);
    this.add(ret.program, { kind: "Program" });
    return ret;
  }
  createRenderBuffer(params) {
    return this.add(glCreateRenderbuffer(this.gl, params), { kind: "Renderbuffer", byteSize: renderBufferBytes(this.gl, params) });
  }
  createSampler(params) {
    return this.add(glCreateSampler(this.gl, params), { kind: "Sampler" });
  }
  createTexture(params) {
    return this.add(glCreateTexture(this.gl, params), { kind: "Texture", target: params.kind, byteSize: textureBytes(params) });
  }
  createTransformFeedback() {
    return this.add(this.gl.createTransformFeedback(), { kind: "TransformFeedback" });
  }
  createVertexArray(params) {
    return this.add(glCreateVertexArray(this.gl, params), { kind: "VertexArray" });
  }
  add(resource, info) {
    console.assert(resource.constructor.name.startsWith("WebGL"));
    if (!this.resourceMap.has(resource)) {
      this.resourceMap.set(resource, [info]);
    } else {
      throw new Error("Resource added more than once!");
    }
    return resource;
  }
  // delete resources that are already kept alive/referenced by other resources,
  // e.g. a buffer referenced by a vertex array object or a texture referenced by a framebuffer.
  // this will remove them from the list of attached resources but retain info for resource tracking purposes
  subordinate(owner, ...resources) {
    const deletedInfos = [];
    console.assert(resources.length > 0);
    this.del(resources, deletedInfos);
    const ownerInfos = this.resourceMap.get(owner);
    if (ownerInfos) {
      ownerInfos.push(...deletedInfos);
    }
  }
  delete(...resources) {
    this.del(resources);
  }
  del(resources, deleteInfos) {
    const { gl, resourceMap } = this;
    for (const resource of resources) {
      if (!resource)
        continue;
      const infos = this.resourceMap.get(resource);
      if (infos && infos.length > 0) {
        for (const info of infos) {
          deleteInfos?.push(info);
        }
        const [primary] = infos;
        gl[`delete${primary.kind}`](resource);
        resourceMap.delete(resource);
      } else {
        throw new Error("Resource could not be found!");
      }
    }
  }
  deleteAll() {
    this.delete(...this.resourceMap.keys());
    this.resourceMap.clear();
  }
  dispose() {
    if (this.gl) {
      this.deleteAll();
      this.collection.delete(this);
    }
  }
};
function bufferBytes(params) {
  return "byteSize" in params ? params.byteSize : params.srcData.byteLength;
}
function renderBufferBytes(gl, params) {
  const { width, height, internalFormat } = params;
  const samples = params.samples == "max" ? glLimits(gl).MAX_SAMPLES : params.samples ?? 1;
  const bytesPerPixel = Math.ceil(internalFormatTexelBytes[internalFormat]);
  return width * height * bytesPerPixel * samples;
}
function textureBytes(params) {
  const width = params.width ?? params.image.width;
  const height = params.height ?? params.image.height;
  const depth = "depth" in params ? params.depth : 1;
  const faces = params.kind == "TEXTURE_CUBE_MAP" ? 6 : 1;
  const topLeveltexels = width * height * depth * faces;
  let totalTexels = 0;
  let levels = 1;
  if ("mipMaps" in params) {
    const { mipMaps } = params;
    const isNumber = typeof mipMaps == "number";
    levels = isNumber ? mipMaps : mipMaps.length;
  }
  if ("generateMipMaps" in params && params.generateMipMaps && isPowerOf22(width) && isPowerOf22(height)) {
    levels = Math.min(Math.log2(width), Math.log2(height));
  }
  for (let level = 0; level < levels; level++) {
    totalTexels += topLeveltexels >> level;
  }
  const bytesPerTexel = Math.ceil(internalFormatTexelBytes[params.internalFormat]);
  return Math.ceil(totalTexels * bytesPerTexel);
}
function isPowerOf22(value) {
  return (value & value - 1) == 0;
}
var internalFormatTexelBytes = {
  "RGB": 3,
  "RGBA": 4,
  "LUMINANCE_ALPHA": 2,
  "LUMINANCE": 1,
  "ALPHA": 1,
  "STENCIL_INDEX8": 1,
  "R8": 1,
  "R8_SNORM": 1,
  "RG8": 2,
  "RG8_SNORM": 2,
  "RGB8": 3,
  "RGB8_SNORM": 3,
  "RGB565": 2,
  "RGBA4": 2,
  "RGB5_A1": 2,
  "RGBA8": 4,
  "RGBA8_SNORM": 4,
  "RGB10_A2": 4,
  "RGB10_A2UI": 4,
  "SRGB8": 3,
  "SRGB8_ALPHA8": 4,
  "R16F": 2,
  "RG16F": 4,
  "RGB16F": 6,
  "RGBA16F": 8,
  "R32F": 4,
  "RG32F": 8,
  "RGB32F": 16,
  "RGBA32F": 32,
  "R11F_G11F_B10F": 4,
  "RGB9_E5": 4,
  "R8I": 1,
  "R8UI": 1,
  "R16I": 2,
  "R16UI": 2,
  "R32I": 4,
  "R32UI": 4,
  "RG8I": 2,
  "RG8UI": 2,
  "RG16I": 4,
  "RG16UI": 4,
  "RG32I": 8,
  "RG32UI": 8,
  "RGB8I": 3,
  "RGB8UI": 4,
  "RGB16I": 6,
  "RGB16UI": 6,
  "RGB32I": 12,
  "RGB32UI": 12,
  "RGBA8I": 4,
  "RGBA8UI": 4,
  "RGBA16I": 8,
  "RGBA16UI": 8,
  "RGBA32I": 16,
  "RGBA32UI": 16,
  "DEPTH_COMPONENT16": 2,
  "DEPTH_COMPONENT24": 3,
  "DEPTH_COMPONENT32F": 4,
  "DEPTH24_STENCIL8": 4,
  "DEPTH32F_STENCIL8": 5,
  // WEBGL_compressed_texture_s3tc
  "COMPRESSED_RGB_S3TC_DXT1_EXT": 0.5,
  "COMPRESSED_RGBA_S3TC_DXT1_EXT": 0.5,
  "COMPRESSED_RGBA_S3TC_DXT3_EXT": 1,
  "COMPRESSED_RGBA_S3TC_DXT5_EXT": 1,
  // WEBGL_compressed_texture_s3tc_srgb
  "COMPRESSED_SRGB_S3TC_DXT1_EXT": 0.5,
  "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT": 0.5,
  "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT": 1,
  "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT": 1,
  // WEBGL_compressed_texture_etc
  "COMPRESSED_R11_EAC": 0.5,
  "COMPRESSED_SIGNED_R11_EAC": 0.5,
  "COMPRESSED_RG11_EAC": 1,
  "COMPRESSED_SIGNED_RG11_EAC": 1,
  "COMPRESSED_RGB8_ETC2": 0.5,
  "COMPRESSED_RGBA8_ETC2_EAC": 1,
  "COMPRESSED_SRGB8_ETC2": 0.5,
  "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC": 1,
  "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2": 0.5,
  "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2": 0.5,
  // WEBGL_compressed_texture_pvrtc
  "COMPRESSED_RGB_PVRTC_4BPPV1_IMG": 0.5,
  "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG": 0.5,
  "COMPRESSED_RGB_PVRTC_2BPPV1_IMG": 0.25,
  "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG": 0.25,
  // WEBGL_compressed_texture_etc1    
  "COMPRESSED_RGB_ETC1_WEBGL": 0.5,
  // WEBGL_compressed_texture_astc    
  "COMPRESSED_RGBA_ASTC_4x4_KHR": 16 / (4 * 4),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR": 16 / (4 * 4),
  "COMPRESSED_RGBA_ASTC_5x4_KHR": 16 / (5 * 4),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR": 16 / (5 * 4),
  "COMPRESSED_RGBA_ASTC_5x5_KHR": 16 / (5 * 5),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR": 16 / (5 * 5),
  "COMPRESSED_RGBA_ASTC_6x5_KHR": 16 / (6 * 5),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR": 16 / (6 * 5),
  "COMPRESSED_RGBA_ASTC_6x6_KHR": 16 / (6 * 6),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR": 16 / (6 * 6),
  "COMPRESSED_RGBA_ASTC_8x5_KHR": 16 / (8 * 5),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR": 16 / (8 * 5),
  "COMPRESSED_RGBA_ASTC_8x6_KHR": 16 / (8 * 6),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR": 16 / (8 * 6),
  "COMPRESSED_RGBA_ASTC_8x8_KHR": 16 / (8 * 8),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR": 16 / (8 * 8),
  "COMPRESSED_RGBA_ASTC_10x5_KHR": 16 / (10 * 5),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR": 16 / (10 * 5),
  "COMPRESSED_RGBA_ASTC_10x6_KHR": 16 / (10 * 6),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR": 16 / (10 * 6),
  "COMPRESSED_RGBA_ASTC_10x10_KHR": 16 / (10 * 10),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR": 16 / (10 * 10),
  "COMPRESSED_RGBA_ASTC_12x10_KHR": 16 / (12 * 10),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR": 16 / (12 * 10),
  "COMPRESSED_RGBA_ASTC_12x12_KHR": 16 / (12 * 12),
  "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR": 16 / (12 * 12),
  // EXT_texture_compression_bptc    
  "COMPRESSED_RGBA_BPTC_UNORM_EXT": 1,
  "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT": 1,
  "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT": 1,
  "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT": 1,
  // EXT_texture_compression_rgtc    
  "COMPRESSED_RED_RGTC1_EXT": 0.5,
  "COMPRESSED_SIGNED_RED_RGTC1_EXT": 0.5,
  "COMPRESSED_RED_GREEN_RGTC2_EXT": 1,
  "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT": 1
};

// /projects/Novorender/ts/dist/core3d/util.ts
function decodeBase64(base64, type = Uint8Array) {
  if (base64) {
    var binaryString = atob(base64);
    var len5 = binaryString.length;
    const bytes = new type(len5);
    for (let i = 0; i < len5; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }
}
function orthoNormalBasisMatrixFromPlane(plane) {
  const [nx, ny, nz, offs] = plane;
  const axisZ = vec3_exports.fromValues(nx, ny, nz);
  const minI = Math.abs(nx) < Math.abs(ny) && Math.abs(nx) < Math.abs(nz) ? 0 : Math.abs(ny) < Math.abs(nz) ? 1 : 2;
  const axisY = vec3_exports.fromValues(0, 0, 0);
  axisY[minI] = 1;
  const axisX = vec3_exports.cross(vec3_exports.create(), axisY, axisZ);
  vec3_exports.cross(axisX, axisY, axisZ);
  vec3_exports.normalize(axisX, axisX);
  vec3_exports.cross(axisY, axisZ, axisX);
  vec3_exports.normalize(axisY, axisY);
  const [bx, by, bz] = axisX;
  const [tx, ty, tz] = axisY;
  return mat4_exports.fromValues(
    bx,
    by,
    bz,
    0,
    tx,
    ty,
    tz,
    0,
    nx,
    ny,
    nz,
    0,
    nx * -offs,
    ny * -offs,
    nz * -offs,
    1
  );
}

// /projects/Novorender/ts/dist/core3d/ktx.ts
var identifier = new Uint8Array([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]);
var HEADER_LEN = 12 + 13 * 4;
var textureDataType = {
  [5121 /* UNSIGNED_BYTE */]: "UNSIGNED_BYTE",
  [33635 /* UNSIGNED_SHORT_5_6_5 */]: "UNSIGNED_SHORT_5_6_5",
  [32819 /* UNSIGNED_SHORT_4_4_4_4 */]: "UNSIGNED_SHORT_4_4_4_4",
  [32820 /* UNSIGNED_SHORT_5_5_5_1 */]: "UNSIGNED_SHORT_5_5_5_1",
  [5131 /* HALF_FLOAT */]: "HALF_FLOAT",
  // [GL.HALF_FLOAT_OES]: "HALF_FLOAT_OES",
  [5126 /* FLOAT */]: "FLOAT",
  [5123 /* UNSIGNED_SHORT */]: "UNSIGNED_SHORT",
  [5125 /* UNSIGNED_INT */]: "UNSIGNED_INT",
  [34042 /* UNSIGNED_INT_24_8 */]: "UNSIGNED_INT_24_8",
  [5120 /* BYTE */]: "BYTE",
  [5122 /* SHORT */]: "SHORT",
  [5124 /* INT */]: "INT",
  // [GL.FLOAT_32_UNSIGNED_INT_24_8_REV]: "FLOAT_32_UNSIGNED_INT_24_8_REV",
  [35902 /* UNSIGNED_INT_5_9_9_9_REV */]: "UNSIGNED_INT_5_9_9_9_REV",
  [33640 /* UNSIGNED_INT_2_10_10_10_REV */]: "UNSIGNED_INT_2_10_10_10_REV",
  [35899 /* UNSIGNED_INT_10F_11F_11F_REV */]: "UNSIGNED_INT_10F_11F_11F_REV"
};
var textureFormatBase = {
  [6407 /* RGB */]: "RGB",
  [6408 /* RGBA */]: "RGBA",
  [6406 /* ALPHA */]: "ALPHA",
  [6409 /* LUMINANCE */]: "LUMINANCE",
  [6410 /* LUMINANCE_ALPHA */]: "LUMINANCE_ALPHA",
  [6402 /* DEPTH_COMPONENT */]: "DEPTH_COMPONENT",
  [34041 /* DEPTH_STENCIL */]: "DEPTH_STENCIL",
  [35904 /* SRGB_EXT */]: "SRGB_EXT",
  [35906 /* SRGB_ALPHA_EXT */]: "SRGB_ALPHA_EXT",
  [6403 /* RED */]: "RED",
  [33319 /* RG */]: "RG",
  [36244 /* RED_INTEGER */]: "RED_INTEGER",
  [33320 /* RG_INTEGER */]: "RG_INTEGER",
  [36248 /* RGB_INTEGER */]: "RGB_INTEGER",
  [36249 /* RGBA_INTEGER */]: "RGBA_INTEGER"
};
var textureFormatUncompressed = {
  [33321 /* R8 */]: "R8",
  [36756 /* R8_SNORM */]: "R8_SNORM",
  [33323 /* RG8 */]: "RG8",
  [36757 /* RG8_SNORM */]: "RG8_SNORM",
  [32849 /* RGB8 */]: "RGB8",
  [36758 /* RGB8_SNORM */]: "RGB8_SNORM",
  [36194 /* RGB565 */]: "RGB565",
  [32854 /* RGBA4 */]: "RGBA4",
  [32855 /* RGB5_A1 */]: "RGB5_A1",
  [32856 /* RGBA8 */]: "RGBA8",
  [36759 /* RGBA8_SNORM */]: "RGBA8_SNORM",
  [32857 /* RGB10_A2 */]: "RGB10_A2",
  [36975 /* RGB10_A2UI */]: "RGB10_A2UI",
  [35905 /* SRGB8 */]: "SRGB8",
  [35907 /* SRGB8_ALPHA8 */]: "SRGB8_ALPHA8",
  [33325 /* R16F */]: "R16F",
  [33327 /* RG16F */]: "RG16F",
  [34843 /* RGB16F */]: "RGB16F",
  [34842 /* RGBA16F */]: "RGBA16F",
  [33326 /* R32F */]: "R32F",
  [33328 /* RG32F */]: "RG32F",
  [34837 /* RGB32F */]: "RGB32F",
  [34836 /* RGBA32F */]: "RGBA32F",
  [35898 /* R11F_G11F_B10F */]: "R11F_G11F_B10F",
  [35901 /* RGB9_E5 */]: "RGB9_E5",
  [33329 /* R8I */]: "R8I",
  [33330 /* R8UI */]: "R8UI",
  [33331 /* R16I */]: "R16I",
  [33332 /* R16UI */]: "R16UI",
  [33333 /* R32I */]: "R32I",
  [33334 /* R32UI */]: "R32UI",
  [33335 /* RG8I */]: "RG8I",
  [33336 /* RG8UI */]: "RG8UI",
  [33337 /* RG16I */]: "RG16I",
  [33338 /* RG16UI */]: "RG16UI",
  [33339 /* RG32I */]: "RG32I",
  [33340 /* RG32UI */]: "RG32UI",
  [36239 /* RGB8I */]: "RGB8I",
  [36221 /* RGB8UI */]: "RGB8UI",
  [36233 /* RGB16I */]: "RGB16I",
  [36215 /* RGB16UI */]: "RGB16UI",
  [36227 /* RGB32I */]: "RGB32I",
  [36209 /* RGB32UI */]: "RGB32UI",
  [36238 /* RGBA8I */]: "RGBA8I",
  [36220 /* RGBA8UI */]: "RGBA8UI",
  [36232 /* RGBA16I */]: "RGBA16I",
  [36214 /* RGBA16UI */]: "RGBA16UI",
  [36226 /* RGBA32I */]: "RGBA32I",
  [36208 /* RGBA32UI */]: "RGBA32UI"
  // [GL.SRGB8_ALPHA8_EXT]: "SRGB8_ALPHA8_EXT",
};
var textureFormatCompressed = {
  [33776 /* COMPRESSED_RGB_S3TC_DXT1_EXT */]: "COMPRESSED_RGB_S3TC_DXT1_EXT",
  [33777 /* COMPRESSED_RGBA_S3TC_DXT1_EXT */]: "COMPRESSED_RGBA_S3TC_DXT1_EXT",
  [33778 /* COMPRESSED_RGBA_S3TC_DXT3_EXT */]: "COMPRESSED_RGBA_S3TC_DXT3_EXT",
  [33779 /* COMPRESSED_RGBA_S3TC_DXT5_EXT */]: "COMPRESSED_RGBA_S3TC_DXT5_EXT",
  [37488 /* COMPRESSED_R11_EAC */]: "COMPRESSED_R11_EAC",
  [37489 /* COMPRESSED_SIGNED_R11_EAC */]: "COMPRESSED_SIGNED_R11_EAC",
  [37490 /* COMPRESSED_RG11_EAC */]: "COMPRESSED_RG11_EAC",
  [37491 /* COMPRESSED_SIGNED_RG11_EAC */]: "COMPRESSED_SIGNED_RG11_EAC",
  [37492 /* COMPRESSED_RGB8_ETC2 */]: "COMPRESSED_RGB8_ETC2",
  [37493 /* COMPRESSED_RGBA8_ETC2_EAC */]: "COMPRESSED_RGBA8_ETC2_EAC",
  [37494 /* COMPRESSED_SRGB8_ETC2 */]: "COMPRESSED_SRGB8_ETC2",
  [37495 /* COMPRESSED_SRGB8_ALPHA8_ETC2_EAC */]: "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
  [37496 /* COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
  [37497 /* COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 */]: "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
  [35840 /* COMPRESSED_RGB_PVRTC_4BPPV1_IMG */]: "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
  [35842 /* COMPRESSED_RGBA_PVRTC_4BPPV1_IMG */]: "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
  [35841 /* COMPRESSED_RGB_PVRTC_2BPPV1_IMG */]: "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
  [35843 /* COMPRESSED_RGBA_PVRTC_2BPPV1_IMG */]: "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
  [36196 /* COMPRESSED_RGB_ETC1_WEBGL */]: "COMPRESSED_RGB_ETC1_WEBGL"
  // [GL.COMPRESSED_RGB_ATC_WEBGL]: "COMPRESSED_RGB_ATC_WEBGL",
  // [GL.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL]: "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
  // [GL.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL]: "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
};
var textureFormatInternal = {
  ...textureFormatUncompressed,
  ...textureFormatCompressed
  // [GL.DEPTH_COMPONENT16]: "DEPTH_COMPONENT16",
  // [GL.DEPTH_COMPONENT24]: "DEPTH_COMPONENT24",
  // [GL.DEPTH_COMPONENT32F]: "DEPTH_COMPONENT32F",
  // [GL.DEPTH32F_STENCIL8]: "DEPTH32F_STENCIL8",
};
function parseHeader(ktx) {
  const idDataView = new DataView(ktx.buffer, ktx.byteOffset, 12);
  for (let i = 0; i < identifier.length; i++) {
    if (idDataView.getUint8(i) != identifier[i]) {
      throw new Error("texture missing KTX identifier");
    }
  }
  const dataSize = Uint32Array.BYTES_PER_ELEMENT;
  const headerDataView = new DataView(ktx.buffer, 12 + ktx.byteOffset, 13 * dataSize);
  const endianness = headerDataView.getUint32(0, true);
  const littleEndian = endianness === 67305985;
  return {
    glType: headerDataView.getUint32(1 * dataSize, littleEndian),
    // must be 0 for compressed textures
    glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
    // must be 1 for compressed textures
    glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
    // must be 0 for compressed textures
    glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
    // the value of arg passed to gl.texImage2D() or gl.compressedTexImage2D(,,x,,,,)
    glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
    // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
    pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
    // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
    pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
    // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
    pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
    // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
    numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
    // used for texture arrays
    numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
    // used for cubemap textures, should either be 1 or 6
    numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
    // number of levels; disregard possibility of 0 for compressed textures
    bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
    // the amount of space after the header for meta-data
    littleEndian
  };
}
function* getImages(header, ktx, littleEndian) {
  const mips = Math.max(1, header.numberOfMipmapLevels);
  const elements = Math.max(1, header.numberOfArrayElements);
  const faces = header.numberOfFaces;
  const depth = Math.max(1, header.pixelDepth);
  let dataOffset = HEADER_LEN + header.bytesOfKeyValueData;
  const imageSizeDenom = faces == 6 && header.numberOfArrayElements == 0 ? 1 : elements * faces * depth;
  const dataView = new DataView(ktx.buffer, ktx.byteOffset);
  for (let mip = 0; mip < mips; mip++) {
    const width = header.pixelWidth >> mip;
    const height = header.pixelHeight >> mip;
    const imageSize = dataView.getInt32(dataOffset, littleEndian);
    dataOffset += 4;
    const imageStride = imageSize / imageSizeDenom;
    console.assert(imageStride % 4 == 0);
    for (let element = 0; element < elements; element++) {
      for (let face = 0; face < faces; face++) {
        for (let z_slice = 0; z_slice < depth; z_slice++) {
          const begin = dataOffset;
          dataOffset += imageStride;
          const end = dataOffset;
          const image = { mip, element, face, width, height, blobRange: [begin, end], buffer: ktx.subarray(begin, end) };
          yield image;
        }
      }
    }
  }
  console.assert(dataOffset == ktx.byteLength);
}
function parseKTX(ktx) {
  const header = parseHeader(ktx);
  const { littleEndian } = header;
  const baseFormat = textureFormatBase[header.glBaseInternalFormat];
  const isArray = header.numberOfArrayElements > 0;
  const isCube = header.numberOfFaces == 6;
  const is3D = header.pixelDepth > 0;
  const hasMips = header.numberOfMipmapLevels > 1;
  const numMips = Math.max(1, header.numberOfMipmapLevels);
  const internalFormat = textureFormatInternal[header.glInternalFormat];
  const kind = isArray ? "TEXTURE_ARRAY" : isCube ? "TEXTURE_CUBE_MAP" : is3D ? "TEXTURE_3D" : "TEXTURE_2D";
  const type = header.glType ? textureDataType[header.glType] : void 0;
  const dim = { width: header.pixelWidth, height: header.pixelHeight, ...is3D ? { depth: header.pixelDepth } : void 0 };
  let mips = void 0;
  if (isCube) {
    const images = new Array(numMips).fill(null).map((_) => []);
    for (const image of getImages(header, ktx, littleEndian)) {
      images[image.mip][image.face] = image.buffer;
    }
    mips = images;
  } else {
    mips = new Array(numMips);
    for (const image of getImages(header, ktx, littleEndian)) {
      mips[image.mip] = image.buffer;
    }
  }
  const imageData = hasMips ? { mipMaps: mips } : { image: mips[0] };
  return {
    kind,
    internalFormat,
    type,
    ...dim,
    ...imageData
  };
}

// /projects/Novorender/ts/dist/core3d/modules/background/index.ts
var BackgroundModule = class {
  kind = "background";
  abortController;
  url;
  textureParams;
  // undefined means no change in textures
  uniforms = {
    envBlurNormalized: "float",
    mipCount: "int"
  };
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    return new BackgroundModuleContext(context, this, uniforms, resources);
  }
  createUniforms() {
    return glUBOProxy(this.uniforms);
  }
  async createResources(context, uniformsProxy) {
    const { vertexShader, fragmentShader } = context.imports.shaders.background.render;
    const bin = context.resourceBin("Background");
    const uniforms = bin.createBuffer({ kind: "UNIFORM_BUFFER", byteSize: uniformsProxy.buffer.byteLength });
    const uniformBufferBlocks = ["Camera", "Background"];
    const textureUniforms = ["textures.skybox", "textures.ibl.specular"];
    const program = await context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks, textureUniforms });
    return { bin, uniforms, program };
  }
  async downloadTextures(baseUrl) {
    if (this.abortController) {
      this.abortController.abort();
    }
    const abortController = this.abortController = new AbortController();
    const { signal } = abortController;
    try {
      const promises = [
        download3(new URL("radiance.ktx", baseUrl)),
        download3(new URL("irradiance.ktx", baseUrl)),
        download3(new URL("background.ktx", baseUrl))
      ];
      const [specular, diffuse, skybox] = await Promise.all(promises);
      this.textureParams = { diffuse, specular, skybox };
    } finally {
      this.abortController = void 0;
    }
    async function download3(url) {
      const response = await fetch(url, { mode: "cors", signal });
      if (response.ok) {
        var ktxData = await response.arrayBuffer();
        var params = parseKTX(new Uint8Array(ktxData));
        return params;
      } else {
        throw new Error(`HTTP Error:${response.status} ${response.status}`);
      }
    }
  }
};
var BackgroundModuleContext = class {
  constructor(context, module, uniforms, resources) {
    this.context = context;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
    this.skybox = resources.bin.createTexture(context.defaultIBLTextureParams);
  }
  skybox;
  update(state) {
    const { context, resources, module, uniforms, skybox } = this;
    const { bin } = resources;
    const { background } = state;
    if (context.hasStateChanged({ background })) {
      uniforms.values.envBlurNormalized = background.blur ?? 0;
      context.updateUniformBuffer(resources.uniforms, this.uniforms);
      const { url } = state.background;
      if (url) {
        if (url != module.url) {
          module.downloadTextures(new URL(url)).then(() => {
            context.changed = true;
          });
        }
      } else {
        context.updateIBLTextures(null);
        bin.delete(skybox);
        this.skybox = bin.createTexture(context.defaultIBLTextureParams);
      }
      module.url = url;
    }
    if (module.textureParams) {
      context.updateIBLTextures(module.textureParams);
      bin.delete(skybox);
      this.skybox = bin.createTexture(module.textureParams.skybox);
      uniforms.values.mipCount = context.iblTextures.numMipMaps;
      context.updateUniformBuffer(resources.uniforms, this.uniforms);
      module.textureParams = void 0;
    }
  }
  render(state) {
    const { context, resources, skybox } = this;
    const { program, uniforms } = resources;
    const { gl, cameraUniforms, samplerSingle, samplerMip } = context;
    const clearColor = state.background.color ?? [0.33, 0.33, 0.33, 1];
    if ((!state.background.color || state.background.url) && state.camera.kind != "orthographic") {
      const { specular } = context.iblTextures;
      glState(gl, {
        program,
        uniformBuffers: [cameraUniforms, uniforms],
        textures: [
          { kind: "TEXTURE_CUBE_MAP", texture: skybox, sampler: samplerSingle },
          { kind: "TEXTURE_CUBE_MAP", texture: specular, sampler: samplerMip }
        ],
        depth: {
          test: false,
          writeMask: false
        }
      });
      const stats = glDraw(gl, { kind: "arrays", mode: "TRIANGLE_STRIP", count: 4 });
      context.addRenderStatistics(stats);
    } else {
      glClear(gl, { kind: "COLOR", drawBuffer: 0, color: clearColor });
    }
  }
  contextLost() {
    const { module } = this;
    module.url = void 0;
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
  }
};

// /projects/Novorender/ts/dist/core3d/modules/grid/index.ts
var GridModule = class {
  kind = "grid";
  uniforms = {
    origin: "vec3",
    axisX: "vec3",
    axisY: "vec3",
    size1: "float",
    size2: "float",
    color1: "vec3",
    color2: "vec3",
    distance: "float"
  };
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    return new GridModuleContext(context, this, uniforms, resources);
  }
  createUniforms() {
    return glUBOProxy(this.uniforms);
  }
  async createResources(context, uniformsProxy) {
    const { vertexShader, fragmentShader } = context.imports.shaders.grid.render;
    const bin = context.resourceBin("Grid");
    const uniforms = bin.createBuffer({ kind: "UNIFORM_BUFFER", srcData: uniformsProxy.buffer });
    const program = await context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks: ["Camera", "Grid"] });
    return { bin, uniforms, program };
  }
};
var GridModuleContext = class {
  constructor(context, module, uniforms, resources) {
    this.context = context;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
  }
  update(state) {
    const { context, resources } = this;
    const { uniforms } = resources;
    const { grid, localSpaceTranslation } = state;
    if (context.hasStateChanged({ grid, localSpaceTranslation })) {
      const { values } = this.uniforms;
      const { axisX, axisY, origin } = grid;
      const worldLocalMatrix = mat4_exports.fromTranslation(mat4_exports.create(), vec3_exports.negate(vec3_exports.create(), localSpaceTranslation));
      values.origin = vec3_exports.transformMat4(vec3_exports.create(), origin, worldLocalMatrix);
      values.axisX = axisX;
      values.axisY = axisY;
      values.color1 = grid.color1;
      values.color2 = grid.color2;
      values.size1 = grid.size1;
      values.size2 = grid.size2;
      values.distance = grid.distance;
      context.updateUniformBuffer(uniforms, this.uniforms);
    }
  }
  render(state) {
    const { context, resources } = this;
    const { program, uniforms } = resources;
    const { gl, cameraUniforms } = context;
    if (state.grid.enabled) {
      glState(gl, {
        program,
        uniformBuffers: [cameraUniforms, uniforms],
        depth: {
          test: true,
          writeMask: false
        },
        sample: {
          alphaToCoverage: false
        },
        blend: {
          enable: true,
          srcRGB: "SRC_ALPHA",
          dstRGB: "ONE_MINUS_SRC_ALPHA",
          srcAlpha: "ZERO",
          dstAlpha: "ONE"
        }
      });
      const stats = glDraw(gl, { kind: "arrays", mode: "TRIANGLE_STRIP", count: 4 });
      context.addRenderStatistics(stats);
    }
  }
  contextLost() {
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
  }
};

// /projects/Novorender/ts/dist/core3d/offline.ts
var offlineDirs = /* @__PURE__ */ new Map();
var rootPromise = navigator.storage.getDirectory();
async function getDirHandle(dirname) {
  try {
    const root = await rootPromise;
    return await root.getDirectoryHandle(dirname);
  } catch {
  }
}
async function requestOfflineFile(pathname) {
  const m = /\/([\da-f]{32})(?=\/).*\/(.+)$/.exec(pathname);
  if (m && m.length == 3) {
    const [_, dirname, filename] = m;
    let dirHandleRef = await offlineDirs.get(dirname);
    if (dirHandleRef !== null) {
      let dirHandle = dirHandleRef?.deref();
      if (!dirHandle) {
        dirHandle = await getDirHandle(dirname);
        if (dirHandle) {
          dirHandleRef = new WeakRef(dirHandle);
          offlineDirs.set(dirname, dirHandleRef);
        } else {
          offlineDirs.set(dirname, null);
        }
      }
      if (dirHandle) {
        try {
          const fileHandle = await dirHandle.getFileHandle(filename);
          const file = await fileHandle.getFile();
          return new Response(file, { status: 200, headers: { "Content-Type": "application/octet-stream" } });
        } catch {
        }
      }
    }
  }
}

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/download.ts
var AbortableDownload = class {
  constructor(download3) {
    this.download = download3;
  }
  result = Promise.resolve(void 0);
  aborted = false;
  start() {
    this.result = this.download();
  }
  abort() {
    this.aborted = true;
  }
};
var Downloader = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
  }
  activeDownloads = 0;
  completeResolve;
  async complete() {
    if (this.activeDownloads > 0) {
      const completePromise = new Promise((resolve, reject) => {
        this.completeResolve = resolve;
      });
      await completePromise;
      this.completeResolve = void 0;
    }
  }
  async request(filename) {
    const url = new URL(filename, this.baseUrl);
    if (!url.search)
      url.search = this.baseUrl?.search ?? "";
    const response = await requestOfflineFile(url.pathname) ?? await fetch(url, { mode: "cors" });
    if (!response.ok) {
      throw new Error(`HTTP Error: ${response.status}: ${response.statusText} (${url})`);
    }
    return response;
  }
  downloadArrayBufferAbortable(filename, buffer) {
    const self2 = this;
    const download3 = new AbortableDownload(buffer != void 0 ? downloadAsyncSize : downloadAsync);
    download3.start();
    return download3;
    async function downloadAsyncSize() {
      try {
        self2.activeDownloads++;
        const response = await self2.request(filename);
        if (!response.ok)
          throw new Error(`HTTP error: ${response.status} ${response.statusText}!`);
        const reader = response.body.getReader();
        const content = new Uint8Array(buffer);
        let offset = 0;
        while (!download3.aborted) {
          const { done, value } = await reader.read();
          if (done)
            break;
          content.set(value, offset);
          offset += value.length;
        }
        if (!download3.aborted) {
          console.assert(offset == content.length);
          return content.buffer;
        } else {
          reader.cancel();
        }
      } finally {
        self2.activeDownloads--;
        if (self2.activeDownloads == 0 && self2.completeResolve) {
          self2.completeResolve();
        }
      }
    }
    async function downloadAsync() {
      try {
        self2.activeDownloads++;
        const response = await self2.request(filename);
        if (!response.ok)
          throw new Error(`HTTP error: ${response.status} ${response.statusText}!`);
        const reader = response.body.getReader();
        const chunks = [];
        let size = 0;
        while (!download3.aborted) {
          const { done, value } = await reader.read();
          if (done)
            break;
          chunks.push(value);
          size += value.length;
        }
        if (!download3.aborted) {
          const content = new Uint8Array(size);
          let offset = 0;
          for (const chunk of chunks) {
            content.set(chunk, offset);
            offset += chunk.length;
          }
          return content.buffer;
        } else {
          reader.cancel();
        }
      } finally {
        self2.activeDownloads--;
        if (self2.activeDownloads == 0 && self2.completeResolve) {
          self2.completeResolve();
        }
      }
    }
  }
};

// /projects/Novorender/ts/dist/core3d/modules/octree/mutex.ts
var Mutex = class {
  _view;
  constructor(buffer) {
    this._view = new Int32Array(buffer, 0, 1);
  }
  // will loop until lock is available, so be careful using this in main thread
  lockSpin() {
    const { _view } = this;
    for (; ; ) {
      if (Atomics.compareExchange(_view, 0, 0 /* unlocked */, 1 /* locked */) == 0 /* unlocked */) {
        return;
      }
    }
  }
  // blocking call, use in workers only!
  lockSync() {
    console.assert(self.Worker != void 0);
    const { _view } = this;
    for (; ; ) {
      if (Atomics.compareExchange(_view, 0, 0 /* unlocked */, 1 /* locked */) == 0 /* unlocked */) {
        return;
      }
      Atomics.wait(_view, 0, 1 /* locked */);
    }
  }
  // safe to use from main thread
  async lockAsync() {
    const { _view } = this;
    for (; ; ) {
      if (Atomics.compareExchange(_view, 0, 0 /* unlocked */, 1 /* locked */) == 0 /* unlocked */) {
        return;
      }
      const { async, value } = Atomics.waitAsync(_view, 0, 1 /* locked */);
      if (async) {
        await value;
      }
    }
  }
  unlock() {
    const { _view } = this;
    if (Atomics.compareExchange(_view, 0, 1 /* locked */, 0 /* unlocked */) != 1 /* locked */) {
      throw new Error("Mutex is in inconsistent state: unlock on unlocked Mutex.");
    }
    Atomics.notify(_view, 0);
  }
};

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/util.ts
var Float16Array = Uint16Array;
var BufferReader = class {
  constructor(buffer) {
    this.buffer = buffer;
    this._u8 = new Uint8Array(buffer, 0, Math.floor(buffer.byteLength / Uint8Array.BYTES_PER_ELEMENT));
    this._u16 = new Uint16Array(buffer, 0, Math.floor(buffer.byteLength / Uint16Array.BYTES_PER_ELEMENT));
    this._u32 = new Uint32Array(buffer, 0, Math.floor(buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT));
    this._i8 = new Int8Array(buffer, 0, Math.floor(buffer.byteLength / Int8Array.BYTES_PER_ELEMENT));
    this._i16 = new Int16Array(buffer, 0, Math.floor(buffer.byteLength / Int16Array.BYTES_PER_ELEMENT));
    this._i32 = new Int32Array(buffer, 0, Math.floor(buffer.byteLength / Int32Array.BYTES_PER_ELEMENT));
    this._f16 = new Uint16Array(buffer, 0, Math.floor(buffer.byteLength / Uint16Array.BYTES_PER_ELEMENT));
    this._f32 = new Float32Array(buffer, 0, Math.floor(buffer.byteLength / Float32Array.BYTES_PER_ELEMENT));
    this._f64 = new Float64Array(buffer, 0, Math.floor(buffer.byteLength / Float64Array.BYTES_PER_ELEMENT));
  }
  pos = 0;
  _u8;
  _u16;
  _u32;
  _i8;
  _i16;
  _i32;
  _f16;
  _f32;
  _f64;
  read(ar, size) {
    if (size == 0)
      return ar.subarray(0, 0);
    const align = ar.BYTES_PER_ELEMENT;
    var padding = align - 1 - (this.pos + align - 1) % align;
    console.assert(padding >= 0 && padding < align);
    const begin = (this.pos + padding) / align;
    const end = begin + size;
    this.pos = end * ar.BYTES_PER_ELEMENT;
    return ar.subarray(begin, end);
  }
  get eof() {
    return this.pos == this.buffer.byteLength;
  }
  u8(size) {
    return this.read(this._u8, size);
  }
  u16(size) {
    return this.read(this._u16, size);
  }
  u32(size) {
    return this.read(this._u32, size);
  }
  i8(size) {
    return this.read(this._i8, size);
  }
  i16(size) {
    return this.read(this._i16, size);
  }
  i32(size) {
    return this.read(this._i32, size);
  }
  f16(size) {
    return this.read(this._f16, size);
  }
  f32(size) {
    return this.read(this._f32, size);
  }
  f64(size) {
    return this.read(this._f64, size);
  }
};

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/2_1.ts
var __exports = {};
__export(__exports, {
  MaterialType: () => MaterialType,
  OptionalVertexAttribute: () => OptionalVertexAttribute,
  PrimitiveType: () => PrimitiveType,
  TextureSemantic: () => TextureSemantic,
  readSchema: () => readSchema,
  version: () => version
});
var version = "2.1";
var PrimitiveType = /* @__PURE__ */ ((PrimitiveType3) => {
  PrimitiveType3[PrimitiveType3["points"] = 0] = "points";
  PrimitiveType3[PrimitiveType3["lines"] = 1] = "lines";
  PrimitiveType3[PrimitiveType3["line_loops"] = 2] = "line_loops";
  PrimitiveType3[PrimitiveType3["line_strip"] = 3] = "line_strip";
  PrimitiveType3[PrimitiveType3["triangles"] = 4] = "triangles";
  PrimitiveType3[PrimitiveType3["triangle_strip"] = 5] = "triangle_strip";
  PrimitiveType3[PrimitiveType3["triangle_fan"] = 6] = "triangle_fan";
  return PrimitiveType3;
})(PrimitiveType || {});
var OptionalVertexAttribute = /* @__PURE__ */ ((OptionalVertexAttribute3) => {
  OptionalVertexAttribute3[OptionalVertexAttribute3["normal"] = 1] = "normal";
  OptionalVertexAttribute3[OptionalVertexAttribute3["color"] = 2] = "color";
  OptionalVertexAttribute3[OptionalVertexAttribute3["texCoord"] = 4] = "texCoord";
  OptionalVertexAttribute3[OptionalVertexAttribute3["projectedPos"] = 8] = "projectedPos";
  return OptionalVertexAttribute3;
})(OptionalVertexAttribute || {});
var MaterialType = /* @__PURE__ */ ((MaterialType4) => {
  MaterialType4[MaterialType4["opaque"] = 0] = "opaque";
  MaterialType4[MaterialType4["opaqueDoubleSided"] = 1] = "opaqueDoubleSided";
  MaterialType4[MaterialType4["transparent"] = 2] = "transparent";
  MaterialType4[MaterialType4["elevation"] = 3] = "elevation";
  return MaterialType4;
})(MaterialType || {});
var TextureSemantic = /* @__PURE__ */ ((TextureSemantic3) => {
  TextureSemantic3[TextureSemantic3["baseColor"] = 0] = "baseColor";
  return TextureSemantic3;
})(TextureSemantic || {});
function readSchema(r) {
  const sizes = r.u32(10);
  const flags = r.u8(10);
  const schema = {
    version: "2.1",
    childInfo: {
      length: sizes[0],
      hash: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) },
      childIndex: r.u8(sizes[0]),
      childMask: r.u32(sizes[0]),
      tolerance: r.i8(sizes[0]),
      totalByteSize: r.u32(sizes[0]),
      offset: {
        length: sizes[0],
        x: r.f64(sizes[0]),
        y: r.f64(sizes[0]),
        z: r.f64(sizes[0])
      },
      scale: r.f32(sizes[0]),
      bounds: {
        length: sizes[0],
        box: {
          length: sizes[0],
          min: {
            length: sizes[0],
            x: r.f32(sizes[0]),
            y: r.f32(sizes[0]),
            z: r.f32(sizes[0])
          },
          max: {
            length: sizes[0],
            x: r.f32(sizes[0]),
            y: r.f32(sizes[0]),
            z: r.f32(sizes[0])
          }
        },
        sphere: {
          length: sizes[0],
          origo: {
            length: sizes[0],
            x: r.f32(sizes[0]),
            y: r.f32(sizes[0]),
            z: r.f32(sizes[0])
          },
          radius: r.f32(sizes[0])
        }
      },
      subMeshes: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) },
      descendantObjectIds: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) }
    },
    hashBytes: r.u8(sizes[1]),
    descendantObjectIds: r.u32(sizes[2]),
    subMeshProjection: {
      length: sizes[3],
      objectId: r.u32(sizes[3]),
      primitiveType: r.u8(sizes[3]),
      attributes: r.u8(sizes[3]),
      numDeviations: r.u8(sizes[3]),
      numIndices: r.u32(sizes[3]),
      numVertices: r.u32(sizes[3]),
      numTextureBytes: r.u32(sizes[3])
    },
    subMesh: {
      length: sizes[4],
      childIndex: r.u8(sizes[4]),
      objectId: r.u32(sizes[4]),
      materialIndex: r.u8(sizes[4]),
      primitiveType: r.u8(sizes[4]),
      materialType: r.u8(sizes[4]),
      attributes: r.u8(sizes[4]),
      numDeviations: r.u8(sizes[4]),
      vertices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) },
      primitiveVertexIndices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) },
      edgeVertexIndices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) },
      cornerVertexIndices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) },
      textures: { start: r.u8(sizes[4]), count: r.u8(sizes[4]) }
    },
    textureInfo: {
      length: sizes[5],
      semantic: r.u8(sizes[5]),
      transform: {
        length: sizes[5],
        e00: r.f32(sizes[5]),
        e01: r.f32(sizes[5]),
        e02: r.f32(sizes[5]),
        e10: r.f32(sizes[5]),
        e11: r.f32(sizes[5]),
        e12: r.f32(sizes[5]),
        e20: r.f32(sizes[5]),
        e21: r.f32(sizes[5]),
        e22: r.f32(sizes[5])
      },
      pixelRange: { start: r.u32(sizes[5]), count: r.u32(sizes[5]) }
    },
    vertex: {
      length: sizes[6],
      position: {
        length: sizes[6],
        x: r.i16(sizes[6]),
        y: r.i16(sizes[6]),
        z: r.i16(sizes[6])
      },
      normal: !flags[0] ? void 0 : {
        length: sizes[6],
        x: r.i8(sizes[6]),
        y: r.i8(sizes[6]),
        z: r.i8(sizes[6])
      },
      color: !flags[1] ? void 0 : {
        length: sizes[6],
        red: r.u8(sizes[6]),
        green: r.u8(sizes[6]),
        blue: r.u8(sizes[6]),
        alpha: r.u8(sizes[6])
      },
      texCoord: !flags[2] ? void 0 : {
        length: sizes[6],
        x: r.f16(sizes[6]),
        y: r.f16(sizes[6])
      },
      projectedPos: !flags[3] ? void 0 : {
        length: sizes[6],
        x: r.i16(sizes[6]),
        y: r.i16(sizes[6]),
        z: r.i16(sizes[6])
      },
      deviations: {
        length: sizes[6],
        a: !flags[4] ? void 0 : r.f16(sizes[6]),
        b: !flags[5] ? void 0 : r.f16(sizes[6]),
        c: !flags[6] ? void 0 : r.f16(sizes[6]),
        d: !flags[7] ? void 0 : r.f16(sizes[6])
      }
    },
    triangle: {
      length: sizes[7],
      topologyFlags: !flags[8] ? void 0 : r.u8(sizes[7])
    },
    vertexIndex: !flags[9] ? void 0 : r.u16(sizes[8]),
    texturePixels: r.u8(sizes[9])
  };
  console.assert(r.eof);
  return schema;
}

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/2_0.ts
var version2 = "2.0";
function readSchema2(r) {
  const sizes = r.u32(9);
  const flags = r.u8(10);
  const schema = {
    version: "2.0",
    childInfo: {
      length: sizes[0],
      hash: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) },
      childIndex: r.u8(sizes[0]),
      childMask: r.u32(sizes[0]),
      tolerance: r.i8(sizes[0]),
      totalByteSize: r.u32(sizes[0]),
      offset: {
        length: sizes[0],
        x: r.f64(sizes[0]),
        y: r.f64(sizes[0]),
        z: r.f64(sizes[0])
      },
      scale: r.f32(sizes[0]),
      bounds: {
        length: sizes[0],
        box: {
          length: sizes[0],
          min: {
            length: sizes[0],
            x: r.f32(sizes[0]),
            y: r.f32(sizes[0]),
            z: r.f32(sizes[0])
          },
          max: {
            length: sizes[0],
            x: r.f32(sizes[0]),
            y: r.f32(sizes[0]),
            z: r.f32(sizes[0])
          }
        },
        sphere: {
          length: sizes[0],
          origo: {
            length: sizes[0],
            x: r.f32(sizes[0]),
            y: r.f32(sizes[0]),
            z: r.f32(sizes[0])
          },
          radius: r.f32(sizes[0])
        }
      },
      subMeshes: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) }
    },
    hashBytes: r.u8(sizes[1]),
    subMeshProjection: {
      length: sizes[2],
      objectId: r.u32(sizes[2]),
      primitiveType: r.u8(sizes[2]),
      attributes: r.u8(sizes[2]),
      numDeviations: r.u8(sizes[2]),
      numIndices: r.u32(sizes[2]),
      numVertices: r.u32(sizes[2]),
      numTextureBytes: r.u32(sizes[2])
    },
    subMesh: {
      length: sizes[3],
      childIndex: r.u8(sizes[3]),
      objectId: r.u32(sizes[3]),
      materialIndex: r.u8(sizes[3]),
      primitiveType: r.u8(sizes[3]),
      materialType: r.u8(sizes[3]),
      attributes: r.u8(sizes[3]),
      numDeviations: r.u8(sizes[3]),
      vertices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) },
      primitiveVertexIndices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) },
      edgeVertexIndices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) },
      cornerVertexIndices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) },
      textures: { start: r.u8(sizes[3]), count: r.u8(sizes[3]) }
    },
    textureInfo: {
      length: sizes[4],
      semantic: r.u8(sizes[4]),
      transform: {
        length: sizes[4],
        e00: r.f32(sizes[4]),
        e01: r.f32(sizes[4]),
        e02: r.f32(sizes[4]),
        e10: r.f32(sizes[4]),
        e11: r.f32(sizes[4]),
        e12: r.f32(sizes[4]),
        e20: r.f32(sizes[4]),
        e21: r.f32(sizes[4]),
        e22: r.f32(sizes[4])
      },
      pixelRange: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) }
    },
    vertex: {
      length: sizes[5],
      position: {
        length: sizes[5],
        x: r.i16(sizes[5]),
        y: r.i16(sizes[5]),
        z: r.i16(sizes[5])
      },
      normal: !flags[0] ? void 0 : {
        length: sizes[5],
        x: r.i8(sizes[5]),
        y: r.i8(sizes[5]),
        z: r.i8(sizes[5])
      },
      color: !flags[1] ? void 0 : {
        length: sizes[5],
        red: r.u8(sizes[5]),
        green: r.u8(sizes[5]),
        blue: r.u8(sizes[5]),
        alpha: r.u8(sizes[5])
      },
      texCoord: !flags[2] ? void 0 : {
        length: sizes[5],
        x: r.f16(sizes[5]),
        y: r.f16(sizes[5])
      },
      projectedPos: !flags[3] ? void 0 : {
        length: sizes[5],
        x: r.i16(sizes[5]),
        y: r.i16(sizes[5]),
        z: r.i16(sizes[5])
      },
      deviations: {
        length: sizes[5],
        a: !flags[4] ? void 0 : r.f16(sizes[5]),
        b: !flags[5] ? void 0 : r.f16(sizes[5]),
        c: !flags[6] ? void 0 : r.f16(sizes[5]),
        d: !flags[7] ? void 0 : r.f16(sizes[5])
      }
    },
    triangle: {
      length: sizes[6],
      topologyFlags: !flags[8] ? void 0 : r.u8(sizes[6])
    },
    vertexIndex: !flags[9] ? void 0 : r.u16(sizes[7]),
    texturePixels: r.u8(sizes[8])
  };
  console.assert(r.eof);
  return schema;
}

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/parser.ts
var { MaterialType: MaterialType2, OptionalVertexAttribute: OptionalVertexAttribute2, PrimitiveType: PrimitiveType2, TextureSemantic: TextureSemantic2 } = __exports;
function isCurrentSchema(schema) {
  return schema.version == version;
}
function isSupportedVersion(version3) {
  return version3 == version || version3 == version2;
}
var primitiveTypeStrings = ["POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN"];
function getVec3(v, i) {
  return vec3_exports.fromValues(v.x[i], v.y[i], v.z[i]);
}
function getRange(v, i) {
  const begin = v.start[i];
  const end = begin + v.count[i];
  return [begin, end];
}
function computePrimitiveCount(primitiveType, numIndices) {
  switch (primitiveType) {
    case PrimitiveType2.points:
      return numIndices;
    case PrimitiveType2.lines:
      return numIndices / 2;
    case PrimitiveType2.line_loops:
      return numIndices;
    case PrimitiveType2.line_strip:
      return numIndices - 1;
    case PrimitiveType2.triangles:
      return numIndices / 3;
    case PrimitiveType2.triangle_strip:
      return numIndices - 2;
    case PrimitiveType2.triangle_fan:
      return numIndices - 2;
    default:
      console.warn(`Unknown primitive type: ${primitiveType}!`);
  }
}
function getVertexAttribs(deviations) {
  return {
    position: { type: Uint16Array, components: ["x", "y", "z"] },
    normal: { type: Int8Array, components: ["x", "y", "z"] },
    texCoord: { type: Float16Array, components: ["x", "y"] },
    color: { type: Uint8Array, components: ["red", "green", "blue", "alpha"] },
    projectedPos: { type: Uint16Array, components: ["x", "y", "z"] },
    deviations: { type: Float16Array, components: ["a", "b", "c", "d"].slice(0, deviations) },
    materialIndex: { type: Uint8Array },
    objectId: { type: Uint32Array }
  };
}
function computeVertexOffsets(attribs, deviations = 0) {
  let offset = 0;
  let offsets = {};
  function alignOffset(alignment) {
    const padding = alignment - 1 - (offset + alignment - 1) % alignment;
    offset += padding;
  }
  let maxAlign = 1;
  const vertexAttribs = getVertexAttribs(deviations);
  for (const attrib of attribs) {
    const { type, components } = vertexAttribs[attrib];
    const count = components?.length ?? 1;
    maxAlign = Math.max(maxAlign, type.BYTES_PER_ELEMENT);
    alignOffset(type.BYTES_PER_ELEMENT);
    offsets[attrib] = offset;
    offset += type.BYTES_PER_ELEMENT * count;
  }
  alignOffset(maxAlign);
  offsets.stride = offset;
  return offsets;
}
function getVertexAttribNames(optionalAttributes, deviations, hasMaterials, hasObjectIds) {
  const attribNames = ["position"];
  if (optionalAttributes & OptionalVertexAttribute2.normal)
    attribNames.push("normal");
  if (optionalAttributes & OptionalVertexAttribute2.texCoord)
    attribNames.push("texCoord");
  if (optionalAttributes & OptionalVertexAttribute2.color)
    attribNames.push("color");
  if (optionalAttributes & OptionalVertexAttribute2.projectedPos)
    attribNames.push("projectedPos");
  if (deviations > 0)
    attribNames.push("deviations");
  if (hasMaterials) {
    attribNames.push("materialIndex");
  }
  if (hasObjectIds) {
    attribNames.push("objectId");
  }
  return attribNames;
}
function aggregateSubMeshProjections(subMeshProjection, range, separatePositionBuffer, predicate) {
  let primitives = 0;
  let totalTextureBytes = 0;
  let totalNumIndices = 0;
  let totalNumVertices = 0;
  let totalNumVertexBytes = 0;
  const [begin, end] = range;
  for (let i = begin; i < end; i++) {
    const objectId = subMeshProjection.objectId[i];
    if (predicate?.(objectId) ?? true) {
      const indices = subMeshProjection.numIndices[i];
      const vertices = subMeshProjection.numVertices[i];
      const textureBytes2 = subMeshProjection.numTextureBytes[i];
      const attributes = subMeshProjection.attributes[i];
      const deviations = subMeshProjection.numDeviations[i];
      const primitiveType = subMeshProjection.primitiveType[i];
      const hasMaterials = textureBytes2 == 0;
      const hasObjectIds = true;
      const [pos, ...rest] = getVertexAttribNames(attributes, deviations, hasMaterials, hasObjectIds);
      const numBytesPerVertex = separatePositionBuffer ? computeVertexOffsets([pos]).stride + computeVertexOffsets(rest, deviations).stride : computeVertexOffsets([pos, ...rest], deviations).stride;
      primitives += computePrimitiveCount(primitiveType, indices ? indices : vertices) ?? 0;
      totalNumIndices += indices;
      totalNumVertices += vertices;
      totalNumVertexBytes += vertices * numBytesPerVertex;
      totalTextureBytes += textureBytes2;
    } else {
    }
  }
  const idxStride = totalNumVertices < 65535 ? 2 : 4;
  const gpuBytes = totalTextureBytes + totalNumVertexBytes + totalNumIndices * idxStride;
  return { primitives, gpuBytes };
}
function toHex(bytes) {
  return Array.prototype.map.call(bytes, (x) => ("00" + x.toString(16).toUpperCase()).slice(-2)).join("");
}
function getChildren(parentId, schema, separatePositionBuffer, predicate) {
  const { childInfo, hashBytes } = schema;
  const children = [];
  const parentPrimitiveCounts = [];
  for (let i = 0; i < childInfo.length; i++) {
    const childIndex = childInfo.childIndex[i];
    const childMask = childInfo.childMask[i];
    const [hashBegin, hashEnd] = getRange(childInfo.hash, i);
    const hash = hashBytes.slice(hashBegin, hashEnd);
    const id = toHex(hash);
    const tolerance = childInfo.tolerance[i];
    const byteSize = childInfo.totalByteSize[i];
    const offset = getVec3(childInfo.offset, i);
    const scale7 = childInfo.scale[i];
    const bounds = {
      box: {
        min: getVec3(childInfo.bounds.box.min, i),
        max: getVec3(childInfo.bounds.box.max, i)
      },
      sphere: {
        center: getVec3(childInfo.bounds.sphere.origo, i),
        radius: childInfo.bounds.sphere.radius[i]
      }
    };
    const { sphere, box } = bounds;
    vec3_exports.add(sphere.center, sphere.center, offset);
    vec3_exports.add(box.min, box.min, offset);
    vec3_exports.add(box.max, box.max, offset);
    const subMeshProjectionRange = getRange(childInfo.subMeshes, i);
    const parentPrimitives = parentPrimitiveCounts[childIndex];
    const { primitives, gpuBytes } = aggregateSubMeshProjections(schema.subMeshProjection, subMeshProjectionRange, separatePositionBuffer, predicate);
    const primitivesDelta = primitives - (parentPrimitives ?? 0);
    let descendantObjectIds;
    if (isCurrentSchema(schema)) {
      const [idsBegin, idsEnd] = getRange(schema.childInfo.descendantObjectIds, i);
      if (idsBegin != idsEnd) {
        descendantObjectIds = [...schema.descendantObjectIds.slice(idsBegin, idsEnd)];
      }
    }
    children.push({ id, childIndex, childMask, tolerance, byteSize, offset, scale: scale7, bounds, primitives, primitivesDelta, gpuBytes, descendantObjectIds });
  }
  return children;
}
function* getSubMeshes(schema, predicate) {
  const { subMesh } = schema;
  for (let i = 0; i < subMesh.length; i++) {
    const objectId = subMesh.objectId[i];
    const primitive = subMesh.primitiveType[i];
    if (predicate?.(objectId) ?? true) {
      const childIndex = subMesh.childIndex[i];
      const objectId2 = subMesh.objectId[i];
      const materialIndex = subMesh.materialIndex[i];
      const materialType = materialIndex == 255 && subMesh.textures.count[i] == 0 && (primitive == PrimitiveType2.triangle_strip || primitive == PrimitiveType2.triangles) ? MaterialType2.elevation : subMesh.materialType[i];
      const primitiveType = subMesh.primitiveType[i];
      const attributes = subMesh.attributes[i];
      const deviations = subMesh.numDeviations[i];
      const vertexRange = getRange(subMesh.vertices, i);
      const indexRange = getRange(subMesh.primitiveVertexIndices, i);
      const textureRange = getRange(subMesh.textures, i);
      yield { childIndex, objectId: objectId2, materialIndex, materialType, primitiveType, attributes, deviations, vertexRange, indexRange, textureRange };
    }
  }
}
function copyToInterleavedArray(wasm2, dst, src, byteOffset, byteStride, begin, end) {
  const offset = byteOffset / dst.BYTES_PER_ELEMENT;
  const stride = byteStride / dst.BYTES_PER_ELEMENT;
  console.assert(Math.round(offset) == offset);
  console.assert(Math.round(stride) == stride);
  let j = offset;
  for (let i = begin; i < end; i++) {
    dst[j] = src[i];
    j += stride;
  }
}
function fillToInterleavedArray(wasm2, dst, src, byteOffset, byteStride, begin, end) {
  const offset = byteOffset / dst.BYTES_PER_ELEMENT;
  const stride = byteStride / dst.BYTES_PER_ELEMENT;
  console.assert(Math.round(offset) == offset);
  console.assert(Math.round(stride) == stride);
  let j = offset;
  for (let i = begin; i < end; i++) {
    dst[j] = src;
    j += stride;
  }
}
function getGeometry(wasm2, schema, separatePositionBuffer, enableOutlines, highlights, predicate) {
  const { vertex, vertexIndex } = schema;
  const filteredSubMeshes = [...getSubMeshes(schema, predicate)];
  let subMeshes = [];
  const referencedTextures = /* @__PURE__ */ new Set();
  const groups = /* @__PURE__ */ new Map();
  for (let i = 0; i < filteredSubMeshes.length; i++) {
    const { materialType, primitiveType, attributes, deviations, childIndex } = filteredSubMeshes[i];
    const key = `${materialType}_${primitiveType}_${attributes}_${deviations}_${childIndex}`;
    let group = groups.get(key);
    if (!group) {
      group = { materialType, primitiveType, attributes, deviations, subMeshIndices: [] };
      groups.set(key, group);
    }
    group.subMeshIndices.push(i);
  }
  highlights.mutex.lockSync();
  for (const { materialType, primitiveType, attributes, deviations, subMeshIndices } of groups.values()) {
    let enumerateBuffers2 = function(possibleBuffers) {
      const buffers = [];
      const indices2 = {};
      for (const [key, value] of Object.entries(possibleBuffers)) {
        const buffer = value;
        let index2 = -1;
        if (buffer) {
          index2 = buffers.indexOf(buffer);
          if (index2 < 0) {
            index2 = buffers.length;
            buffers.push(buffer);
          }
        }
        Reflect.set(indices2, key, index2);
      }
      return [buffers, indices2];
    };
    var enumerateBuffers = enumerateBuffers2;
    if (subMeshIndices.length == 0)
      continue;
    const groupMeshes = subMeshIndices.map((i) => filteredSubMeshes[i]);
    const hasMaterials = groupMeshes.some((m) => m.materialIndex != 255);
    const hasObjectIds = groupMeshes.some((m) => m.objectId != 4294967295);
    const allAttribNames = getVertexAttribNames(attributes, deviations, hasMaterials, hasObjectIds);
    const [posName, ...extraAttribNames] = allAttribNames;
    const attribNames = separatePositionBuffer ? extraAttribNames : allAttribNames;
    const positionStride = computeVertexOffsets([posName], deviations).stride;
    const trianglePosStride = positionStride * 3;
    const attribOffsets = computeVertexOffsets(attribNames, deviations);
    const vertexStride = attribOffsets.stride;
    const childIndices = [...new Set(groupMeshes.map((sm) => sm.childIndex))].sort();
    let numVertices = 0;
    let numIndices = 0;
    let numTriangles = 0;
    for (let i = 0; i < groupMeshes.length; i++) {
      const sm = groupMeshes[i];
      const vtxCnt = sm.vertexRange[1] - sm.vertexRange[0];
      const idxCnt = sm.indexRange[1] - sm.indexRange[0];
      numVertices += vtxCnt;
      numIndices += idxCnt;
      if (primitiveType == PrimitiveType2.triangles) {
        numTriangles += Math.round((idxCnt > 0 ? idxCnt : vtxCnt) / 3);
      }
    }
    const vertexBuffer = new ArrayBuffer(numVertices * vertexStride);
    let trianglePosBuffer;
    let triangleObjectIdBuffer;
    let highlightBufferTri;
    if (enableOutlines && primitiveType == PrimitiveType2.triangles) {
      trianglePosBuffer = new Int16Array(new ArrayBuffer(numTriangles * trianglePosStride));
      triangleObjectIdBuffer = new Uint32Array(numTriangles);
      highlightBufferTri = new Uint8Array(numTriangles);
    }
    const positionBuffer = separatePositionBuffer ? new ArrayBuffer(numVertices * positionStride) : void 0;
    let indexBuffer;
    if (vertexIndex) {
      indexBuffer = new (numVertices < 65535 ? Uint16Array : Uint32Array)(numIndices);
    }
    const highlightBuffer = new Uint8Array(numVertices);
    let indexOffset = 0;
    let vertexOffset = 0;
    let triangleOffset = 0;
    let drawRanges = [];
    const objectRanges = [];
    const [vertexBuffers, bufIdx] = enumerateBuffers2({
      primary: vertexBuffer,
      highlight: highlightBuffer?.buffer,
      pos: positionBuffer,
      triPos: trianglePosBuffer?.buffer,
      triId: triangleObjectIdBuffer?.buffer,
      highlightTri: highlightBufferTri?.buffer
    });
    for (const childIndex of childIndices) {
      const meshes = groupMeshes.filter((sm) => sm.childIndex == childIndex);
      if (meshes.length == 0)
        continue;
      const drawRangeBegin = indexBuffer ? indexOffset : vertexOffset;
      for (const subMesh of meshes) {
        const { vertexRange, indexRange, materialIndex, deviations: deviations2, objectId } = subMesh;
        const context = { materialIndex, objectId };
        const [beginVtx, endVtx] = vertexRange;
        const [beginIdx, endIdx] = indexRange;
        const vertexAttribs = getVertexAttribs(deviations2);
        for (const attribName of attribNames) {
          const { type, components } = vertexAttribs[attribName];
          const dst = new type(vertexBuffer, vertexOffset * vertexStride);
          const count2 = components?.length ?? 1;
          for (var c = 0; c < count2; c++) {
            const offs = attribOffsets[attribName] + c * type.BYTES_PER_ELEMENT;
            if (attribName in vertex) {
              let src = Reflect.get(vertex, attribName);
              if (components) {
                src = Reflect.get(src, components[c]);
              }
              copyToInterleavedArray(wasm2, dst, src, offs, vertexStride, beginVtx, endVtx);
            } else {
              const src = Reflect.get(context, attribName);
              fillToInterleavedArray(wasm2, dst, src, offs, vertexStride, beginVtx, endVtx);
            }
          }
        }
        let numTrianglesInSubMesh = 0;
        if (trianglePosBuffer && triangleObjectIdBuffer) {
          const { x, y, z } = vertex.position;
          let j = triangleOffset * 3 * 3;
          if (vertexIndex && indexBuffer) {
            numTrianglesInSubMesh = (endIdx - beginIdx) / 3;
            for (let i = beginIdx; i < endIdx; i++) {
              const idx = vertexIndex[i] + beginVtx;
              trianglePosBuffer[j++] = x[idx];
              trianglePosBuffer[j++] = y[idx];
              trianglePosBuffer[j++] = z[idx];
            }
          } else {
            numTrianglesInSubMesh = (endVtx - beginVtx) / 3;
            for (let i = beginVtx; i < endVtx; i++) {
              const idx = i;
              trianglePosBuffer[j++] = x[idx];
              trianglePosBuffer[j++] = y[idx];
              trianglePosBuffer[j++] = z[idx];
            }
          }
          triangleObjectIdBuffer.fill(objectId, triangleOffset, triangleOffset + numTrianglesInSubMesh);
        }
        if (positionBuffer) {
          const i16 = new Int16Array(positionBuffer, vertexOffset * positionStride);
          copyToInterleavedArray(wasm2, i16, vertex.position.x, 0, positionStride, beginVtx, endVtx);
          copyToInterleavedArray(wasm2, i16, vertex.position.y, 2, positionStride, beginVtx, endVtx);
          copyToInterleavedArray(wasm2, i16, vertex.position.z, 4, positionStride, beginVtx, endVtx);
        }
        if (vertexIndex && indexBuffer) {
          for (let i = beginIdx; i < endIdx; i++) {
            indexBuffer[indexOffset++] = vertexIndex[i] + vertexOffset;
          }
        }
        const endVertex = vertexOffset + (endVtx - beginVtx);
        const endTriangle = triangleOffset + (endIdx - beginIdx) / 3;
        const highlightIndex = highlights.indices[objectId] ?? 0;
        if (highlightIndex) {
          highlightBuffer.fill(highlightIndex, vertexOffset, endVertex);
          highlightBufferTri?.fill(highlightIndex, triangleOffset, endTriangle);
        }
        const prev = objectRanges.length - 1;
        if (prev >= 0 && objectRanges[prev].objectId == objectId) {
          objectRanges[prev].endVertex = endVertex;
          objectRanges[prev].endTriangle = endTriangle;
        } else {
          objectRanges.push({ objectId, beginVertex: vertexOffset, endVertex, beginTriangle: triangleOffset, endTriangle });
        }
        triangleOffset += numTrianglesInSubMesh;
        vertexOffset += endVtx - beginVtx;
      }
      const drawRangeEnd = indexBuffer ? indexOffset : vertexOffset;
      const byteOffset = drawRangeBegin * (indexBuffer ? indexBuffer.BYTES_PER_ELEMENT : vertexStride);
      const count = drawRangeEnd - drawRangeBegin;
      drawRanges.push({ childIndex, byteOffset, first: drawRangeBegin, count });
    }
    console.assert(vertexOffset == numVertices);
    console.assert(indexOffset == numIndices);
    console.assert(triangleOffset == (triangleObjectIdBuffer?.length ?? 0));
    const indices = indexBuffer ?? numVertices;
    const [beginTexture, endTexture] = groupMeshes[0].textureRange;
    let baseColorTexture;
    if (endTexture > beginTexture) {
      baseColorTexture = beginTexture;
    }
    if (baseColorTexture != void 0) {
      referencedTextures.add(baseColorTexture);
    }
    const stride = vertexStride;
    const deviationsKind = deviations == 0 || deviations == 1 ? "FLOAT" : `FLOAT_VEC${deviations}`;
    const vertexAttributes = {
      position: { kind: "FLOAT_VEC4", buffer: bufIdx.pos, componentCount: 3, componentType: "SHORT", normalized: true, byteOffset: attribOffsets["position"], byteStride: separatePositionBuffer ? 0 : stride },
      normal: (attributes & OptionalVertexAttribute2.normal) != 0 ? { kind: "FLOAT_VEC3", buffer: bufIdx.primary, componentCount: 3, componentType: "BYTE", normalized: true, byteOffset: attribOffsets["normal"], byteStride: stride } : null,
      material: hasMaterials ? { kind: "UNSIGNED_INT", buffer: bufIdx.primary, componentCount: 1, componentType: "UNSIGNED_BYTE", normalized: false, byteOffset: attribOffsets["materialIndex"], byteStride: stride } : null,
      objectId: hasObjectIds ? { kind: "UNSIGNED_INT", buffer: bufIdx.primary, componentCount: 1, componentType: "UNSIGNED_INT", normalized: false, byteOffset: attribOffsets["objectId"], byteStride: stride } : null,
      texCoord: (attributes & OptionalVertexAttribute2.texCoord) != 0 ? { kind: "FLOAT_VEC2", buffer: bufIdx.primary, componentCount: 2, componentType: "HALF_FLOAT", normalized: false, byteOffset: attribOffsets["texCoord"], byteStride: stride } : null,
      color: (attributes & OptionalVertexAttribute2.color) != 0 ? { kind: "FLOAT_VEC4", buffer: bufIdx.primary, componentCount: 4, componentType: "UNSIGNED_BYTE", normalized: true, byteOffset: attribOffsets["color"], byteStride: stride } : null,
      projectedPos: (attributes & OptionalVertexAttribute2.projectedPos) != 0 ? { kind: "FLOAT_VEC4", buffer: bufIdx.primary, componentCount: 3, componentType: "SHORT", normalized: true, byteOffset: attribOffsets["projectedPos"], byteStride: stride } : null,
      deviations: deviations != 0 ? { kind: deviationsKind, buffer: bufIdx.primary, componentCount: deviations, componentType: "HALF_FLOAT", normalized: false, byteOffset: attribOffsets["deviations"], byteStride: stride } : null,
      triangles0: trianglePosBuffer ? { kind: "FLOAT_VEC4", buffer: bufIdx.triPos, componentCount: 3, componentType: "SHORT", normalized: true, byteOffset: 0, byteStride: 18 } : null,
      triangles1: trianglePosBuffer ? { kind: "FLOAT_VEC4", buffer: bufIdx.triPos, componentCount: 3, componentType: "SHORT", normalized: true, byteOffset: 6, byteStride: 18 } : null,
      triangles2: trianglePosBuffer ? { kind: "FLOAT_VEC4", buffer: bufIdx.triPos, componentCount: 3, componentType: "SHORT", normalized: true, byteOffset: 12, byteStride: 18 } : null,
      trianglesObjId: trianglePosBuffer ? { kind: "UNSIGNED_INT", buffer: bufIdx.triId, componentCount: 1, componentType: "UNSIGNED_INT", normalized: false, byteOffset: 0, byteStride: 4 } : null,
      highlight: { kind: "UNSIGNED_INT", buffer: bufIdx.highlight, componentCount: 1, componentType: "UNSIGNED_BYTE", normalized: false, byteOffset: 0, byteStride: 0 },
      highlightTri: { kind: "UNSIGNED_INT", buffer: bufIdx.highlightTri, componentCount: 1, componentType: "UNSIGNED_BYTE", normalized: false, byteOffset: 0, byteStride: 0 }
    };
    objectRanges.sort((a, b) => a.objectId - b.objectId);
    subMeshes.push({
      materialType,
      primitiveType: primitiveTypeStrings[primitiveType],
      numVertices,
      numTriangles,
      objectRanges,
      vertexAttributes,
      vertexBuffers,
      indices,
      baseColorTexture,
      drawRanges
    });
  }
  highlights.mutex.unlock();
  const textures = new Array(schema.textureInfo.length);
  const { textureInfo } = schema;
  for (const i of referencedTextures) {
    const [begin, end] = getRange(textureInfo.pixelRange, i);
    const semantic = textureInfo.semantic[i];
    const transform = [
      textureInfo.transform.e00[i],
      textureInfo.transform.e01[i],
      textureInfo.transform.e02[i],
      textureInfo.transform.e10[i],
      textureInfo.transform.e11[i],
      textureInfo.transform.e12[i],
      textureInfo.transform.e20[i],
      textureInfo.transform.e21[i],
      textureInfo.transform.e22[i]
    ];
    const ktx = schema.texturePixels.subarray(begin, end);
    const params = parseKTX(ktx);
    textures[i] = { semantic, transform, params };
  }
  return { subMeshes, textures };
}
function parseNode(wasm2, id, separatePositionBuffer, enableOutlines, version3, buffer, highlights, applyFilter) {
  console.assert(isSupportedVersion(version3));
  const r = new BufferReader(buffer);
  var schema = version3 == version ? readSchema(r) : readSchema2(r);
  let predicate;
  predicate = applyFilter ? (objectId) => highlights.indices[objectId] != 255 : void 0;
  const childInfos = getChildren(id, schema, separatePositionBuffer, predicate);
  const geometry = getGeometry(wasm2, schema, separatePositionBuffer, enableOutlines, highlights, predicate);
  return { childInfos, geometry };
}

// /projects/Novorender/ts/node_modules/@novorender/wasm-parser/wasm_parser_bg.js
var wasm_parser_bg_exports = {};
__export(wasm_parser_bg_exports, {
  __wbg_set_wasm: () => __wbg_set_wasm,
  __wbindgen_copy_to_typed_array: () => __wbindgen_copy_to_typed_array,
  __wbindgen_object_drop_ref: () => __wbindgen_object_drop_ref,
  copy_to_interleaved_array_f32: () => copy_to_interleaved_array_f32,
  copy_to_interleaved_array_f64: () => copy_to_interleaved_array_f64,
  copy_to_interleaved_array_i16: () => copy_to_interleaved_array_i16,
  copy_to_interleaved_array_i32: () => copy_to_interleaved_array_i32,
  copy_to_interleaved_array_i8: () => copy_to_interleaved_array_i8,
  copy_to_interleaved_array_u16: () => copy_to_interleaved_array_u16,
  copy_to_interleaved_array_u32: () => copy_to_interleaved_array_u32,
  copy_to_interleaved_array_u8: () => copy_to_interleaved_array_u8,
  fill_to_interleaved_array_f32: () => fill_to_interleaved_array_f32,
  fill_to_interleaved_array_f64: () => fill_to_interleaved_array_f64,
  fill_to_interleaved_array_i16: () => fill_to_interleaved_array_i16,
  fill_to_interleaved_array_i32: () => fill_to_interleaved_array_i32,
  fill_to_interleaved_array_i8: () => fill_to_interleaved_array_i8,
  fill_to_interleaved_array_u16: () => fill_to_interleaved_array_u16,
  fill_to_interleaved_array_u32: () => fill_to_interleaved_array_u32,
  fill_to_interleaved_array_u8: () => fill_to_interleaved_array_u8,
  init: () => init
});
var wasm;
function __wbg_set_wasm(val) {
  wasm = val;
}
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getArrayU8FromWasm0(ptr, len5) {
  ptr = ptr >>> 0;
  return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len5);
}
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
function init() {
  wasm.init();
}
var WASM_VECTOR_LEN = 0;
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function copy_to_interleaved_array_u8(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray8ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
var cachedUint16Memory0 = null;
function getUint16Memory0() {
  if (cachedUint16Memory0 === null || cachedUint16Memory0.byteLength === 0) {
    cachedUint16Memory0 = new Uint16Array(wasm.memory.buffer);
  }
  return cachedUint16Memory0;
}
function passArray16ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 2, 2) >>> 0;
  getUint16Memory0().set(arg, ptr / 2);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function copy_to_interleaved_array_u16(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray16ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
var cachedUint32Memory0 = null;
function getUint32Memory0() {
  if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
    cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachedUint32Memory0;
}
function passArray32ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 4, 4) >>> 0;
  getUint32Memory0().set(arg, ptr / 4);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function copy_to_interleaved_array_u32(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray32ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
function copy_to_interleaved_array_i8(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray8ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
function copy_to_interleaved_array_i16(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray16ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
function copy_to_interleaved_array_i32(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArray32ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
var cachedFloat32Memory0 = null;
function getFloat32Memory0() {
  if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {
    cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);
  }
  return cachedFloat32Memory0;
}
function passArrayF32ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 4, 4) >>> 0;
  getFloat32Memory0().set(arg, ptr / 4);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function copy_to_interleaved_array_f32(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArrayF32ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArrayF32ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_f32(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
var cachedFloat64Memory0 = null;
function getFloat64Memory0() {
  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
  }
  return cachedFloat64Memory0;
}
function passArrayF64ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 8, 8) >>> 0;
  getFloat64Memory0().set(arg, ptr / 8);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function copy_to_interleaved_array_f64(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArrayF64ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  const ptr1 = passArrayF64ToWasm0(src, wasm.__wbindgen_malloc);
  const len1 = WASM_VECTOR_LEN;
  wasm.copy_to_interleaved_array_f64(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_u8(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_u16(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_u32(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_i8(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_i16(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_i32(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_f32(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArrayF32ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_f32(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function fill_to_interleaved_array_f64(dst, src, byte_offset, byte_stride, begin, end) {
  var ptr0 = passArrayF64ToWasm0(dst, wasm.__wbindgen_malloc);
  var len0 = WASM_VECTOR_LEN;
  wasm.fill_to_interleaved_array_f64(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);
}
function __wbindgen_copy_to_typed_array(arg0, arg1, arg2) {
  new Uint8Array(getObject(arg2).buffer, getObject(arg2).byteOffset, getObject(arg2).byteLength).set(getArrayU8FromWasm0(arg0, arg1));
}
function __wbindgen_object_drop_ref(arg0) {
  takeObject(arg0);
}

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/wasm_loader.ts
async function esbuildWasmInstance(wasmData) {
  let imports = {
    ["./wasm_parser_bg.js"]: wasm_parser_bg_exports
  };
  const { instance } = await WebAssembly.instantiate(wasmData, imports);
  __wbg_set_wasm(instance.exports);
  return wasm_parser_bg_exports;
}

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/handler.ts
var LoaderHandler = class {
  constructor(send) {
    this.send = send;
  }
  downloader = new Downloader();
  downloads = /* @__PURE__ */ new Map();
  highlights = void 0;
  // will be set right after construction by "buffer" message
  wasm;
  receive(msg) {
    switch (msg.kind) {
      case "init":
        this.init(msg);
        break;
      case "parse":
        this.parse(msg);
        break;
      case "load":
        this.load(msg);
        break;
      case "abort":
        this.abort(msg);
        break;
      case "abort_all":
        this.abortAll(msg);
        break;
    }
  }
  async init(msg) {
    const { wasmData, buffer } = msg;
    this.wasm = await esbuildWasmInstance(wasmData);
    const indices = new Uint8Array(buffer, 4);
    const mutex = new Mutex(buffer);
    this.highlights = { buffer, indices, mutex };
    const setBufferMsg = { kind: "buffer" };
    this.send(setBufferMsg);
  }
  parseBuffer(buffer, params) {
    if (this.wasm) {
      const { highlights } = this;
      const { id, version: version3, separatePositionsBuffer, enableOutlines, applyFilter } = params;
      const { childInfos, geometry } = parseNode(this.wasm, id, separatePositionsBuffer, enableOutlines, version3, buffer, highlights, applyFilter);
      const readyMsg = { kind: "ready", id, childInfos, geometry };
      const transfer2 = [];
      for (const { vertexBuffers, indices } of geometry.subMeshes) {
        transfer2.push(...vertexBuffers);
        if (typeof indices != "number") {
          transfer2.push(indices.buffer);
        }
      }
      this.send(readyMsg, transfer2);
    } else {
      console.error("Wasm is not initialized yet");
    }
  }
  async parse(params) {
    const { id, buffer } = params;
    try {
      this.parseBuffer(buffer, params);
    } catch (error) {
      this.error(id, error);
    }
  }
  async load(params) {
    const { downloader, downloads } = this;
    const { url, id, byteSize } = params;
    try {
      const download3 = downloader.downloadArrayBufferAbortable(url, new ArrayBuffer(byteSize));
      downloads.set(id, download3);
      const buffer = await download3.result;
      downloads.delete(id);
      if (buffer) {
        this.parseBuffer(buffer, params);
      } else {
        const abortedMsg = { kind: "aborted", id };
        this.send(abortedMsg);
      }
    } catch (error) {
      this.error(id, error);
    }
  }
  removeNode(id) {
    const { downloads } = this;
    const download3 = downloads.get(id);
    downloads.delete(id);
    return { download: download3 };
  }
  error(id, error) {
    const { download: download3 } = this.removeNode(id);
    const errorMsg = { kind: "error", id, error };
    this.send(errorMsg);
  }
  abort(params) {
    const { id } = params;
    const { download: download3 } = this.removeNode(id);
    download3?.abort();
  }
  async abortAll(params) {
    const { downloads, downloader } = this;
    for (const download3 of downloads.values()) {
      download3.abort();
    }
    await downloader.complete();
    console.assert(downloads.size == 0);
    const abortedAllMsg = { kind: "aborted_all" };
    this.send(abortedAllMsg);
  }
};

// /projects/Novorender/ts/dist/core3d/modules/octree/worker/index.ts
var handler = new LoaderHandler((msg, transfer2) => {
  postMessage(msg, { transfer: transfer2 });
});
onmessage = (e) => {
  const msg = e.data;
  if (msg.kind == "close") {
    close();
  } else {
    handler.receive(msg);
  }
};

// /projects/Novorender/ts/dist/core3d/modules/octree/mesh.ts
function convertAttributes(attributes, buffers) {
  const ret = {};
  function convertAttrib(a) {
    return a ? { ...a, buffer: buffers[a.buffer] } : null;
  }
  for (const [key, value] of Object.entries(attributes)) {
    ret[key] = convertAttrib(value);
  }
  return ret;
}
function* createMeshes(resourceBin, geometry) {
  const textures = geometry.textures.map((ti) => {
    if (ti) {
      return resourceBin.createTexture(ti.params);
    }
  });
  for (const subMesh of geometry.subMeshes) {
    const { vertexAttributes, vertexBuffers, indices, numVertices, numTriangles, drawRanges, objectRanges, materialType } = subMesh;
    const buffers = vertexBuffers.map((vb) => {
      return resourceBin.createBuffer({ kind: "ARRAY_BUFFER", srcData: vb });
    });
    const ib = typeof indices != "number" ? resourceBin.createBuffer({ kind: "ELEMENT_ARRAY_BUFFER", srcData: indices }) : void 0;
    const count = typeof indices == "number" ? indices : indices.length;
    const indexType = indices instanceof Uint16Array ? "UNSIGNED_SHORT" : "UNSIGNED_INT";
    const { triangles0, triangles1, triangles2, trianglesObjId, position, normal, material, objectId, texCoord, color, projectedPos, deviations, highlight, highlightTri } = convertAttributes(vertexAttributes, buffers);
    const triangleAttributes = [triangles0, triangles1, triangles2, trianglesObjId, highlightTri];
    const renderAttributes = [position, normal, material, objectId, texCoord, color, projectedPos, deviations, highlight];
    const highlightVB = buffers[vertexAttributes.highlight.buffer];
    const highlightTriVB = triangles0 ? buffers[vertexAttributes.highlightTri.buffer] : null;
    const vao = resourceBin.createVertexArray({ attributes: renderAttributes, indices: ib });
    const vaoPosOnly = position.buffer != 0 ? resourceBin.createVertexArray({ attributes: [position], indices: ib }) : null;
    const vaoTriangles = triangleAttributes ? resourceBin.createVertexArray({ attributes: triangleAttributes }) : null;
    resourceBin.subordinate(vao, ...buffers.filter((buf) => buf != highlightVB && buf != highlightTriVB));
    if (ib) {
      resourceBin.subordinate(vao, ib);
    }
    const drawParams = ib ? { kind: "elements", mode: subMesh.primitiveType, indexType, count } : { kind: "arrays", mode: subMesh.primitiveType, count };
    const baseColorTextureIndex = subMesh.baseColorTexture;
    const baseColorTexture = textures[baseColorTextureIndex] ?? null;
    yield { vao, vaoPosOnly, vaoTriangles, highlightVB, highlightTriVB, drawParams, drawRanges, numVertices, numTriangles, objectRanges, materialType, baseColorTexture };
  }
}
function updateMeshHighlights(gl, mesh, highlights) {
  const { highlightVB, highlightTriVB } = mesh;
  if (highlightVB) {
    const highlightBuffer = new Uint8Array(mesh.numVertices);
    if (highlights) {
      for (const { objectId, beginVertex, endVertex } of mesh.objectRanges) {
        const highlight = highlights[objectId];
        if (highlight) {
          highlightBuffer.fill(highlight, beginVertex, endVertex);
        }
      }
    }
    glUpdateBuffer(gl, { kind: "ARRAY_BUFFER", srcData: highlightBuffer, targetBuffer: highlightVB });
  }
  if (highlightTriVB) {
    const highlightTriBuffer = new Uint8Array(mesh.numTriangles);
    if (highlights) {
      for (const { objectId, beginTriangle, endTriangle } of mesh.objectRanges) {
        const highlight = highlights[objectId];
        if (highlight) {
          highlightTriBuffer.fill(highlight, beginTriangle, endTriangle);
        }
      }
    }
    glUpdateBuffer(gl, { kind: "ARRAY_BUFFER", srcData: highlightTriBuffer, targetBuffer: highlightTriVB });
  }
}
function deleteMesh(resourceBin, mesh) {
  const { vao, vaoPosOnly, vaoTriangles, highlightVB, highlightTriVB, baseColorTexture } = mesh;
  resourceBin.delete(vao, vaoPosOnly, vaoTriangles, highlightVB, highlightTriVB, baseColorTexture);
}
function getMultiDrawParams(mesh, childMask) {
  const drawRanges = mesh.drawRanges.filter((r) => (1 << r.childIndex & childMask) != 0);
  if (drawRanges.length == 0) {
    return;
  }
  const offsetsList = new Int32Array(drawRanges.map((r) => r.byteOffset));
  const countsList = new Int32Array(drawRanges.map((r) => r.count));
  const drawCount = offsetsList.length;
  const { drawParams } = mesh;
  const { mode } = drawParams;
  function isElements2(params) {
    return "indexType" in params;
  }
  if (isElements2(drawParams)) {
    const { indexType } = drawParams;
    return {
      kind: "elements_multidraw",
      mode,
      drawCount,
      indexType,
      byteOffsets: offsetsList,
      counts: countsList
    };
  } else {
    return {
      kind: "arrays_multidraw",
      mode,
      drawCount,
      firstsList: offsetsList,
      counts: countsList
    };
  }
}
function meshPrimitiveCount(mesh, renderedChildMask) {
  let numPrimitives = 0;
  const primitiveType = mesh.drawParams.mode ?? "TRIANGLES";
  for (const drawRange of mesh.drawRanges) {
    const childMask = 1 << drawRange.childIndex;
    if ((renderedChildMask & childMask) != 0) {
      numPrimitives += calcNumPrimitives2(drawRange.count, primitiveType);
    }
  }
  return numPrimitives;
}
function calcNumPrimitives2(vertexCount, primitiveType) {
  let primitiveCount = 0;
  switch (primitiveType) {
    case "TRIANGLES":
      primitiveCount = vertexCount / 3;
      break;
    case "TRIANGLE_STRIP":
    case "TRIANGLE_FAN":
      primitiveCount = vertexCount - 2;
      break;
    case "LINES":
      primitiveCount = vertexCount / 2;
      break;
    case "LINE_STRIP":
      primitiveCount = vertexCount - 1;
      break;
    default:
      primitiveCount = vertexCount;
  }
  return primitiveCount;
}

// /projects/Novorender/ts/dist/core3d/modules/octree/loader.ts
var NodeLoader = class {
  constructor(worker) {
    this.worker = worker;
    worker.onmessage = (e) => {
      this.receive(e.data);
    };
  }
  payloadPromises = /* @__PURE__ */ new Map();
  abortAllPromise = Promise.resolve();
  resolveAbortAll;
  bufferPromise = Promise.resolve();
  resolveBuffer;
  aborted = false;
  async init(buffer, wasmData) {
    this.bufferPromise = new Promise((resolve) => {
      this.resolveBuffer = resolve;
    });
    const msg = { kind: "init", buffer, wasmData };
    this.send(msg);
    await this.bufferPromise;
  }
  get activeDownloads() {
    return this.payloadPromises.size;
  }
  send(msg) {
    this.worker.postMessage(msg);
  }
  receive(msg) {
    if (msg.kind == "buffer") {
      const { resolveBuffer } = this;
      this.resolveBuffer = void 0;
      resolveBuffer?.();
      return;
    }
    if (msg.kind == "aborted_all") {
      const { resolveAbortAll } = this;
      this.resolveAbortAll = void 0;
      resolveAbortAll?.();
      return;
    }
    const { id } = msg;
    const { payloadPromises } = this;
    const payloadPromise = payloadPromises.get(id);
    if (payloadPromise) {
      payloadPromises.delete(id);
      const { resolve, reject } = payloadPromise;
      switch (msg.kind) {
        case "ready":
          resolve(msg);
          break;
        case "aborted":
          resolve(void 0);
          break;
        case "error":
          reject(msg.error);
          break;
      }
    }
  }
  abortAll() {
    this.abortAllPromise = new Promise((resolve) => {
      this.resolveAbortAll = resolve;
    });
    const msg = { kind: "abort_all" };
    this.send(msg);
    this.payloadPromises.clear();
  }
  dispose() {
    const msg = { kind: "close" };
    this.send(msg);
  }
  parseNode(buffer, id, deviceProfile, version3) {
    const { payloadPromises } = this;
    const enableOutlines = deviceProfile.features.outline;
    const applyFilter = true;
    const parseMsg = { kind: "parse", buffer, id, version: version3, separatePositionsBuffer: true, enableOutlines, applyFilter };
    const promise = new Promise((resolve, reject) => {
      payloadPromises.set(id, { resolve, reject });
    });
    this.send(parseMsg);
    return promise;
  }
  loadNode(node, version3) {
    const { payloadPromises } = this;
    const { deviceProfile } = node.context.renderContext;
    const { id, data } = node;
    if (node.context.url == void 0) {
      return Promise.resolve(void 0);
    }
    const url = new URL(node.context.url);
    url.pathname += node.path;
    const { byteSize } = data;
    const enableOutlines = deviceProfile.features.outline;
    const applyFilter = true;
    const loadMsg = { kind: "load", id, version: version3, url: url.toString(), byteSize, separatePositionsBuffer: true, enableOutlines, applyFilter };
    console.assert(byteSize != 0);
    const abortMsg = { kind: "abort", id };
    const abort = () => {
      this.send(abortMsg);
    };
    node.download = { abort };
    this.send(loadMsg);
    return new Promise((resolve, reject) => {
      payloadPromises.set(id, { resolve, reject });
    });
  }
};

// /projects/Novorender/ts/dist/core3d/modules/octree/node.ts
var OctreeNode2 = class _OctreeNode {
  constructor(context, data, parent) {
    this.context = context;
    this.data = data;
    this.geometryKind = typeof parent == "object" ? parent.geometryKind : parent;
    this.parent = typeof parent == "object" ? parent : void 0;
    const { sphere, box } = data.bounds;
    const { center, radius } = sphere;
    this.id = data.id;
    this.resourceBin = context.renderContext.resourceBin("Node");
    this.center = center;
    this.radius = radius;
    this.center4 = vec4_exports.fromValues(center[0], center[1], center[2], 1);
    const [x0, y0, z0] = box.min;
    const [x1, y1, z1] = box.max;
    this.corners = [
      vec4_exports.fromValues(x0, y0, z0, 1),
      vec4_exports.fromValues(x1, y0, z0, 1),
      vec4_exports.fromValues(x0, y1, z0, 1),
      vec4_exports.fromValues(x1, y1, z0, 1),
      vec4_exports.fromValues(x0, y0, z1, 1),
      vec4_exports.fromValues(x1, y0, z1, 1),
      vec4_exports.fromValues(x0, y1, z1, 1),
      vec4_exports.fromValues(x1, y1, z1, 1)
    ];
    this.size = Math.max(box.max[0] - box.min[0], Math.max(box.max[1] - box.min[1], box.max[2] - box.min[2])) * 4;
    this.uniformsData = glUBOProxy({
      modelLocalMatrix: "mat4",
      tolerance: "float",
      debugColor: "vec4",
      min: "vec3",
      max: "vec3"
    });
    this.uniformsData.values.tolerance = Math.pow(2, data.tolerance);
  }
  id;
  parent;
  resourceBin;
  center;
  radius;
  size;
  children = [];
  meshes = [];
  uniformsData;
  geometryKind;
  uniforms;
  center4;
  corners;
  hasValidModelLocalMatrix = false;
  state = 0 /* collapsed */;
  download;
  visibility = 0 /* undefined */;
  viewDistance = 0;
  projectedSize = 0;
  static errorModifiersPinhole = {
    [0 /* terrain */]: 0.05,
    [1 /* triangles */]: 1,
    [2 /* lines */]: 0.5,
    [3 /* points */]: 0.35,
    [4 /* documents */]: 0.08
  };
  static errorModifiersOrtho = {
    [0 /* terrain */]: 0.25,
    [1 /* triangles */]: 5,
    [2 /* lines */]: 2.5,
    [3 /* points */]: 0.75,
    [4 /* documents */]: 0.4
  };
  dispose() {
    const { meshes, uniforms, children, resourceBin } = this;
    for (const mesh of meshes) {
      deleteMesh(resourceBin, mesh);
    }
    if (uniforms) {
      resourceBin.delete(uniforms);
      this.uniforms = void 0;
    }
    console.assert(resourceBin.size == 0);
    resourceBin.dispose();
    for (const child of children) {
      child.dispose();
    }
    meshes.length = 0;
    children.length = 0;
    this.download?.abort();
    this.download = void 0;
    this.state = 0 /* collapsed */;
  }
  get isRoot() {
    return !this.parent;
  }
  get path() {
    return this.id;
  }
  get isSplit() {
    return this.state != 0 /* collapsed */;
  }
  get hasGeometry() {
    return this.meshes.length > 0 || this.uniforms != void 0;
  }
  get renderedChildMask() {
    let { childMask } = this.data;
    for (const child of this.children) {
      if (child.hasGeometry) {
        childMask &= ~(1 << child.data.childIndex);
      }
    }
    return childMask;
  }
  shouldSplit(projectedSizeSplitThreshold) {
    const { visibility, projectedSize, context, geometryKind } = this;
    const hidden = context.hidden[geometryKind ?? -1] ?? false;
    return !hidden && (this.isRoot || visibility != 1 /* none */ && projectedSize > projectedSizeSplitThreshold) && !this.areAllDescendantsHidden;
  }
  get areAllDescendantsHidden() {
    const { descendantObjectIds } = this.data;
    if (descendantObjectIds) {
      const { highlights } = this.context;
      if (descendantObjectIds.every((id) => highlights[id] >= 254)) {
        return true;
      }
    }
    return false;
  }
  intersectsPlane(plane) {
    const { center4, radius, corners } = this;
    const distance4 = vec4_exports.dot(plane, center4);
    if (Math.abs(distance4) > radius) {
      return false;
    }
    let side = 0;
    for (const corner of corners) {
      const distance5 = vec4_exports.dot(plane, corner);
      const distSgn = Math.sign(distance5);
      if (side && distSgn != side) {
        return true;
      }
      if (distSgn) {
        side = distSgn;
      }
    }
    return false;
  }
  computeVisibility(state) {
    const { center4, radius, corners } = this;
    let fullyInside = true;
    let fullyOutside = false;
    const { planes } = state.viewFrustum;
    for (const plane of planes) {
      const distance4 = vec4_exports.dot(plane, center4);
      if (distance4 > radius) {
        fullyOutside = true;
        fullyInside = false;
        break;
      } else if (distance4 > -radius)
        fullyInside = false;
    }
    if (fullyInside === fullyOutside) {
      fullyOutside = true;
      fullyInside = true;
      for (const corner of corners) {
        for (const plane of planes) {
          const distance4 = vec4_exports.dot(plane, corner);
          if (distance4 > 0) {
            fullyInside = false;
          } else {
            fullyOutside = false;
          }
        }
      }
    }
    let visibility = 0 /* undefined */;
    if (fullyOutside) {
      visibility = 1 /* none */;
    } else if (!fullyInside) {
      visibility = 2 /* partial */;
    } else {
      visibility = 3 /* full */;
    }
    return visibility;
  }
  get renderedPrimitives() {
    let numPrimitives = 0;
    if (this.visibility != 1 /* none */) {
      const { renderedChildMask } = this;
      if (renderedChildMask) {
        for (const mesh of this.meshes) {
          numPrimitives += meshPrimitiveCount(mesh, renderedChildMask);
        }
      }
    }
    return numPrimitives;
  }
  update(state, parentVisibility = 2 /* partial */) {
    this.visibility = parentVisibility == 2 /* partial */ ? this.computeVisibility(state) : parentVisibility;
    const { context, center4, visibility, radius, uniforms, data, uniformsData, children } = this;
    const { camera, matrices, viewFrustum } = state;
    const imagePlane = viewFrustum.image;
    const projection2 = matrices.getMatrix(1 /* View */, 2 /* Clip */);
    const viewDistance = this.viewDistance = vec4_exports.dot(imagePlane, center4);
    if (visibility <= 1 /* none */) {
      this.projectedSize = 0;
    } else if (camera.kind == "pinhole") {
      const distance4 = Math.max(1e-3, viewDistance - radius);
      this.projectedSize = this.size * _OctreeNode.errorModifiersPinhole[this.geometryKind] * projection2[5] / (-distance4 * projection2[11]);
    } else {
      this.projectedSize = this.size * _OctreeNode.errorModifiersOrtho[this.geometryKind] * projection2[5];
    }
    if (context.localSpaceChanged || !this.hasValidModelLocalMatrix) {
      let { offset, scale: scale7 } = data;
      const [ox, oy, oz] = offset;
      const [tx, ty, tz] = state.localSpaceTranslation;
      const modelLocalMatrix = mat4_exports.fromValues(
        scale7,
        0,
        0,
        0,
        0,
        scale7,
        0,
        0,
        0,
        0,
        scale7,
        0,
        ox - tx,
        oy,
        oz - tz,
        1
      );
      const { values } = this.uniformsData;
      values.modelLocalMatrix = modelLocalMatrix;
      if (uniforms) {
        glUpdateBuffer(context.renderContext.gl, { kind: "UNIFORM_BUFFER", srcData: uniformsData.buffer, targetBuffer: uniforms });
      }
      this.hasValidModelLocalMatrix = true;
    }
    if (context.debug) {
      let r = 0, g = 0, b = 0;
      switch (visibility) {
        case 2 /* partial */:
          g = 0.25;
          break;
        case 3 /* full */:
          g = 1;
          break;
      }
      switch (this.state) {
        case 2 /* downloading */:
          r = 1;
          break;
        case 3 /* ready */:
          b = 1;
          break;
      }
      const worldLocalMatrix = mat4_exports.fromTranslation(mat4_exports.create(), vec3_exports.negate(vec3_exports.create(), state.localSpaceTranslation));
      const { min: min4, max: max4 } = data.bounds.box;
      const { values } = uniformsData;
      values.debugColor = vec4_exports.fromValues(r, g, b, 1);
      values.min = vec3_exports.transformMat4(vec3_exports.create(), min4, worldLocalMatrix);
      values.max = vec3_exports.transformMat4(vec3_exports.create(), max4, worldLocalMatrix);
      if (uniforms) {
        glUpdateBuffer(context.renderContext.gl, { kind: "UNIFORM_BUFFER", srcData: uniformsData.buffer, targetBuffer: uniforms });
      }
    }
    for (const child of children) {
      child.update(state, this.visibility);
    }
  }
  async downloadNode() {
    const { context, children, meshes, resourceBin } = this;
    const { renderContext, loader, version: version3, highlightGeneration } = context;
    this.state = 2 /* downloading */;
    const payload = await loader.loadNode(this, version3);
    if (payload) {
      const { childInfos, geometry } = payload;
      for (const data of childInfos) {
        const child = new _OctreeNode(context, data, this);
        children.push(child);
      }
      meshes.push(...createMeshes(resourceBin, geometry));
      if (context.highlightGeneration != highlightGeneration) {
        _OctreeNode.updateHighlights(context, meshes);
      }
      this.uniforms = resourceBin.createBuffer({ kind: "UNIFORM_BUFFER", byteSize: this.uniformsData.buffer.byteLength });
      glUpdateBuffer(this.context.renderContext.gl, { kind: "UNIFORM_BUFFER", srcData: this.uniformsData.buffer, targetBuffer: this.uniforms });
      renderContext.changed = true;
      this.state = 3 /* ready */;
    } else {
      this.state = 0 /* collapsed */;
    }
  }
  applyHighlights(highlights) {
    const { context, meshes } = this;
    const { gl } = context.renderContext;
    for (const mesh of meshes) {
      updateMeshHighlights(gl, mesh, highlights);
    }
  }
  static updateHighlights(context, meshes) {
    const { renderContext, highlights } = context;
    const { gl } = renderContext;
    for (const mesh of meshes) {
      updateMeshHighlights(gl, mesh, highlights);
    }
  }
};

// /projects/Novorender/ts/dist/core3d/scene.ts
async function downloadScene(url, abortSignal) {
  const fullUrl = new URL(url);
  fullUrl.pathname += "scene.json";
  let config = await download(fullUrl, "json", abortSignal);
  if (config.up) {
    let { offset, center } = config;
    offset = flipCADToGLVec(offset);
    center = flipCADToGLVec(center);
    config = { ...config, offset, center };
  }
  if (!isSupportedVersion(config.version)) {
    throw new Error(`Unsupported scene version: ${config.variants}!`);
  }
  return { url: url.toString(), config };
}
function flipCADToGLVec(v) {
  const [x, y, z] = v;
  return vec3_exports.fromValues(x, z, -y);
}
async function createSceneRootNodes(context, config, deviceProfile) {
  const { buffer } = decodeBase64(config.root);
  const { loader } = context;
  const result = await loader.parseNode(buffer, "", deviceProfile, config.version);
  if (!result)
    return;
  const { childInfos } = result;
  const rootNodes = {};
  let hasNodes = false;
  for (const childInfo of childInfos) {
    const geometryKind = childInfo.childIndex;
    const child = new OctreeNode2(context, childInfo, geometryKind);
    rootNodes[childInfo.childIndex] = child;
    hasNodes = true;
  }
  return hasNodes ? rootNodes : void 0;
}
async function download(url, kind, signal) {
  const response = await requestOfflineFile(url.pathname) ?? await fetch(url, { mode: "cors", signal });
  if (response.ok) {
    return await response[kind]();
  } else {
    throw new Error(`HTTP Error:${response.status} ${response.status}`);
  }
}

// /projects/Novorender/ts/dist/core3d/modules/octree/gradient.ts
function gradientRange(gradient) {
  if (gradient.knots.length == 0)
    return [0, 0];
  return [gradient.knots[0].position, gradient.knots[gradient.knots.length - 1].position];
}
function computeGradientColors(size, gradient) {
  const { knots } = gradient;
  const n = knots.length;
  const pixels = new Uint8ClampedArray(size * 4);
  if (n > 0) {
    let getColor2 = function(index2) {
      const [r, g, b, a] = knots[index2].color;
      return vec4_exports.fromValues(r, g, b, a ?? 1);
    };
    var getColor = getColor2;
    const minValue = knots[0].position;
    const maxValue = knots[n - 1].position;
    let prevIndex = 0;
    const color = getColor2(0);
    for (let i = 0; i < size; i++) {
      const texel = (i + 0.5) / size * (maxValue - minValue) + minValue;
      for (let j = prevIndex; j < n - 1; j++) {
        prevIndex = j;
        const e0 = knots[j].position;
        const e1 = knots[j + 1].position;
        const c0 = getColor2(j);
        const c1 = getColor2(j + 1);
        if (texel >= e0 && texel < e1) {
          const t = (texel - e0) / (e1 - e0);
          vec4_exports.lerp(color, c0, c1, t);
          break;
        }
      }
      const [r, g, b, a] = color;
      pixels[i * 4 + 0] = r * 255;
      pixels[i * 4 + 1] = g * 255;
      pixels[i * 4 + 2] = b * 255;
      pixels[i * 4 + 3] = a * 255;
    }
  }
  return pixels;
}

// /projects/Novorender/ts/dist/core3d/modules/octree/context.ts
var OctreeModuleContext = class {
  constructor(renderContext, module, uniforms, resources, buffer, loader) {
    this.renderContext = renderContext;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
    this.loader = loader;
    this.highlight = {
      buffer,
      indices: new Uint8Array(buffer, 4),
      mutex: new Mutex(buffer)
    };
  }
  gradientsImage = new Uint8ClampedArray(1024 /* size */ * 2 * 4);
  currentProgramFlags = OctreeModule.defaultProgramFlags;
  nextProgramFlags = OctreeModule.defaultProgramFlags;
  debug = false;
  suspendUpdates = false;
  localSpaceTranslation = vec3_exports.create();
  localSpaceChanged = false;
  url;
  // rootNode: OctreeNode | undefined;
  rootNodes = {};
  version = "";
  projectedSizeSplitThreshold = 1;
  // baseline node size split threshold = 50% of view height
  hidden = [false, false, false, false, false];
  highlight;
  highlightGeneration = 0;
  compiling = false;
  get highlights() {
    return this.highlight.indices;
  }
  update(state) {
    const { renderContext, resources, uniforms, projectedSizeSplitThreshold, module, currentProgramFlags } = this;
    const { gl, deviceProfile } = renderContext;
    const { scene, localSpaceTranslation, highlights, points, terrain, pick, output, clipping } = state;
    const { values } = uniforms.scene;
    let { nextProgramFlags } = this;
    const updateShaderCompileConstants = (flags) => {
      if (Object.getOwnPropertyNames(flags).some((key) => nextProgramFlags[key] != flags[key])) {
        this.nextProgramFlags = nextProgramFlags = { ...nextProgramFlags, ...flags };
      }
    };
    this.projectedSizeSplitThreshold = 1 / deviceProfile.detailBias;
    if (values.iblMipCount != renderContext.iblTextures.numMipMaps) {
      values.iblMipCount = renderContext.iblTextures.numMipMaps;
    }
    this.debug = state.debug.showNodeBounds;
    let updateGradients = false;
    if (renderContext.hasStateChanged({ points })) {
      const { size, deviation } = points;
      const { values: values2 } = uniforms.scene;
      values2.pixelSize = size.pixel ?? 0;
      values2.maxPixelSize = size.maxPixel ?? 20;
      values2.metricSize = size.metric ?? 0;
      values2.toleranceFactor = size.toleranceFactor ?? 0;
      values2.deviationIndex = deviation.index;
      values2.deviationFactor = deviation.mixFactor;
      values2.deviationUndefinedColor = deviation.undefinedColor ?? vec4_exports.fromValues(0, 0, 0, 0);
      values2.deviationRange = gradientRange(deviation.colorGradient);
      values2.useProjectedPosition = points.useProjectedPosition;
      const deviationColors = computeGradientColors(1024 /* size */, deviation.colorGradient);
      this.gradientsImage.set(deviationColors, 0 * 1024 /* size */ * 4);
      updateGradients = true;
    }
    if (renderContext.hasStateChanged({ terrain })) {
      const { values: values2 } = uniforms.scene;
      values2.elevationRange = gradientRange(terrain.elevationGradient);
      const elevationColors = computeGradientColors(1024 /* size */, terrain.elevationGradient);
      this.gradientsImage.set(elevationColors, 1 * 1024 /* size */ * 4);
      updateGradients = true;
    }
    if (renderContext.hasStateChanged({ pick })) {
      const { values: values2 } = uniforms.scene;
      values2.pickOpacityThreshold = pick.opacityThreshold;
    }
    if (updateGradients) {
      glUpdateTexture(gl, resources.gradientsTexture, { ...module.gradientImageParams, image: this.gradientsImage });
    }
    if (renderContext.hasStateChanged({ scene })) {
      const { prevState } = renderContext;
      if (scene) {
        const { hide } = scene;
        if (hide != prevState?.scene?.hide) {
          if (hide) {
            const { terrain: terrain2, triangles, lines, points: points2, documents } = hide;
            this.hidden = [terrain2 ?? false, triangles ?? false, lines ?? false, points2 ?? false, documents ?? false];
          } else {
            this.hidden = [true, false, false, false, false];
          }
        }
      }
      if (scene?.url != this.url) {
        if (this.url) {
          this.loader.abortAll();
        }
        for (const rootNode of Object.values(this.rootNodes)) {
          rootNode.dispose();
        }
        this.rootNodes = {};
        const url = scene?.url;
        if (url != this.url) {
          const { highlight } = this;
          const numObjects = scene?.config.numObjects ?? 0;
          const numBytes = numObjects + 4;
          if (highlight.buffer.byteLength != numBytes) {
            highlight.mutex.lockSpin();
            if (numBytes > highlight.buffer.byteLength) {
              highlight.buffer.grow(numBytes);
            }
            highlight.indices = new Uint8Array(highlight.buffer, 4, numObjects);
            updateHighlightBuffer(highlight.indices, state.highlights);
            this.highlightGeneration++;
            highlight.mutex.unlock();
          }
          this.url = url;
          if (url) {
            const materialData = makeMaterialAtlas(state);
            if (materialData) {
              glUpdateTexture(gl, resources.materialTexture, { kind: "TEXTURE_2D", width: 256, height: 1, internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image: materialData });
            }
          }
        }
        if (scene) {
          this.version = scene.config.version;
          this.reloadScene(scene);
        }
      }
    }
    const { rootNodes } = this;
    if (renderContext.hasStateChanged({ localSpaceTranslation })) {
      this.localSpaceChanged = localSpaceTranslation !== this.localSpaceTranslation;
      this.localSpaceTranslation = localSpaceTranslation;
    }
    if (renderContext.hasStateChanged({ highlights })) {
      const { groups } = highlights;
      const { highlight } = this;
      const { prevState } = renderContext;
      const prevGroups = prevState?.highlights.groups ?? [];
      updateShaderCompileConstants({ highlight: groups.length > 0 || highlights.defaultAction != void 0 });
      const { values: values2 } = uniforms.scene;
      values2.applyDefaultHighlight = highlights.defaultAction != void 0;
      if (scene) {
        const n = Math.max(groups.length, prevGroups.length);
        let reload = false;
        const prevDefaultAction = prevState?.highlights.defaultAction;
        const currDefaultAction = state.highlights.defaultAction;
        if (prevDefaultAction != currDefaultAction && (prevDefaultAction == "filter" || currDefaultAction == "filter")) {
          reload = true;
        } else {
          const filterGroups = new Set(prevGroups.filter((g) => g.action == "filter").map((g) => g.objectIds));
          for (const { action, objectIds: objectIds2 } of groups) {
            if (action == "filter") {
              var removed = filterGroups.delete(objectIds2);
              if (!removed) {
                reload = true;
                break;
              }
            }
          }
          if (filterGroups.size > 0) {
            reload = true;
          }
        }
        if (reload) {
          this.reloadScene(scene);
        }
      }
      const transforms2 = [highlights.defaultAction, ...groups.map((g) => g.action)];
      const prevTransforms = prevState ? [
        prevState.highlights.defaultAction,
        ...prevState.highlights.groups.map((g) => g.action)
      ] : [];
      if (!sequenceEqual(transforms2, prevTransforms)) {
        const image = createColorTransforms(highlights);
        glUpdateTexture(gl, resources.highlightTexture, { kind: "TEXTURE_2D", width: 256, height: 6, internalFormat: "RGBA32F", type: "FLOAT", image });
      }
      const objectIds = groups.map((g) => g.objectIds);
      const prevObjectIds = prevState?.highlights.groups.map((g) => g.objectIds) ?? [];
      const objectIdsChanged = !sequenceEqual(objectIds, prevObjectIds);
      const actions = groups.map((g) => typeof g.action == "string" ? g.action : void 0);
      const prevActions = prevState?.highlights.groups.map((g) => typeof g.action == "string" ? g.action : void 0) ?? [];
      const actionsChanged = highlights.defaultAction != prevState?.highlights.defaultAction || !sequenceEqual(actions, prevActions);
      if (objectIdsChanged || actionsChanged) {
        highlight.mutex.lockSpin();
        updateHighlightBuffer(highlight.indices, highlights);
        this.highlightGeneration++;
        highlight.mutex.unlock();
        const nodes = [];
        for (const rootNode of Object.values(rootNodes)) {
          nodes.push(...iterateNodes(rootNode));
        }
        for (const node of nodes) {
          node.applyHighlights(highlight.indices);
        }
      }
      ;
    }
    if (renderContext.hasStateChanged({ clipping })) {
      updateShaderCompileConstants({ clip: clipping.enabled });
    }
    if (renderContext.hasStateChanged({ output })) {
      updateShaderCompileConstants({ dither: output.samplesMSAA <= 1 });
    }
    renderContext.updateUniformBuffer(resources.sceneUniforms, uniforms.scene);
    if (currentProgramFlags != nextProgramFlags && !this.compiling) {
      this.compiling = true;
      const recompile = async () => {
        const programs = await OctreeModule.compileShaders(renderContext, resources.bin, nextProgramFlags);
        Object.assign(resources.programs, programs);
        renderContext.changed = true;
        this.compiling = false;
        this.currentProgramFlags = nextProgramFlags;
      };
      recompile();
    }
    if (!this.suspendUpdates) {
      const nodes = [];
      for (const rootNode of Object.values(rootNodes)) {
        rootNode.update(state);
        const preCollapseNodes = [...iterateNodes(rootNode)];
        for (const node of preCollapseNodes) {
          if (!node.shouldSplit(projectedSizeSplitThreshold * 0.98)) {
            if (node.state != 0 /* collapsed */) {
              node.dispose();
            }
          }
        }
        nodes.push(...iterateNodes(rootNode));
      }
      nodes.sort((a, b) => b.projectedSize - a.projectedSize);
      const { maxGPUBytes } = deviceProfile.limits;
      const { maxPrimitives } = deviceProfile.limits;
      let gpuBytes = 0;
      let primitives = 0;
      for (const node of nodes) {
        if (node.hasGeometry) {
          gpuBytes += node.data.gpuBytes;
          primitives += node.renderedPrimitives;
        }
        if (node.state == 1 /* requestDownload */ || node.state == 2 /* downloading */) {
          primitives += node.data.primitivesDelta;
          gpuBytes += node.data.gpuBytes;
        }
      }
      for (const node of nodes) {
        if (node.shouldSplit(projectedSizeSplitThreshold)) {
          if (node.state == 0 /* collapsed */) {
            if (primitives + node.data.primitivesDelta <= maxPrimitives && gpuBytes + node.data.gpuBytes <= maxGPUBytes) {
              node.state = 1 /* requestDownload */;
              primitives += node.data.primitivesDelta;
              gpuBytes += node.data.gpuBytes;
            }
          }
        }
      }
      renderContext.addLoadStatistics(primitives);
      const maxDownloads = 8;
      let availableDownloads = maxDownloads - this.loader.activeDownloads;
      for (const node of nodes) {
        if (availableDownloads > 0 && node.state == 1 /* requestDownload */) {
          node.downloadNode();
          availableDownloads--;
        }
      }
    }
  }
  applyDefaultAttributeValues() {
    const { gl } = this.renderContext;
    gl.vertexAttribI4ui(2 /* material */, 255, 0, 0, 0);
    gl.vertexAttribI4ui(3 /* objectId */, 4294967295, 0, 0, 0);
    gl.vertexAttrib4f(5 /* color0 */, 0, 0, 0, 0);
    gl.vertexAttrib4f(6 /* projectedPos */, 0, 0, 0, 0);
    gl.vertexAttrib4f(7 /* deviations */, 0, 0, 0, 0);
    gl.vertexAttribI4ui(8 /* highlight */, 0, 0, 0, 0);
  }
  getRenderNodes(projectedSizeSplitThreshold, rootNode) {
    const nodes = [];
    function iterate(node) {
      let rendered = false;
      if (node.visibility != 1 /* none */) {
        let mask = node.data.childMask;
        if (node.shouldSplit(projectedSizeSplitThreshold)) {
          for (const child of node.children) {
            if (child.hasGeometry) {
              rendered = true;
              if (iterate(child)) {
                mask &= ~(1 << child.data.childIndex);
              }
            }
          }
        }
        rendered = true;
        nodes.push({ mask, node });
      }
      return rendered;
    }
    if (rootNode) {
      iterate(rootNode);
      nodes.sort((a, b) => a.node.viewDistance - b.node.viewDistance);
    }
    return nodes;
  }
  prepass(state) {
    const { resources, renderContext } = this;
    const { programs } = resources;
    const { gl } = renderContext;
    for (const rootNode of Object.values(this.rootNodes)) {
      const renderNodes = this.getRenderNodes(this.projectedSizeSplitThreshold / state.quality.detail, rootNode);
      glState(gl, {
        program: programs.pre,
        depth: { test: true }
      });
      gl.activeTexture(gl.TEXTURE0);
      const meshState = {};
      for (const { mask, node } of renderNodes) {
        this.renderNode(node, mask, meshState, 2 /* pre */);
      }
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
  }
  render(state) {
    const { resources, renderContext, debug } = this;
    const { usePrepass, samplerSingle, samplerMip } = renderContext;
    const { programs, sceneUniforms, samplerNearest, materialTexture, highlightTexture, gradientsTexture } = resources;
    const { gl, iblTextures, cameraUniforms, clippingUniforms, outlineUniforms, deviceProfile } = renderContext;
    const { diffuse, specular } = iblTextures;
    glState(gl, {
      program: programs.color,
      uniformBuffers: [cameraUniforms, clippingUniforms, sceneUniforms, null],
      cull: { enable: true },
      depth: {
        test: true,
        writeMask: true,
        func: usePrepass ? "LEQUAL" : "LESS"
      },
      textures: [
        { kind: "TEXTURE_2D", texture: null, sampler: samplerSingle },
        // basecolor - will be overridden by nodes that have textures, e.g. terrain nodes.
        { kind: "TEXTURE_CUBE_MAP", texture: diffuse, sampler: samplerNearest },
        { kind: "TEXTURE_CUBE_MAP", texture: specular, sampler: samplerMip },
        { kind: "TEXTURE_2D", texture: materialTexture, sampler: samplerNearest },
        { kind: "TEXTURE_2D", texture: highlightTexture, sampler: samplerNearest },
        { kind: "TEXTURE_2D", texture: gradientsTexture, sampler: samplerNearest }
      ]
    });
    this.applyDefaultAttributeValues();
    gl.activeTexture(gl.TEXTURE0);
    for (const rootNode of Object.values(this.rootNodes)) {
      const renderNodes = this.getRenderNodes(this.projectedSizeSplitThreshold / state.quality.detail, rootNode);
      const meshState = {};
      for (const { mask, node } of renderNodes) {
        this.renderNode(node, mask, meshState, 0 /* color */);
      }
      if (rootNode.geometryKind == 0 /* terrain */ && state.terrain.asBackground) {
        glClear(gl, { kind: "DEPTH_STENCIL", depth: 1, stencil: 0 });
      }
    }
    gl.bindTexture(gl.TEXTURE_2D, null);
    if (deviceProfile.features.outline && state.outlines.on) {
      const renderOutlines = (plane, color, planeIndex = -1) => {
        const [x, y, z, offset] = plane;
        const p = vec4_exports.fromValues(x, y, z, -offset);
        renderContext.updateOutlinesUniforms(p, color, planeIndex);
        glState(gl, {
          uniformBuffers: [cameraUniforms, clippingUniforms, outlineUniforms, null],
          depth: {
            test: false,
            writeMask: false
          }
        });
        const renderNodes = this.getRenderNodes(this.projectedSizeSplitThreshold / state.quality.detail, this.rootNodes[1 /* triangles */]);
        for (const { mask, node } of renderNodes) {
          if (node.intersectsPlane(p)) {
            this.renderNodeClippingOutline(node, mask);
          }
        }
      };
      if (state.outlines.enabled) {
        renderOutlines(state.outlines.plane, state.outlines.color);
      }
      if (state.clipping.enabled) {
        for (let i = 0; i < state.clipping.planes.length; ++i) {
          const { normalOffset, outline } = state.clipping.planes[i];
          if (outline?.enabled) {
            renderOutlines(normalOffset, outline.color ?? state.outlines.color, i);
          }
        }
      }
    }
    if (debug) {
      for (const rootNode of Object.values(this.rootNodes)) {
        const renderNodes = this.getRenderNodes(this.projectedSizeSplitThreshold / state.quality.detail, rootNode);
        glState(gl, {
          program: programs.debug,
          uniformBuffers: [cameraUniforms, clippingUniforms, sceneUniforms, null],
          depth: {
            test: true,
            writeMask: false,
            func: "GREATER"
          },
          cull: { enable: true },
          blend: {
            enable: true,
            srcRGB: "CONSTANT_ALPHA",
            dstRGB: "ONE_MINUS_CONSTANT_ALPHA",
            color: [0, 0, 0, 0.25]
          }
        });
        for (const { mask, node } of renderNodes) {
          this.renderNodeDebug(node);
        }
        glState(gl, {
          program: programs.debug,
          depth: { func: "LESS" },
          blend: {
            color: [0, 0, 0, 0.75]
          }
        });
        for (const { mask, node } of renderNodes) {
          this.renderNodeDebug(node);
        }
      }
    }
  }
  pick() {
    const { resources, renderContext } = this;
    const { gl, cameraUniforms, clippingUniforms, outlineUniforms, samplerSingle, samplerMip, iblTextures, currentState, deviceProfile } = renderContext;
    const { programs, sceneUniforms, samplerNearest, materialTexture, highlightTexture, gradientsTexture } = resources;
    const { diffuse, specular } = iblTextures;
    const state = currentState;
    for (const rootNode of Object.values(this.rootNodes)) {
      const renderNodes = this.getRenderNodes(this.projectedSizeSplitThreshold / state.quality.detail, rootNode);
      glState(gl, {
        program: programs.pick,
        uniformBuffers: [cameraUniforms, clippingUniforms, sceneUniforms, null],
        cull: { enable: true },
        depth: { test: true, writeMask: true },
        textures: [
          { kind: "TEXTURE_2D", texture: null, sampler: samplerSingle },
          // basecolor - will be overridden by nodes that have textures, e.g. terrain nodes.
          { kind: "TEXTURE_CUBE_MAP", texture: diffuse, sampler: samplerNearest },
          { kind: "TEXTURE_CUBE_MAP", texture: specular, sampler: samplerMip },
          { kind: "TEXTURE_2D", texture: materialTexture, sampler: samplerNearest },
          { kind: "TEXTURE_2D", texture: highlightTexture, sampler: samplerNearest },
          { kind: "TEXTURE_2D", texture: gradientsTexture, sampler: samplerNearest }
        ]
      });
      this.applyDefaultAttributeValues();
      gl.activeTexture(gl.TEXTURE0);
      const meshState = {};
      for (const { mask, node } of renderNodes) {
        this.renderNode(node, mask, meshState, 1 /* pick */);
      }
      gl.bindTexture(gl.TEXTURE_2D, null);
      if (deviceProfile.features.outline && state.outlines.on) {
        const renderOutlines = (plane, color, planeIndex = -1) => {
          const [x, y, z, offset] = plane;
          const p = vec4_exports.fromValues(x, y, z, -offset);
          renderContext.updateOutlinesUniforms(p, color, planeIndex);
          glState(gl, {
            uniformBuffers: [cameraUniforms, clippingUniforms, outlineUniforms, null],
            depth: {
              test: false,
              writeMask: false
            }
          });
          for (const { mask, node } of renderNodes) {
            if (node.intersectsPlane(p)) {
              this.renderNodeClippingOutline(node, mask);
            }
          }
        };
        if (state.outlines.enabled) {
          renderOutlines(state.outlines.plane, state.outlines.color);
        }
        if (state.clipping.enabled) {
          for (let i = 0; i < state.clipping.planes.length; ++i) {
            const { normalOffset, outline } = state.clipping.planes[i];
            if (outline?.enabled) {
              renderOutlines(normalOffset, outline.color ?? state.outlines.color, i);
            }
          }
        }
      }
      if (rootNode.geometryKind == 0 /* terrain */ && state.terrain.asBackground) {
        glClear(gl, { kind: "DEPTH_STENCIL", depth: 1, stencil: 0 });
      }
    }
  }
  renderNode(node, mask, meshState, pass) {
    const { renderContext } = this;
    const { gl } = renderContext;
    const { resources } = this;
    const { programs } = resources;
    const { data } = node;
    const prepass = pass == 2 /* pre */;
    if (node.uniforms) {
      gl.bindBufferBase(gl.UNIFORM_BUFFER, 3 /* node */, node.uniforms);
      for (const mesh of node.meshes) {
        const { materialType } = mesh;
        const isTransparent = materialType == 2 /* transparent */;
        if (prepass && isTransparent)
          continue;
        gl.bindVertexArray(prepass ? mesh.vaoPosOnly : mesh.vao);
        const mode = mesh.materialType == 3 /* elevation */ ? 2 /* terrain */ : mesh.drawParams.mode == "POINTS" ? 1 /* points */ : 0 /* triangles */;
        if (meshState.mode != mode) {
          meshState.mode = mode;
          gl.useProgram(programs[pass][mode]);
        }
        const doubleSided = mesh.materialType != 0 /* opaque */;
        if (meshState.doubleSided != doubleSided) {
          meshState.doubleSided = doubleSided;
          if (doubleSided) {
            gl.disable(gl.CULL_FACE);
          } else {
            gl.enable(gl.CULL_FACE);
          }
        }
        if (pass == 0 /* color */ || pass == 1 /* pick */) {
          gl.bindTexture(gl.TEXTURE_2D, mesh.baseColorTexture ?? resources.defaultBaseColorTexture);
        }
        if (mask == data.childMask) {
          const stats = glDraw(gl, mesh.drawParams);
          renderContext.addRenderStatistics(stats);
        } else {
          const multiDrawParams = getMultiDrawParams(mesh, mask);
          if (multiDrawParams) {
            const stats = glDraw(gl, multiDrawParams);
            renderContext.addRenderStatistics(stats);
          }
        }
      }
    }
  }
  renderNodeClippingOutline(node, mask) {
    const { resources, renderContext, module } = this;
    const { gl } = renderContext;
    const { programs, transformFeedback, vb_line, vao_line } = resources;
    if (mask && node.uniforms) {
      gl.bindBufferBase(gl.UNIFORM_BUFFER, 3 /* node */, node.uniforms);
      for (const mesh of node.meshes) {
        if (mesh.numTriangles && mesh.drawParams.mode == "TRIANGLES" && !mesh.baseColorTexture) {
          for (const drawRange of mesh.drawRanges) {
            if (1 << drawRange.childIndex & mask) {
              const count = drawRange.count / 3;
              const first = drawRange.first / 3;
              console.assert(count * 2 <= module.maxLines);
              glState(gl, {
                program: programs.intersect,
                vertexArrayObject: mesh.vaoTriangles
              });
              glTransformFeedback(gl, { kind: "POINTS", transformFeedback, outputBuffers: [vb_line], count, first });
              glState(gl, {
                program: programs.line,
                vertexArrayObject: vao_line
              });
              const stats = glDraw(gl, { kind: "arrays_instanced", mode: "LINES", count: 2, instanceCount: count });
              renderContext.addRenderStatistics(stats);
            }
          }
        }
      }
    }
  }
  renderNodeDebug(node) {
    const { renderContext } = this;
    const { gl } = renderContext;
    if (node.renderedChildMask && node.uniforms) {
      gl.bindBufferBase(gl.UNIFORM_BUFFER, 3 /* node */, node.uniforms ?? null);
      const stats = glDraw(gl, { kind: "arrays", mode: "TRIANGLES", count: 8 * 12 });
      renderContext.addRenderStatistics(stats);
    }
  }
  contextLost() {
    const { loader, rootNodes } = this;
    loader.abortAll();
    for (const rootNode of Object.values(rootNodes)) {
      rootNode?.dispose();
    }
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
    this.rootNodes = {};
  }
  async reloadScene(scene) {
    this.suspendUpdates = true;
    await this.loader.abortAllPromise;
    const rootNodes = await createSceneRootNodes(this, scene.config, this.renderContext.deviceProfile);
    if (rootNodes) {
      this.rootNodes = rootNodes;
    }
    this.suspendUpdates = false;
    this.renderContext.changed = true;
  }
};
function makeMaterialAtlas(state) {
  const { scene } = state;
  if (scene) {
    const { config } = scene;
    const { numMaterials } = config;
    if (numMaterials) {
      let zeroes2 = function() {
        return new Uint8ClampedArray(numMaterials);
      }, ones2 = function() {
        const a = new Uint8ClampedArray(numMaterials);
        a.fill(255);
        return a;
      };
      var zeroes = zeroes2, ones = ones2;
      const { diffuse, opacity } = config.materialProperties;
      console.assert(numMaterials <= 256);
      ;
      ;
      const red = decodeBase64(diffuse.red, Uint8ClampedArray) ?? zeroes2();
      const green = decodeBase64(diffuse.green, Uint8ClampedArray) ?? zeroes2();
      const blue = decodeBase64(diffuse.blue, Uint8ClampedArray) ?? zeroes2();
      const alpha = decodeBase64(opacity, Uint8ClampedArray) ?? ones2();
      const srcData = interleaveRGBA(red, green, blue, alpha);
      return srcData;
    }
  }
}
function updateHighlightBuffer(buffer, highlight) {
  const { defaultAction, groups } = highlight;
  function getIndex(action, value) {
    return action == "hide" ? 254 /* hidden */ : action == "filter" ? 255 /* filtered */ : value;
  }
  const defaultValue = getIndex(defaultAction, 0 /* default */);
  buffer.fill(defaultValue);
  let groupIndex = 1;
  for (const group of groups) {
    const idx = getIndex(group.action, groupIndex);
    for (const objectId of group.objectIds) {
      buffer[objectId] = idx;
    }
    groupIndex++;
  }
}
function* iterateNodes(node) {
  if (node) {
    yield node;
    for (const child of node.children) {
      yield* iterateNodes(child);
    }
  }
}
function createColorTransforms(highlights) {
  const numColorMatrices = 256;
  const numColorMatrixCols = 6;
  const numColorMatrixRows = 4;
  const colorMatrices = new Float32Array(numColorMatrices * numColorMatrixRows * numColorMatrixCols);
  for (let i = 0; i < numColorMatrices; i++) {
    for (let j = 0; j < numColorMatrixCols; j++) {
      colorMatrices[(numColorMatrices * j + i) * 4 + j] = i == j ? 1 : 0;
    }
  }
  function copyMatrix(index2, rgbaTransform, outlineColor) {
    for (let col2 = 0; col2 < 5; col2++) {
      for (let row = 0; row < numColorMatrixRows; row++) {
        colorMatrices[(numColorMatrices * col2 + index2) * 4 + row] = rgbaTransform[col2 + row * 5];
      }
    }
    const col = numColorMatrixCols - 1;
    const rgba = outlineColor ? [...outlineColor, 1] : [0, 0, 0, 0];
    for (let row = 0; row < numColorMatrixRows; row++) {
      colorMatrices[(numColorMatrices * col + index2) * 4 + row] = rgba[row];
    }
  }
  const { defaultAction, groups } = highlights;
  copyMatrix(0, getRGBATransform(defaultAction));
  for (let i = 0; i < groups.length; i++) {
    copyMatrix(i + 1, getRGBATransform(groups[i].action), groups[i].outlineColor);
  }
  return colorMatrices;
}
function interleaveRGBA(r, g, b, a) {
  const n = r.length;
  console.assert(n == g.length && n == b.length && n == a.length);
  const rgba = new Uint8ClampedArray(256 * 4);
  let j = 0;
  for (let i = 0; i < n; i++) {
    rgba[j++] = r[i];
    rgba[j++] = g[i];
    rgba[j++] = b[i];
    rgba[j++] = a[i];
  }
  return rgba;
}
function sequenceEqual(a, b) {
  if (a.length != b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] != b[i]) {
      return false;
    }
  }
  return true;
}
var defaultRGBATransform = [
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0
];
function getRGBATransform(action) {
  return typeof action != "string" && Array.isArray(action) ? action : defaultRGBATransform;
}

// /projects/Novorender/ts/dist/core3d/modules/octree/module.ts
var OctreeModule = class _OctreeModule {
  kind = "octree";
  sceneUniforms = {
    applyDefaultHighlight: "bool",
    iblMipCount: "float",
    pixelSize: "float",
    maxPixelSize: "float",
    metricSize: "float",
    toleranceFactor: "float",
    deviationIndex: "int",
    deviationFactor: "float",
    deviationRange: "vec2",
    deviationUndefinedColor: "vec4",
    useProjectedPosition: "bool",
    elevationRange: "vec2",
    pickOpacityThreshold: "float"
  };
  gradientImageParams = { kind: "TEXTURE_2D", width: 1024 /* size */, height: 2, internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image: null };
  maxHighlights = 8;
  static textureNames = ["base_color", "ibl.diffuse", "ibl.specular", "materials", "highlights", "gradients"];
  static textureUniforms = _OctreeModule.textureNames.map((name) => `textures.${name}`);
  static uniformBufferBlocks = ["Camera", "Clipping", "Scene", "Node"];
  static passes = [0 /* color */, 1 /* pick */, 2 /* pre */];
  static modes = [0 /* triangles */, 1 /* points */, 2 /* terrain */];
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    const loader = new NodeLoader(context.imports.loaderWorker);
    const maxObjects = 1e7;
    const maxByteLength = maxObjects + 4;
    const buffer = new SharedArrayBuffer(maxByteLength);
    await loader.init(buffer, context.imports.parserWasm);
    return new OctreeModuleContext(context, this, uniforms, resources, buffer, loader);
  }
  createUniforms() {
    return {
      scene: glUBOProxy(this.sceneUniforms)
    };
  }
  async createResources(context, uniforms) {
    const shaders = context.imports.shaders.octree;
    const bin = context.resourceBin("Watermark");
    const sceneUniforms = bin.createBuffer({ kind: "UNIFORM_BUFFER", srcData: uniforms.scene.buffer });
    const samplerNearest = bin.createSampler({ minificationFilter: "NEAREST", magnificationFilter: "NEAREST", wrap: ["CLAMP_TO_EDGE", "CLAMP_TO_EDGE"] });
    const defaultBaseColorTexture = bin.createTexture({ kind: "TEXTURE_2D", width: 1, height: 1, internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image: new Uint8Array([255, 255, 255, 255]) });
    const materialTexture = bin.createTexture({ kind: "TEXTURE_2D", width: 256, height: 1, internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image: null });
    const highlightTexture = bin.createTexture({ kind: "TEXTURE_2D", width: 256, height: 6, internalFormat: "RGBA32F", type: "FLOAT", image: null });
    const gradientsTexture = bin.createTexture(this.gradientImageParams);
    const transformFeedback = bin.createTransformFeedback();
    let vb_line = null;
    let vao_line = null;
    if (context.deviceProfile.features.outline) {
      vb_line = bin.createBuffer({ kind: "ARRAY_BUFFER", byteSize: this.maxLines * 24, usage: "STATIC_DRAW" });
      vao_line = bin.createVertexArray({
        attributes: [
          { kind: "FLOAT_VEC4", buffer: vb_line, byteStride: 36, byteOffset: 0, componentType: "FLOAT", divisor: 1 },
          // positions in plane space (line vertex pair)
          { kind: "FLOAT_VEC4", buffer: vb_line, byteStride: 36, byteOffset: 16, componentType: "FLOAT", divisor: 1 },
          // color
          { kind: "UNSIGNED_INT", buffer: vb_line, byteStride: 36, byteOffset: 32, componentType: "UNSIGNED_INT", divisor: 1 }
          // object_id
        ]
      });
    }
    const { textureUniforms, uniformBufferBlocks } = _OctreeModule;
    const shadersPromise = _OctreeModule.compileShaders(context, bin);
    const [
      /*color, pick, pre,*/
      intersect,
      line,
      debug,
      corePrograms
    ] = await Promise.all([
      // context.makeProgramAsync(bin, { ...shaders.render, uniformBufferBlocks, textureUniforms, header: OctreeModule.shaderConstants(ShaderPass.color, ShaderMode.triangles) }),
      // context.makeProgramAsync(bin, { ...shaders.render, uniformBufferBlocks, textureUniforms, header: OctreeModule.shaderConstants(ShaderPass.pick, ShaderMode.triangles) }),
      // context.makeProgramAsync(bin, { ...shaders.render, uniformBufferBlocks, textureUniforms, header: OctreeModule.shaderConstants(ShaderPass.pre, ShaderMode.triangles) }),
      context.makeProgramAsync(bin, { ...shaders.intersect, uniformBufferBlocks: ["Camera", "Clipping", "Outline", "Node"], textureUniforms, transformFeedback: { varyings: ["line_vertices", "color", "object_id"], bufferMode: "INTERLEAVED_ATTRIBS" } }),
      context.makeProgramAsync(bin, { ...shaders.line, uniformBufferBlocks: ["Camera", "Clipping", "Outline", "Node"], header: { flags: context.deviceProfile.quirks.adreno600 ? ["ADRENO600"] : [] } }),
      context.makeProgramAsync(bin, { ...shaders.debug, uniformBufferBlocks }),
      shadersPromise
    ]);
    const programs = { ...corePrograms, intersect, line, debug };
    return {
      bin,
      programs,
      transformFeedback,
      vb_line,
      vao_line,
      sceneUniforms,
      samplerNearest,
      defaultBaseColorTexture,
      materialTexture,
      highlightTexture,
      gradientsTexture
    };
  }
  static defaultProgramFlags = {
    clip: false,
    dither: false,
    highlight: false
  };
  static shaderConstants(deviceProfile, pass, mode, programFlags = _OctreeModule.defaultProgramFlags) {
    const { clip, dither, highlight } = programFlags;
    const flags = [];
    if (clip || deviceProfile.quirks.slowShaderRecompile) {
      flags.push("CLIP");
    }
    if (dither) {
      flags.push("DITHER");
    }
    if (highlight) {
      flags.push("HIGHLIGHT");
    }
    if (deviceProfile.quirks.adreno600) {
      flags.push("ADRENO600");
    }
    const defines = [
      { name: "PASS", value: pass.toString() },
      { name: "MODE", value: mode.toString() }
    ];
    return { defines, flags };
  }
  static async compileShaders(context, bin, programFlags = _OctreeModule.defaultProgramFlags) {
    const shaders = context.imports.shaders.octree;
    const { textureUniforms, uniformBufferBlocks } = _OctreeModule;
    const programs = {};
    const promises = [];
    for (const pass of _OctreeModule.passes) {
      const modes = {};
      for (const mode of _OctreeModule.modes) {
        const promise = context.makeProgramAsync(bin, { ...shaders.render, uniformBufferBlocks, textureUniforms, header: _OctreeModule.shaderConstants(context.deviceProfile, pass, mode, programFlags) });
        const compiledPromise = promise.then((program) => {
          modes[mode] = program;
        });
        promises.push(compiledPromise);
      }
      programs[pass] = modes;
    }
    await Promise.all(promises);
    return programs;
  }
  maxLines = 1024 * 1024;
  // TODO: find a proper size!
};

// /projects/Novorender/ts/dist/core3d/modules/tonemap/index.ts
var TonemapModule = class {
  kind = "tonemap";
  uniforms = {
    exposure: "float",
    mode: "uint",
    maxLinearDepth: "float"
  };
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    return new TonemapModuleContext(context, this, uniforms, resources);
  }
  createUniforms() {
    return glUBOProxy(this.uniforms);
  }
  async createResources(context, uniformsProxy) {
    const { vertexShader, fragmentShader } = context.imports.shaders.tonemap.render;
    const bin = context.resourceBin("Tonemap");
    const uniforms = bin.createBuffer({ kind: "UNIFORM_BUFFER", byteSize: uniformsProxy.buffer.byteLength });
    const sampler = bin.createSampler({ minificationFilter: "NEAREST", magnificationFilter: "NEAREST", wrap: ["CLAMP_TO_EDGE", "CLAMP_TO_EDGE"] });
    const textureNames = ["color", "pick", "zbuffer"];
    const textureUniforms = textureNames.map((name) => `textures.${name}`);
    const program = await context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks: ["Tonemapping"], textureUniforms });
    return { bin, uniforms, sampler, program };
  }
};
var TonemapModuleContext = class {
  constructor(context, module, uniforms, resources) {
    this.context = context;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
  }
  update(state) {
    const { context } = this;
    const { uniforms } = this.resources;
    const { camera, tonemapping } = state;
    if (context.hasStateChanged({ camera, tonemapping })) {
      const { camera: camera2, tonemapping: tonemapping2 } = state;
      const { values } = this.uniforms;
      values.exposure = Math.pow(2, tonemapping2.exposure);
      values.mode = tonemapping2.mode;
      values.maxLinearDepth = camera2.far;
      context.updateUniformBuffer(uniforms, this.uniforms);
    }
  }
  render() {
    const { context, resources } = this;
    const { program, sampler, uniforms } = resources;
    const { gl } = context;
    const { textures } = context.buffers;
    context.buffers.resolveMSAA();
    glState(gl, {
      program,
      uniformBuffers: [uniforms],
      textures: [
        { kind: "TEXTURE_2D", texture: textures.color, sampler },
        { kind: "TEXTURE_2D", texture: textures.pick, sampler },
        { kind: "TEXTURE_2D", texture: textures.depth, sampler }
      ],
      frameBuffer: null,
      drawBuffers: ["BACK"],
      depth: {
        test: false,
        writeMask: false
      }
    });
    const stats = glDraw(gl, { kind: "arrays", mode: "TRIANGLE_STRIP", count: 4 });
    context.addRenderStatistics(stats);
  }
  contextLost() {
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
  }
};

// /projects/Novorender/ts/dist/core3d/modules/cube/index.ts
var CubeModule = class {
  kind = "cube";
  cubeUniforms = {
    modelLocalMatrix: "mat4"
  };
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    return new CubeModuleContext(context, this, uniforms, resources);
  }
  createUniforms() {
    return {
      cube: glUBOProxy(this.cubeUniforms)
    };
  }
  async createResources(context, uniformsProxy) {
    const shaders = context.imports.shaders.cube;
    const vertices = createVertices((pos2, norm, col) => [...pos2, ...norm, ...col]);
    const pos = createVertices((pos2) => pos2);
    const indices = createIndices();
    const triplets = new Float32Array(indices.length * 3);
    for (let i = 0; i < indices.length; i += 3) {
      const [a, b, c] = indices.slice(i, i + 3);
      const pa = pos.slice(a * 3, (a + 1) * 3);
      const pb = pos.slice(b * 3, (b + 1) * 3);
      const pc = pos.slice(c * 3, (c + 1) * 3);
      triplets.set(pa, i * 3 + 0);
      triplets.set(pb, i * 3 + 3);
      triplets.set(pc, i * 3 + 6);
    }
    const bin = context.resourceBin("Cube");
    const uniforms = {
      cube: bin.createBuffer({ kind: "UNIFORM_BUFFER", byteSize: uniformsProxy.cube.buffer.byteLength })
    };
    const transformFeedback = bin.createTransformFeedback();
    const vb_render = bin.createBuffer({ kind: "ARRAY_BUFFER", srcData: vertices });
    const ib_render = bin.createBuffer({ kind: "ELEMENT_ARRAY_BUFFER", srcData: indices });
    const vao_render = bin.createVertexArray({
      attributes: [
        { kind: "FLOAT_VEC3", buffer: vb_render, byteStride: 36, byteOffset: 0 },
        // position
        { kind: "FLOAT_VEC3", buffer: vb_render, byteStride: 36, byteOffset: 12 },
        // normal
        { kind: "FLOAT_VEC3", buffer: vb_render, byteStride: 36, byteOffset: 24 }
        // color
      ],
      indices: ib_render
    });
    bin.subordinate(vao_render, vb_render, ib_render);
    const vb_triplets = bin.createBuffer({ kind: "ARRAY_BUFFER", srcData: triplets });
    const vao_triplets = bin.createVertexArray({
      attributes: [
        { kind: "FLOAT_VEC3", buffer: vb_triplets, byteStride: 36, byteOffset: 0 },
        // position 0
        { kind: "FLOAT_VEC3", buffer: vb_triplets, byteStride: 36, byteOffset: 12 },
        // position 1
        { kind: "FLOAT_VEC3", buffer: vb_triplets, byteStride: 36, byteOffset: 24 }
        // position 2
      ]
    });
    bin.subordinate(vao_triplets, vb_triplets);
    const vb_line = bin.createBuffer({ kind: "ARRAY_BUFFER", byteSize: 12 * 2 * 4, usage: "STATIC_DRAW" });
    const vb_opacity = bin.createBuffer({ kind: "ARRAY_BUFFER", byteSize: 12 * 4, usage: "STATIC_DRAW" });
    const vao_line = bin.createVertexArray({
      attributes: [
        // { kind: "FLOAT_VEC2", buffer: vb_line, byteStride: 8, byteOffset: 0 }, // position
        // { kind: "FLOAT_VEC2", buffer: vb_line, byteStride: 4, byteOffset: 0, componentType: "HALF_FLOAT" }, // position
        { kind: "FLOAT_VEC4", buffer: vb_line, byteStride: 8, byteOffset: 0, componentType: "HALF_FLOAT", divisor: 1 },
        // position
        { kind: "FLOAT", buffer: vb_opacity, byteStride: 4, byteOffset: 0, componentType: "FLOAT", divisor: 1 }
        // opacity
      ]
    });
    const uniformBufferBlocks = ["Camera", "Clipping", "Cube"];
    const [color, pick, line, intersect] = await Promise.all([
      context.makeProgramAsync(bin, { ...shaders.render, uniformBufferBlocks }),
      context.makeProgramAsync(bin, { ...shaders.render, uniformBufferBlocks, header: { flags: ["PICK"] } }),
      context.makeProgramAsync(bin, { ...shaders.line, uniformBufferBlocks: [...uniformBufferBlocks, "Outline"] }),
      context.makeProgramAsync(bin, { ...shaders.intersect, uniformBufferBlocks: [...uniformBufferBlocks, "Outline"], transformFeedback: { varyings: ["line_vertices", "opacity"], bufferMode: "SEPARATE_ATTRIBS" } })
    ]);
    const programs = { color, pick, line, intersect };
    return { bin, uniforms, transformFeedback, vao_render, vao_triplets, vao_line, vb_line, vb_opacity, programs };
  }
};
var CubeModuleContext = class {
  constructor(context, module, uniforms, resources) {
    this.context = context;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
  }
  update(state) {
    const { context, resources, uniforms } = this;
    const { cube, localSpaceTranslation } = state;
    if (context.hasStateChanged({ cube, localSpaceTranslation })) {
      const { scale: scale7, position } = cube;
      const posLS = vec3_exports.subtract(vec3_exports.create(), position, localSpaceTranslation);
      const m = [
        scale7,
        0,
        0,
        0,
        0,
        scale7,
        0,
        0,
        0,
        0,
        scale7,
        0,
        ...posLS,
        1
      ];
      uniforms.cube.values.modelLocalMatrix = mat4_exports.fromValues(...m);
    }
    context.updateUniformBuffer(resources.uniforms.cube, uniforms.cube);
  }
  render(state) {
    const { context, resources } = this;
    const { programs, uniforms, transformFeedback, vao_render, vao_triplets, vao_line, vb_line, vb_opacity } = resources;
    const { gl, cameraUniforms, clippingUniforms, outlineUniforms, deviceProfile } = context;
    if (state.cube.enabled) {
      glState(gl, {
        program: programs.color,
        uniformBuffers: [cameraUniforms, clippingUniforms, uniforms.cube],
        // drawBuffers: context.drawBuffers(),
        depth: { test: true },
        cull: { enable: false },
        vertexArrayObject: vao_render
      });
      const stats = glDraw(gl, { kind: "elements", mode: "TRIANGLES", indexType: "UNSIGNED_SHORT", count: 36 });
      context.addRenderStatistics(stats);
      if (state.outlines.enabled && deviceProfile.features.outline) {
        const planeIndex = state.clipping.planes.findIndex((cp) => vec4_exports.exactEquals(cp.normalOffset, plane));
        const [x, y, z, offset] = state.outlines.plane;
        const plane = vec4_exports.fromValues(x, y, z, -offset);
        context.updateOutlinesUniforms(plane, state.outlines.color, planeIndex);
        glState(gl, {
          program: programs.intersect,
          uniformBuffers: [cameraUniforms, clippingUniforms, uniforms.cube, outlineUniforms],
          vertexArrayObject: vao_triplets
        });
        glTransformFeedback(gl, { kind: "POINTS", transformFeedback, outputBuffers: [vb_line, vb_opacity], count: 12 });
        glState(gl, {
          program: programs.line,
          // drawBuffers: context.drawBuffers(BufferFlags.color),
          blend: {
            enable: true,
            srcRGB: "SRC_ALPHA",
            dstRGB: "ONE_MINUS_SRC_ALPHA",
            srcAlpha: "ZERO",
            dstAlpha: "ONE"
          },
          depth: { test: false },
          vertexArrayObject: vao_line
        });
        const stats2 = glDraw(gl, { kind: "arrays_instanced", mode: "LINES", count: 2, instanceCount: 12 });
        context.addRenderStatistics(stats2);
      }
    }
  }
  pick(state) {
    const { context, resources } = this;
    const { programs, uniforms, vao_render } = resources;
    const { gl, cameraUniforms, clippingUniforms } = context;
    if (state.cube.enabled) {
      glState(gl, {
        program: programs.pick,
        uniformBuffers: [cameraUniforms, clippingUniforms, uniforms.cube],
        depth: { test: true },
        cull: { enable: false },
        vertexArrayObject: vao_render
      });
      glDraw(gl, { kind: "elements", mode: "TRIANGLES", indexType: "UNSIGNED_SHORT", count: 36 });
    }
  }
  contextLost() {
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
  }
};
function createVertices(pack) {
  function face(x, y, color) {
    const normal = vec3_exports.cross(vec3_exports.create(), y, x);
    function vert(fx, fy) {
      const pos = vec3_exports.clone(normal);
      vec3_exports[fx](pos, pos, x);
      vec3_exports[fy](pos, pos, y);
      return pack(pos, normal, color);
    }
    return [
      ...vert("sub", "sub"),
      ...vert("add", "sub"),
      ...vert("sub", "add"),
      ...vert("add", "add")
    ];
  }
  return new Float32Array([
    ...face([0, 0, -1], [0, 1, 0], [1, 0, 0]),
    // right (1, 0, 0)
    ...face([0, 0, 1], [0, 1, 0], [0, 1, 1]),
    // left (-1, 0, 0)
    ...face([1, 0, 0], [0, 0, 1], [0, 1, 0]),
    // top (0, 1, 0)
    ...face([1, 0, 0], [0, 0, -1], [1, 0, 1]),
    // bottom (0, -1, 0)
    ...face([1, 0, 0], [0, 1, 0], [0, 0, 1]),
    // front (0, 0, 1)
    ...face([-1, 0, 0], [0, 1, 0], [1, 1, 0])
    // back (0, 0, -1)
  ]);
}
function createIndices() {
  let idxOffset = 0;
  function face() {
    const idx = [0, 2, 1, 1, 2, 3].map((i) => i + idxOffset);
    idxOffset += 4;
    return idx;
  }
  return new Uint16Array([
    ...face(),
    ...face(),
    ...face(),
    ...face(),
    ...face(),
    ...face()
  ]);
}

// /projects/Novorender/ts/dist/core3d/modules/clipping/index.ts
var ClippingModule = class {
  kind = "clipping";
  uniforms = {
    "colors.0": "vec4",
    "colors.1": "vec4",
    "colors.2": "vec4",
    "colors.3": "vec4",
    "colors.4": "vec4",
    "colors.5": "vec4"
  };
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    return new ClippingModuleContext(context, this, uniforms, resources);
  }
  createUniforms() {
    return glUBOProxy(this.uniforms);
  }
  async createResources(context, uniformsProxy) {
    const { vertexShader, fragmentShader } = context.imports.shaders.clipping.render;
    const bin = context.resourceBin("Clipping");
    const uniforms = bin.createBuffer({ kind: "UNIFORM_BUFFER", byteSize: uniformsProxy.buffer.byteLength });
    const uniformBufferBlocks = ["Camera", "Clipping", "Colors"];
    const program = await context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks });
    return { bin, uniforms, program };
  }
};
var ClippingModuleContext = class {
  constructor(context, module, uniforms, resources) {
    this.context = context;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
  }
  update(state) {
    const { context, resources } = this;
    const { clipping } = state;
    if (context.hasStateChanged({ clipping })) {
      const { planes } = clipping;
      const values = this.uniforms.values;
      for (let i = 0; i < planes.length; i++) {
        const { color } = planes[i];
        const idx = i;
        values[`colors.${idx}`] = color ?? [0, 0, 0, 0];
      }
    }
    context.updateUniformBuffer(resources.uniforms, this.uniforms);
  }
  render(state) {
    const { context, resources } = this;
    const { program, uniforms } = resources;
    const { gl, cameraUniforms, clippingUniforms } = context;
    const { clipping } = state;
    if (clipping.draw) {
      glState(gl, {
        program,
        uniformBuffers: [cameraUniforms, clippingUniforms, uniforms],
        depth: {
          test: true
          // writeMask: true,
        },
        blend: {
          enable: true,
          srcRGB: "SRC_ALPHA",
          dstRGB: "ONE_MINUS_SRC_ALPHA",
          srcAlpha: "ZERO",
          dstAlpha: "ONE"
        }
      });
      const stats = glDraw(gl, { kind: "arrays", mode: "TRIANGLE_STRIP", count: 4 });
      context.addRenderStatistics(stats);
    }
  }
  pick(state) {
    return this.render(state);
  }
  contextLost() {
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
  }
};

// /projects/Novorender/ts/dist/core3d/modules/watermark/index.ts
var WatermarkModule = class _WatermarkModule {
  kind = "watermark";
  uniforms = {
    modelClipMatrix: "mat4",
    color: "vec4"
  };
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    return new WatermarkModuleContext(context, this, uniforms, resources);
  }
  createUniforms() {
    return glUBOProxy(this.uniforms);
  }
  async createResources(context, uniformsProxy) {
    const { vertexShader, fragmentShader } = context.imports.shaders.watermark.render;
    const bin = context.resourceBin("Watermark");
    const uniforms = bin.createBuffer({ kind: "UNIFORM_BUFFER", srcData: uniformsProxy.buffer });
    const { vertices, indices } = _WatermarkModule.geometry(context.imports.logo);
    const vb = bin.createBuffer({ kind: "ARRAY_BUFFER", srcData: vertices });
    const ib = bin.createBuffer({ kind: "ELEMENT_ARRAY_BUFFER", srcData: indices });
    const vao = bin.createVertexArray({
      attributes: [
        { kind: "FLOAT_VEC3", buffer: vb, byteStride: 12, byteOffset: 0 }
        // position
      ],
      indices: ib
    });
    bin.subordinate(vao, vb, ib);
    const program = await context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks: ["Watermark"] });
    return { bin, uniforms, vao, program };
  }
  // these magic numbers are the byte offsets and lengths from gltf bufferViews
  static vertexBufferBytes = 16620;
  static indexBufferBytes = 12276;
  static numIndices = this.indexBufferBytes / 2;
  // Logo data are comes from the binary buffer of an gltf file. It has positions and triangle indices only. Z-coordinate is used for antialiasing. Mesh has been tesselated such that each triangle lies in a single antialiasing slope, i.e. has vertices along one edge only.
  static geometry(logo) {
    const vertices = new Float32Array(logo, 0, _WatermarkModule.vertexBufferBytes / 4).slice();
    const indices = new Uint16Array(logo, _WatermarkModule.vertexBufferBytes, _WatermarkModule.numIndices).slice();
    return { vertices, indices };
  }
};
var WatermarkModuleContext = class {
  constructor(context, module, uniforms, resources) {
    this.context = context;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
  }
  update(state) {
    const { context, resources } = this;
    const { output } = state;
    6;
    if (context.hasStateChanged({ output })) {
      const { values } = this.uniforms;
      const padding = 1;
      const size = 0.2;
      const { width, height } = output;
      const w = 12.717909812927246 - 42313020094297826e-20;
      const h = 0.0024876839015632868 + 1.87906813621521;
      const e = 0.1;
      const d = Math.hypot(w, h);
      const diag = Math.hypot(width, height) * size;
      const sx = 2 * diag / d / width;
      const sy = 2 * diag / d / height;
      const sz = diag / d * e * 0.5 / h;
      const m = [
        sx,
        0,
        0,
        0,
        0,
        sy,
        0,
        0,
        0,
        0,
        sz,
        0,
        1 - padding * sx,
        -1 + padding * sy,
        sz * 0.5,
        1
      ];
      values.modelClipMatrix = m;
      values.color = [43 / 255, 46 / 255, 52 / 255, 0.5];
      context.updateUniformBuffer(resources.uniforms, this.uniforms);
    }
  }
  render() {
    const { context, resources, module } = this;
    const { program, uniforms, vao } = resources;
    const { gl } = context;
    glState(gl, {
      program,
      uniformBuffers: [uniforms],
      depth: { writeMask: false },
      cull: { enable: true },
      vertexArrayObject: vao,
      blend: {
        enable: true,
        srcRGB: "SRC_ALPHA",
        srcAlpha: "ONE",
        dstRGB: "ONE",
        dstAlpha: "ONE"
      }
    });
    const stats = glDraw(gl, { kind: "elements", mode: "TRIANGLES", indexType: "UNSIGNED_SHORT", count: WatermarkModule.numIndices });
    context.addRenderStatistics(stats);
  }
  contextLost() {
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
  }
};

// /projects/Novorender/ts/dist/core3d/modules/dynamic/index.ts
var DynamicModule = class {
  kind = "dynamic";
  materialUniforms = {
    baseColor: "vec4"
  };
  instanceUniforms = {
    modelViewMatrix: "mat4"
  };
  async withContext(context) {
    const resources = await this.createResources(context);
    return new DynamicModuleContext(context, this, resources);
  }
  async createResources(context) {
    const { vertexShader, fragmentShader } = context.imports.shaders.dynamic.render;
    const bin = context.resourceBin("Dynamic");
    const defaultSamplers = {
      mip: bin.createSampler({ magnificationFilter: "LINEAR", minificationFilter: "LINEAR_MIPMAP_LINEAR", wrap: ["REPEAT", "REPEAT"] }),
      plain: bin.createSampler({ magnificationFilter: "LINEAR", minificationFilter: "LINEAR", wrap: ["REPEAT", "REPEAT"] })
    };
    const defaultTexture = bin.createTexture({ kind: "TEXTURE_2D", width: 1, height: 1, internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image: new Uint8Array(4) });
    const uniformBufferBlocks = ["Camera", "Material", "Object"];
    const textureNames = ["lut_ggx", "ibl.diffuse", "ibl.specular", "base_color", "metallic_roughness", "normal", "emissive", "occlusion"];
    const textureUniforms = textureNames.map((name) => `textures.${name}`);
    const [unlit, ggx] = await Promise.all([
      context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks, textureUniforms, header: { flags: context.deviceProfile.quirks.adreno600 ? ["ADRENO600"] : [] } }),
      context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks, textureUniforms, header: { flags: context.deviceProfile.quirks.adreno600 ? ["ADRENO600", "PBR_METALLIC_ROUGHNESS"] : ["PBR_METALLIC_ROUGHNESS"] } })
    ]);
    const programs = { unlit, ggx };
    return { bin, defaultSamplers, defaultTexture, programs };
  }
};
var DynamicModuleContext = class {
  constructor(context, module, resources) {
    this.context = context;
    this.module = module;
    this.resources = resources;
    this.iblTextures = context.iblTextures;
  }
  iblTextures;
  buffers = /* @__PURE__ */ new Map();
  geometries = /* @__PURE__ */ new Map();
  objects = /* @__PURE__ */ new Map();
  materials = /* @__PURE__ */ new Map();
  images = /* @__PURE__ */ new Map();
  samplers = /* @__PURE__ */ new Map();
  update(state) {
    const { context, resources } = this;
    const { bin, defaultSamplers, defaultTexture, programs } = resources;
    const { dynamic, localSpaceTranslation } = state;
    if (context.hasStateChanged({ dynamic })) {
      function* getTextures(material) {
        const { baseColorTexture } = material;
        if (baseColorTexture)
          yield baseColorTexture.texture;
        if (material.kind == "ggx") {
          const { emissiveTexture, metallicRoughnessTexture, normalTexture, occlusionTexture } = material;
          if (emissiveTexture)
            yield emissiveTexture.texture;
          if (metallicRoughnessTexture)
            yield metallicRoughnessTexture.texture;
          if (normalTexture)
            yield normalTexture.texture;
          if (occlusionTexture)
            yield occlusionTexture.texture;
        }
      }
      const primitives = [...new Set(dynamic.objects.flatMap((o) => o.mesh.primitives))];
      const geometries = [...new Set(primitives.map((p) => p.geometry))];
      const materials = [...new Set(primitives.map((p) => p.material))];
      const textures = [...new Set(materials.flatMap((m) => [...getTextures(m)]))];
      const images = [...new Set(textures.map((t) => t.image))];
      const samplers = [...new Set(textures.map((t) => t.sampler).filter((s) => s))];
      const objects = [...new Set(dynamic.objects.map((o) => o))];
      const vertexBuffers = new Set(geometries.flatMap((g) => [...Object.values(g.attributes).map((a) => a.buffer).filter((b) => b)]));
      const indexBuffers = new Set(geometries.map((g) => typeof g.indices == "number" ? void 0 : g.indices).filter((b) => b));
      const numVertexBuffers = vertexBuffers.size;
      const buffers = [...vertexBuffers, ...indexBuffers];
      syncAssets(bin, buffers, this.buffers, (data, idx) => new BufferAsset(bin, idx < numVertexBuffers ? "ARRAY_BUFFER" : "ELEMENT_ARRAY_BUFFER", data));
      syncAssets(bin, images, this.images, (data) => new TextureAsset(bin, data));
      syncAssets(bin, samplers, this.samplers, (data) => new SamplerAsset(bin, data));
      syncAssets(bin, geometries, this.geometries, (data) => new GeometryAsset(bin, data, this.buffers));
      syncAssets(bin, objects, this.objects, (data) => new ObjectAsset(bin, context, data, state));
      syncAssets(bin, materials, this.materials, (data) => new MaterialAsset(bin, context, data, this.images, this.samplers, defaultTexture, defaultSamplers, programs[data.kind]));
    }
    if (context.hasStateChanged({ localSpaceTranslation })) {
      for (const instance of this.objects.values()) {
        instance.update(context, state);
      }
    }
    if (context.iblTextures != this.iblTextures) {
      this.iblTextures = context.iblTextures;
      for (const material of this.materials.values()) {
        material.update(context, defaultTexture);
      }
    }
  }
  render(state) {
    const { context } = this;
    const { gl, cameraUniforms } = context;
    glState(gl, {
      uniformBuffers: [cameraUniforms],
      depth: {
        test: true,
        writeMask: true
      }
    });
    const { objects, geometries, materials } = this;
    const meshes = [];
    let numPrimitives = 0;
    state.dynamic.objects.forEach((p) => {
      numPrimitives += p.mesh.primitives.length;
    });
    if (numPrimitives != geometries.size) {
      return;
    }
    for (const obj of state.dynamic.objects) {
      const objAsset = objects.get(obj);
      for (const primitive of obj.mesh.primitives) {
        const geometry = geometries.get(primitive.geometry);
        const material = materials.get(primitive.material);
        meshes.push({ material, geometry, object: objAsset });
      }
    }
    meshes.sort((a, b) => {
      let diff = a.material.index - b.material.index;
      if (diff == 0) {
        diff = a.object.index - b.object.index;
      }
      return diff;
    });
    gl.vertexAttrib4f(3, 1, 1, 1, 1);
    let currentMaterial = void 0;
    let currentObject = void 0;
    for (const { material, object, geometry } of meshes) {
      if (currentMaterial != material) {
        currentMaterial = material;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 1, material.uniformsBuffer);
        glState(gl, currentMaterial.stateParams);
      }
      if (currentObject != object) {
        currentObject = object;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, 2, object.uniformsBuffer);
      }
      gl.bindVertexArray(geometry.resources.vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, object.instancesBuffer);
      for (let i = 0; i < 4; i++) {
        const attrib = i + 6 /* matrix0 */;
        gl.vertexAttribPointer(attrib, 3, gl.FLOAT, false, 4 * 12, i * 12);
        gl.vertexAttribDivisor(attrib, 1);
        gl.enableVertexAttribArray(attrib);
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      const kind = `${geometry.drawParams.kind}_instanced`;
      const params = { ...geometry.drawParams, kind, instanceCount: object.numInstances };
      const stats = glDraw(gl, params);
      gl.bindVertexArray(null);
      context.addRenderStatistics(stats);
    }
    for (let i = 0; i < 4; i++) {
      const attrib = i + 6 /* matrix0 */;
      gl.disableVertexAttribArray(attrib);
    }
  }
  pick(state) {
    this.render(state);
  }
  contextLost() {
  }
  dispose() {
    const { resources, buffers, geometries, materials, objects } = this;
    const { bin, programs, defaultSamplers, defaultTexture } = resources;
    this.contextLost();
    const assets = [...buffers.values(), ...geometries.values(), ...materials.values(), ...objects.values()];
    for (const asset of assets) {
      asset.dispose(bin);
    }
    bin.delete(programs.unlit, programs.ggx, defaultSamplers.mip, defaultSamplers.plain, defaultTexture);
    console.assert(bin.size == 0);
    bin.dispose();
    buffers.clear();
    geometries.clear();
    materials.clear();
    objects.clear();
  }
};
function syncAssets(bin, uniqueResources, map, create7) {
  const unreferenced = new Map(map);
  for (const resource of uniqueResources) {
    unreferenced.delete(resource);
  }
  for (const [resource, asset] of unreferenced) {
    map.delete(resource);
    asset.dispose(bin);
  }
  let idx = 0;
  for (const resource of uniqueResources) {
    let asset = map.get(resource);
    if (!asset) {
      asset = create7(resource, idx);
      map.set(resource, asset);
    }
    asset.index = idx++;
  }
}
var BufferAsset = class {
  index = 0;
  buffer;
  constructor(bin, kind, srcData) {
    this.buffer = bin.createBuffer({ kind, srcData });
  }
  dispose(bin) {
    bin.delete(this.buffer);
  }
};
var GeometryAsset = class {
  index = 0;
  drawParams;
  resources;
  constructor(bin, data, buffers) {
    const hasIndexBuffer = typeof data.indices != "number";
    const indexType = !hasIndexBuffer ? void 0 : data.indices instanceof Uint32Array ? "UNSIGNED_INT" : data.indices instanceof Uint16Array ? "UNSIGNED_SHORT" : "UNSIGNED_BYTE";
    const mode = data.primitiveType;
    const count = hasIndexBuffer ? data.indices.length : data.indices;
    this.drawParams = { kind: hasIndexBuffer ? "elements" : "arrays", mode, count, indexType };
    const { position, normal, tangent, color0, texCoord0, texCoord1 } = data.attributes;
    function convAttr(a) {
      if (!a)
        return null;
      const { buffer } = buffers.get(a.buffer);
      return { ...a, buffer };
    }
    const indices = typeof data.indices == "number" ? void 0 : bin.createBuffer({ kind: "ELEMENT_ARRAY_BUFFER", srcData: data.indices });
    const params = {
      attributes: [
        convAttr(position),
        convAttr(normal),
        convAttr(tangent),
        convAttr(color0),
        convAttr(texCoord0),
        convAttr(texCoord1)
      ],
      indices
    };
    const vao = bin.createVertexArray(params);
    if (indices) {
      bin.subordinate(vao, indices);
    }
    this.resources = { vao };
  }
  dispose(bin) {
    bin.delete(this.resources.vao);
  }
};
var ObjectAsset = class _ObjectAsset {
  constructor(bin, context, data, state) {
    this.data = data;
    const uniformsDesc = {
      worldLocalMatrix: "mat4",
      baseObjectId: "uint"
    };
    this.uniforms = glUBOProxy(uniformsDesc);
    const { values } = this.uniforms;
    values.baseObjectId = data.baseObjectId ?? 4294967295;
    this.uniformsBuffer = bin.createBuffer({ kind: "UNIFORM_BUFFER", srcData: this.uniforms.buffer });
    const { instances } = data;
    this.numInstances = instances.length;
    this.instancesBuffer = _ObjectAsset.createInstancesBuffer(bin, instances, state.localSpaceTranslation);
    this.update(context, state);
  }
  index = 0;
  uniforms;
  numInstances;
  uniformsBuffer;
  instancesBuffer;
  static createInstancesBuffer(bin, instances, localSpaceTranslation) {
    const srcData = _ObjectAsset.computeInstanceMatrices(instances, localSpaceTranslation);
    return bin.createBuffer({ kind: "ARRAY_BUFFER", srcData });
  }
  static computeInstanceMatrices(instances, localSpaceTranslation) {
    const srcData = new Float32Array(instances.length * 12);
    for (let i = 0; i < instances.length; i++) {
      const { position, rotation, scale: scale7 } = instances[i];
      const translatedPos = vec3_exports.sub(vec3_exports.create(), position, localSpaceTranslation);
      const transform = rotation ? mat4_exports.fromRotationTranslation(mat4_exports.create(), rotation, translatedPos) : mat4_exports.fromTranslation(mat4_exports.create(), translatedPos);
      const [e00, e01, e02, e03, e10, e11, e12, e13, e20, e21, e22, e23, e30, e31, e32, e33] = transform;
      const elems4x3 = [e00, e01, e02, e10, e11, e12, e20, e21, e22, e30, e31, e32];
      if (scale7 != void 0) {
        for (let i2 = 0; i2 < 9; i2++) {
          elems4x3[i2] *= scale7;
        }
      }
      srcData.set(elems4x3, i * elems4x3.length);
    }
    return srcData;
  }
  update(context, state) {
    const { uniforms, uniformsBuffer, data, instancesBuffer } = this;
    const { localSpaceTranslation } = state;
    const { values } = uniforms;
    values.worldLocalMatrix = mat4_exports.fromTranslation(mat4_exports.create(), vec3_exports.negate(vec3_exports.create(), state.localSpaceTranslation));
    if (context.hasStateChanged({ localSpaceTranslation })) {
      const srcData = _ObjectAsset.computeInstanceMatrices(data.instances, localSpaceTranslation);
      glUpdateBuffer(context.gl, { kind: "ARRAY_BUFFER", srcData, targetBuffer: instancesBuffer });
    }
    context.updateUniformBuffer(uniformsBuffer, uniforms);
  }
  dispose(bin) {
    bin.delete(this.uniformsBuffer);
  }
};
var MaterialAsset = class {
  index = 0;
  kind;
  uniforms;
  stateParams;
  uniformsBuffer;
  textures = {};
  samplers = {};
  constructor(bin, context, data, textures, samplers, defaultTexture, defaultSamplers, program) {
    this.kind = data.kind;
    const blend = {
      enable: true,
      srcRGB: "SRC_ALPHA",
      dstRGB: "ONE_MINUS_SRC_ALPHA",
      srcAlpha: "ZERO",
      dstAlpha: "ONE"
    };
    this.stateParams = {
      program,
      cull: { enable: data.doubleSided ? false : true },
      blend: data.alphaMode == "BLEND" ? blend : void 0
      // drawBuffers: context.drawBuffers(data.alphaMode == "BLEND" ? BufferFlags.color : BufferFlags.all), // for devices without OES_draw_buffers_indexed support
    };
    const uniformsDesc = {
      baseColorFactor: "vec4",
      emissiveFactor: "vec3",
      roughnessFactor: "float",
      metallicFactor: "float",
      normalScale: "float",
      occlusionStrength: "float",
      alphaCutoff: "float",
      baseColorUVSet: "int",
      metallicRoughnessUVSet: "int",
      normalUVSet: "int",
      occlusionUVSet: "int",
      emissiveUVSet: "int",
      radianceMipCount: "uint"
    };
    const uniformsProxy = this.uniforms = glUBOProxy(uniformsDesc);
    let tex = this.textures;
    let samp = this.samplers;
    const { values } = uniformsProxy;
    const { baseColorTexture } = data;
    values.baseColorFactor = data.baseColorFactor ?? [1, 1, 1, 1];
    values.baseColorUVSet = data.baseColorTexture ? data.baseColorTexture.texCoord ?? 0 : -1;
    values.alphaCutoff = data.alphaCutoff ?? data.alphaMode == "MASK" ? 0.5 : 0;
    values.radianceMipCount = context.iblTextures.numMipMaps;
    function getDefaultSampler(texRef) {
      if (texRef) {
        return isImagePowerOfTwo(texRef.texture.image) ? defaultSamplers.mip : defaultSamplers.plain;
      }
    }
    if (baseColorTexture) {
      tex.baseColor = textures.get(baseColorTexture.texture.image).texture;
      samp.baseColor = samplers.get(baseColorTexture.texture.sampler)?.sampler ?? getDefaultSampler(baseColorTexture);
    }
    if (data.kind == "ggx") {
      const { roughnessFactor, metallicFactor, emissiveFactor, emissiveTexture, normalTexture, occlusionTexture, metallicRoughnessTexture } = data;
      values.roughnessFactor = roughnessFactor ?? 1;
      values.metallicFactor = metallicFactor ?? 1;
      values.emissiveFactor = emissiveFactor ?? [0, 0, 0];
      values.metallicRoughnessUVSet = metallicRoughnessTexture ? metallicRoughnessTexture.texCoord ?? 0 : -1;
      values.normalUVSet = normalTexture ? normalTexture.texCoord ?? 0 : -1;
      values.normalScale = normalTexture?.scale ?? 1;
      values.occlusionUVSet = occlusionTexture ? occlusionTexture.texCoord ?? 0 : -1;
      values.occlusionStrength = occlusionTexture?.strength ?? 1;
      values.emissiveUVSet = emissiveTexture ? emissiveTexture.texCoord ?? 0 : -1;
      if (emissiveTexture) {
        tex.emissive = textures.get(emissiveTexture.texture.image).texture;
        samp.emissive = samplers.get(emissiveTexture.texture.sampler)?.sampler ?? getDefaultSampler(emissiveTexture);
      }
      if (normalTexture) {
        tex.normal = textures.get(normalTexture.texture.image).texture;
        samp.normal = samplers.get(normalTexture.texture.sampler)?.sampler ?? getDefaultSampler(normalTexture);
      }
      if (occlusionTexture) {
        tex.occlusion = textures.get(occlusionTexture.texture.image).texture;
        samp.occlusion = samplers.get(occlusionTexture.texture.sampler)?.sampler ?? getDefaultSampler(occlusionTexture);
      }
      if (metallicRoughnessTexture) {
        tex.metallicRoughness = textures.get(metallicRoughnessTexture.texture.image).texture;
        samp.metallicRoughness = samplers.get(metallicRoughnessTexture.texture.sampler)?.sampler ?? getDefaultSampler(metallicRoughnessTexture);
      }
    } else {
      values.roughnessFactor = 1;
      values.metallicFactor = 1;
      values.emissiveFactor = [0, 0, 0];
      values.metallicRoughnessUVSet = -1;
      values.normalUVSet = -1;
      values.normalScale = 0;
      values.occlusionUVSet = -1;
      values.occlusionStrength = 0;
      values.emissiveUVSet = -1;
    }
    this.uniformsBuffer = bin.createBuffer({ kind: "UNIFORM_BUFFER", srcData: uniformsProxy.buffer });
    this.update(context, defaultTexture);
  }
  update(context, defaultTexture) {
    const { iblTextures, lut_ggx, samplerSingle, samplerMip } = context;
    const { uniforms, uniformsBuffer, textures, samplers } = this;
    const { diffuse, specular, numMipMaps } = iblTextures;
    const mutableState = this.stateParams;
    mutableState.textures = [
      { kind: "TEXTURE_2D", texture: lut_ggx, sampler: samplerSingle },
      { kind: "TEXTURE_CUBE_MAP", texture: diffuse, sampler: samplerSingle },
      { kind: "TEXTURE_CUBE_MAP", texture: specular, sampler: samplerMip },
      { kind: "TEXTURE_2D", texture: textures.baseColor ?? defaultTexture, sampler: samplers.baseColor ?? null },
      { kind: "TEXTURE_2D", texture: textures.metallicRoughness ?? defaultTexture, sampler: samplers.metallicRoughness ?? null },
      { kind: "TEXTURE_2D", texture: textures.normal ?? defaultTexture, sampler: samplers.normal ?? null },
      { kind: "TEXTURE_2D", texture: textures.emissive ?? defaultTexture, sampler: samplers.emissive ?? null },
      { kind: "TEXTURE_2D", texture: textures.occlusion ?? defaultTexture, sampler: samplers.occlusion ?? null }
    ];
    uniforms.values.radianceMipCount = numMipMaps;
    context.updateUniformBuffer(uniformsBuffer, uniforms);
  }
  dispose(bin) {
    bin.delete(this.uniformsBuffer);
  }
};
var TextureAsset = class {
  index = 0;
  texture;
  constructor(bin, image) {
    this.texture = bin.createTexture(image.params);
  }
  dispose(bin) {
    bin.delete(this.texture);
  }
};
var SamplerAsset = class {
  index = 0;
  sampler;
  constructor(bin, sampler) {
    this.sampler = bin.createSampler(sampler);
  }
  dispose(bin) {
    bin.delete(this.sampler);
  }
};
function isImagePowerOfTwo(image) {
  function isPowerOf23(value) {
    return (value & value - 1) == 0;
  }
  const { width, height } = image.params;
  return isPowerOf23(width) && isPowerOf23(height);
}

// /projects/Novorender/ts/dist/core3d/modules/toon_outline/index.ts
var ToonModule = class {
  kind = "toon_outline";
  uniforms = {
    color: "vec3"
  };
  async withContext(context) {
    const uniforms = this.createUniforms();
    const resources = await this.createResources(context, uniforms);
    return new ToonModuleContext(context, this, uniforms, resources);
  }
  createUniforms() {
    return glUBOProxy(this.uniforms);
  }
  async createResources(context, uniformsProxy) {
    const { vertexShader, fragmentShader } = context.imports.shaders.toon.render;
    const bin = context.resourceBin("Grid");
    const uniforms = bin.createBuffer({ kind: "UNIFORM_BUFFER", srcData: uniformsProxy.buffer });
    const sampler = bin.createSampler({ minificationFilter: "NEAREST", magnificationFilter: "NEAREST", wrap: ["CLAMP_TO_EDGE", "CLAMP_TO_EDGE"] });
    const textureNames = ["color", "pick", "zbuffer"];
    const textureUniforms = textureNames.map((name) => `textures.${name}`);
    const program = await context.makeProgramAsync(bin, { vertexShader, fragmentShader, uniformBufferBlocks: ["Camera"], textureUniforms });
    return { bin, uniforms, sampler, program };
  }
};
var ToonModuleContext = class {
  constructor(context, module, uniforms, resources) {
    this.context = context;
    this.module = module;
    this.uniforms = uniforms;
    this.resources = resources;
  }
  async update(state) {
    const { context, resources } = this;
    if (context.deviceProfile.quirks.adreno600) {
      return;
    }
    const { uniforms } = resources;
    const { toonOutline, localSpaceTranslation } = state;
    if (context.hasStateChanged({ toonOutline, localSpaceTranslation })) {
      const { values } = this.uniforms;
      values.color = toonOutline.color;
      context.updateUniformBuffer(uniforms, this.uniforms);
    }
    if (context.prevState != void 0 && !context.isPickBuffersValid() && state.toonOutline.enabled && state.toonOutline.on) {
      await context.renderPickBuffers();
    }
  }
  render(state) {
    const { context, resources } = this;
    if (context.deviceProfile.quirks.adreno600) {
      return;
    }
    const { program, uniforms, sampler } = resources;
    const { gl, cameraUniforms } = context;
    const { textures } = context.buffers;
    if (context.prevState != void 0 && context.isPickBuffersValid() && state.toonOutline.enabled && state.toonOutline.on) {
      glState(gl, {
        program,
        uniformBuffers: [cameraUniforms, uniforms],
        textures: [
          { kind: "TEXTURE_2D", texture: textures.color, sampler },
          { kind: "TEXTURE_2D", texture: textures.pick, sampler },
          { kind: "TEXTURE_2D", texture: textures.depth, sampler }
        ],
        sample: {
          alphaToCoverage: true
        },
        blend: {
          enable: false,
          srcRGB: "SRC_ALPHA",
          dstRGB: "ONE_MINUS_SRC_ALPHA",
          srcAlpha: "ONE",
          dstAlpha: "ONE"
        },
        depth: {
          test: false,
          writeMask: false
        }
      });
      const stats = glDraw(gl, { kind: "arrays", mode: "TRIANGLE_STRIP", count: 4 });
      context.addRenderStatistics(stats);
    }
  }
  contextLost() {
  }
  dispose() {
    this.contextLost();
    this.resources.bin.dispose();
  }
};

// /projects/Novorender/ts/dist/core3d/modules/default.ts
function createDefaultModules() {
  return [
    new BackgroundModule(),
    new CubeModule(),
    new OctreeModule(),
    new DynamicModule(),
    new ToonModule(),
    new GridModule(),
    new ClippingModule(),
    new WatermarkModule(),
    new TonemapModule()
  ];
}

// /projects/Novorender/ts/dist/core3d/context.ts
var RenderContext2 = class _RenderContext {
  /** @internal */
  constructor(deviceProfile, canvas, imports, webGLOptions) {
    this.deviceProfile = deviceProfile;
    this.canvas = canvas;
    this.imports = imports;
    const gl = canvas.getContext("webgl2", webGLOptions);
    if (!gl)
      throw new Error("Unable to create WebGL 2 context!");
    this.gl = gl;
    const extensions = glExtensions(gl, true);
    const defaultBin = this.defaultResourceBin = this.resourceBin("context");
    const iblBin = this.iblResourceBin = this.resourceBin("ibl");
    console.assert(extensions.loseContext != null, extensions.multiDraw != null, extensions.colorBufferFloat != null);
    const { provokingVertex } = extensions;
    if (provokingVertex) {
      provokingVertex.provokingVertexWEBGL(provokingVertex.FIRST_VERTEX_CONVENTION_WEBGL);
    }
    this.commonChunk = imports.shaders.common;
    this.wasm = imports.wasmInstance;
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    const lutParams = { kind: "TEXTURE_2D", internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image: imports.lutGGX };
    this.lut_ggx = defaultBin.createTexture(lutParams);
    this.samplerSingle = defaultBin.createSampler({ minificationFilter: "LINEAR", magnificationFilter: "LINEAR", wrap: ["CLAMP_TO_EDGE", "CLAMP_TO_EDGE"] });
    this.samplerMip = defaultBin.createSampler({ minificationFilter: "LINEAR_MIPMAP_LINEAR", magnificationFilter: "LINEAR", wrap: ["CLAMP_TO_EDGE", "CLAMP_TO_EDGE"] });
    const top = new Uint8Array([192, 192, 192, 255]);
    const side = new Uint8Array([128, 128, 128, 255]);
    const bottom = new Uint8Array([64, 64, 64, 255]);
    const image = [side, side, top, bottom, side, side];
    const textureParams = this.defaultIBLTextureParams = { kind: "TEXTURE_CUBE_MAP", width: 1, height: 1, internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image };
    this.iblTextures = {
      diffuse: iblBin.createTexture(textureParams),
      specular: iblBin.createTexture(textureParams),
      numMipMaps: 1,
      default: true
    };
    this.cameraUniformsData = glUBOProxy({
      clipViewMatrix: "mat4",
      viewClipMatrix: "mat4",
      localViewMatrix: "mat4",
      viewLocalMatrix: "mat4",
      localViewMatrixNormal: "mat3",
      viewLocalMatrixNormal: "mat3",
      windowSize: "vec2",
      near: "float"
    });
    this.cameraUniforms = glCreateBuffer(gl, { kind: "UNIFORM_BUFFER", byteSize: this.cameraUniformsData.buffer.byteLength });
    this.clippingUniformsData = glUBOProxy({
      "planes.0": "vec4",
      "planes.1": "vec4",
      "planes.2": "vec4",
      "planes.3": "vec4",
      "planes.4": "vec4",
      "planes.5": "vec4",
      numPlanes: "uint",
      mode: "uint"
    });
    this.clippingUniforms = glCreateBuffer(gl, { kind: "UNIFORM_BUFFER", byteSize: this.clippingUniformsData.buffer.byteLength });
    this.outlinesUniformsData = glUBOProxy({
      localPlaneMatrix: "mat4",
      planeLocalMatrix: "mat4",
      color: "vec3",
      planeIndex: "int"
    });
    this.outlineUniforms = glCreateBuffer(gl, { kind: "UNIFORM_BUFFER", byteSize: this.outlinesUniformsData.buffer.byteLength });
  }
  /** WebGL2 render context associated with this object. */
  gl;
  /** WebGL common GLSL code header used across shaders. */
  commonChunk;
  /** WebGL basic fallback IBL textures to use while loading proper IBL textures. */
  defaultIBLTextureParams;
  /** Web assembly instance. */
  wasm;
  static defaultModules;
  modules;
  cameraUniformsData;
  clippingUniformsData;
  outlinesUniformsData;
  localSpaceTranslation = vec3_exports.create();
  asyncPrograms = [];
  resourceBins = /* @__PURE__ */ new Set();
  defaultResourceBin;
  iblResourceBin;
  pickBuffersValid = false;
  currentPick;
  activeTimers = /* @__PURE__ */ new Set();
  currentFrameTime = 0;
  statistics = {
    points: 0,
    lines: 0,
    triangles: 0,
    drawCalls: 0,
    primitives: 0
  };
  prevFrame;
  // use a pre-pass to fill in z-buffer for improved fill rate at the expense of triangle rate (useful when doing heavy shading, but unclear how efficient this is on tiled GPUs.)
  //* @internal */
  usePrepass = false;
  // copy from last rendered state
  isOrtho = false;
  viewClipMatrix = mat4_exports.create();
  viewWorldMatrix = mat4_exports.create();
  viewWorldMatrixNormal = mat3_exports.create();
  viewClipMatrixLastPoll = mat4_exports.create();
  viewWorldMatrixLastPoll = mat4_exports.create();
  // constant gl resources
  /** WebGL uniform buffer for camera related uniforms. */
  cameraUniforms;
  /** WebGL uniform buffer for clipping related uniforms. */
  clippingUniforms;
  /** WebGL uniform buffer for outline related uniforms. */
  outlineUniforms;
  /** WebGL GGX/PBR shading lookup table texture. */
  lut_ggx;
  /** WebGL Sampler used to sample mipmapped diffuse IBL texture. */
  samplerMip;
  // use to read diffuse texture
  /** WebGL Sampler used to sample other, non-mipmapped IBL textures. */
  samplerSingle;
  // use to read the other textures
  // shared mutable state
  /** {@link RenderState} used to render the previous frame, if any. */
  prevState;
  // shared mutable state
  /** {@link RenderState} used to make the newest state available during render. */
  currentState;
  /** Set to true to force a re-render when state not contained in {@link RenderState} has changed, e.g. download complete etc. */
  changed = true;
  /** @internal */
  pause = false;
  // true to freeze all module updates, e.g. downloading of new geometry etc.
  /** WebGL render and pick buffers
   * @remarks
   * Note that these buffers will be recreated whenever the {@link RenderState.output} size changes.
   */
  buffers = void 0;
  /** WebGL textures used for image based lighting ({@link https://en.wikipedia.org/wiki/Image-based_lighting | IBL}).
   * @remarks
   * Note that these buffers will be changed by the background module when download of the specified {@link RenderState.background.url} IBL textures completes.
   * 
   * The process to create the textures are similar to that of {@link https://github.com/KhronosGroup/glTF-IBL-Sampler}/
   */
  iblTextures;
  /** Initialize render context with specified render modules.
   * @remarks
   * The default/built-in render modules can be retrieved using {@link createDefaultModules}.
   * These will be used if no modules are specified.
   * Developers may introduce their own render modules here.
   * Note that the order of the modules matters, as this is the order by which they will be rendered.
   */
  async init(modules) {
    if (!modules) {
      _RenderContext.defaultModules ??= createDefaultModules();
      modules = _RenderContext.defaultModules;
    }
    const modulePromises = modules.map((m, i) => {
      const ret = m.withContext(this);
      return isPromise(ret) ? ret : Promise.resolve(ret);
    });
    this.linkAsyncPrograms();
    this.modules = await Promise.all(modulePromises);
  }
  linkAsyncPrograms() {
    const { gl, asyncPrograms } = this;
    for (const { program } of this.asyncPrograms) {
      gl.linkProgram(program);
    }
    gl.useProgram(null);
    const ext = glExtensions(gl).parallelShaderCompile;
    function pollAsyncPrograms() {
      for (let i = 0; i < asyncPrograms.length; i++) {
        const { program, resolve, reject } = asyncPrograms[i];
        if (ext) {
          if (!gl.getProgramParameter(program, ext.COMPLETION_STATUS_KHR))
            continue;
        }
        const [info] = asyncPrograms.splice(i--, 1);
        const error = glCheckProgram(gl, info);
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      }
      if (asyncPrograms.length > 0) {
        setTimeout(pollAsyncPrograms);
      }
    }
    pollAsyncPrograms();
  }
  /**
   * Dispose of the GPU resources used by this context, effectively destroying it and freeing up memory.
   * @remarks
   * Calling this method is optional as the garbage collection of the underlying WebGL render context will do the same thing.
   * This may take some time, however, so calling this function is recommended if you plan to create a new context shortly thereafter.
   */
  dispose() {
    const { buffers, modules, activeTimers, defaultResourceBin, iblResourceBin } = this;
    this.poll();
    for (const timer of activeTimers) {
      timer.dispose();
    }
    activeTimers.clear();
    if (modules) {
      for (const module of modules) {
        module?.dispose();
      }
      this.modules = void 0;
    }
    buffers?.dispose();
    iblResourceBin.dispose();
    defaultResourceBin.dispose();
    console.assert(this.resourceBins.size == 0);
  }
  /** Return the current pixel width of the drawing buffer. */
  get width() {
    return this.gl.drawingBufferWidth;
  }
  /** Return the current pixel height of the drawing buffer. */
  get height() {
    return this.gl.drawingBufferHeight;
  }
  /** Query if pick buffers are valid.
   * @remarks This could be useful for optimistic/non-async picking.
   */
  isPickBuffersValid() {
    return this.pickBuffersValid;
  }
  /** Query whether the underlying WebGL render context is currently lost.
   * @remarks
   * This could occur when too many resources are allocated or when browser window is dragged across screens.
   * Loss and restoration of WebGL contexts is supported by this API automatically.
   */
  isContextLost() {
    return this.gl.isContextLost();
  }
  /** @internal */
  drawBuffers(buffers = 7 /* all */) {
    const activeBuffers = buffers;
    return [
      activeBuffers & 1 /* color */ ? "COLOR_ATTACHMENT0" : "NONE",
      activeBuffers & 2 /* pick */ ? "COLOR_ATTACHMENT1" : "NONE"
    ];
  }
  /** Helper function to update WebGL uniform buffer from proxies. */
  updateUniformBuffer(uniformBuffer, proxy2) {
    if (!proxy2.dirtyRange.isEmpty) {
      const { begin, end } = proxy2.dirtyRange;
      glUpdateBuffer(this.gl, { kind: "UNIFORM_BUFFER", srcData: proxy2.buffer, targetBuffer: uniformBuffer, srcElementOffset: begin, dstByteOffset: begin, byteSize: end - begin });
      proxy2.dirtyRange.clear();
    }
  }
  /** Explicitly update WebGL IBL textures from specified parameters. */
  updateIBLTextures(params) {
    const { iblResourceBin } = this;
    iblResourceBin.deleteAll();
    if (params) {
      const { diffuse, specular } = params;
      this.iblTextures = {
        diffuse: iblResourceBin.createTexture(diffuse),
        specular: iblResourceBin.createTexture(specular),
        numMipMaps: typeof specular.mipMaps == "number" ? specular.mipMaps : specular.mipMaps.length,
        default: false
      };
    } else {
      this.iblTextures = {
        diffuse: iblResourceBin.createTexture(this.defaultIBLTextureParams),
        specular: iblResourceBin.createTexture(this.defaultIBLTextureParams),
        numMipMaps: 1,
        default: true
      };
    }
  }
  /**
   * Helper function to check for changes in render state.
   * @param state The parts of the render state to check for changes.
   * @returns True if any of the specified parts has changed since last frame.
   * @remarks
   * Since the render state is immutable, any changes will automatically trickle up to the container object as well.
   * Thus, this function does a shallow strict equality of the parts of the renderstate specified in the state parameter.
   * @example
   * Example of how to check for changes in either camera or output render state.
   * ```typescript
   * const {camera, output} = renderState;
   * if(renderContext.hasStateChanged({camera, output})) {
   *   // update related GPU state here...
   * }
   * ```
   */
  hasStateChanged(state) {
    const { prevState } = this;
    let changed = false;
    for (const prop in state) {
      const p = prop;
      if (!prevState || prevState[p] !== state[p]) {
        changed = true;
        break;
      }
    }
    return changed;
  }
  /** Create a new named resource bin. */
  resourceBin(name) {
    return new ResourceBin(this.gl, name, this.resourceBins);
  }
  /** Compile WebGL/GLSL shader program asynchronously. */
  makeProgramAsync(resourceBin, params) {
    const { gl, commonChunk } = this;
    const { vertexShader, fragmentShader } = params;
    const header = { commonChunk, ...params.header };
    const programAsync = resourceBin.createProgramAsync({ header, vertexShader, fragmentShader });
    const { program } = programAsync;
    const { attributes, transformFeedback, uniformBufferBlocks, textureUniforms } = params;
    if (attributes) {
      let i = 0;
      for (const name of attributes) {
        gl.bindAttribLocation(program, i++, name);
      }
    }
    if (transformFeedback) {
      const { varyings, bufferMode } = transformFeedback;
      gl.transformFeedbackVaryings(program, varyings, gl[bufferMode]);
    }
    return new Promise((resolve, reject) => {
      function postLink() {
        gl.useProgram(program);
        if (uniformBufferBlocks) {
          let idx = 0;
          for (const name of uniformBufferBlocks) {
            if (name) {
              const blockIndex = gl.getUniformBlockIndex(program, name);
              if (blockIndex != gl.INVALID_INDEX) {
                gl.uniformBlockBinding(program, blockIndex, idx);
              } else {
                console.warn(`Shader has no uniform block named: ${name}!`);
              }
            }
            idx++;
          }
        }
        if (textureUniforms) {
          let i = 0;
          for (const name of textureUniforms) {
            const location = gl.getUniformLocation(program, name);
            gl.uniform1i(location, i++);
          }
        }
        gl.useProgram(null);
        resolve(program);
      }
      this.asyncPrograms.push({ ...programAsync, resolve: postLink, reject });
    });
  }
  resetStatistics() {
    const { statistics } = this;
    statistics.points = 0;
    statistics.lines = 0;
    statistics.triangles = 0;
    statistics.drawCalls = 0;
    statistics.primitives = 0;
  }
  /** @internal */
  addRenderStatistics(stats, drawCalls = 1) {
    const { statistics } = this;
    statistics.points += stats.points;
    statistics.lines += stats.lines;
    statistics.triangles += stats.triangles;
    statistics.drawCalls += drawCalls;
  }
  /** @internal */
  addLoadStatistics(numPrimitives) {
    this.statistics.primitives += numPrimitives;
  }
  /** @internal */
  contextLost() {
    const { modules } = this;
    if (modules) {
      for (const module of modules) {
        module?.contextLost();
      }
    }
  }
  /** @internal */
  emulateLostContext(value) {
    const ext = glExtensions(this.gl).loseContext;
    if (ext) {
      if (value == "lose") {
        ext.loseContext();
      } else {
        ext.restoreContext();
      }
    }
  }
  /** Poll the status of WebGL pick fences and timers and resolve associated promises when possible. */
  poll() {
    this.buffers?.pollPickFence();
    this.viewClipMatrixLastPoll = mat4_exports.clone(this.viewClipMatrix);
    this.viewWorldMatrixLastPoll = mat4_exports.clone(this.viewWorldMatrix);
    this.pollTimers();
  }
  beginTimer() {
    const timer = glCreateTimer(this.gl, false);
    this.activeTimers.add(timer);
    timer.begin();
    return timer;
  }
  pollTimers() {
    const { activeTimers } = this;
    for (const timer of [...activeTimers]) {
      if (timer.poll()) {
        activeTimers.delete(timer);
        timer.dispose();
      }
    }
  }
  /** Wait for the next frame to be ready for rendering.
   * @param context render context to wait for, if any.
   * @remarks Use this function instead of requestAnimationFrame()!
   */
  static nextFrame(context) {
    return new Promise((resolve) => {
      requestAnimationFrame((time) => {
        if (context) {
          const { prevFrame } = context;
          if (prevFrame) {
            prevFrame.resolve(time - prevFrame.time);
            context.prevFrame = void 0;
          }
          context.currentFrameTime = time;
        }
        resolve(time);
      });
    });
  }
  /**
   * Render a new frame using the specified render state.
   * @param state An object describing what the frame should look like.
   * @returns A promise to the performance related statistics involved in rendering this frame.
   */
  async render(state) {
    if (!this.modules) {
      throw new Error("Context has not been initialized!");
    }
    const beginTime = performance.now();
    const { gl, canvas, prevState } = this;
    this.changed = false;
    this.resetStatistics();
    const drawTimer = this.beginTimer();
    const { MAX_SAMPLES } = glLimits(gl);
    const effectiveSamplesMSAA = Math.max(1, Math.min(MAX_SAMPLES, Math.min(this.deviceProfile.limits.maxSamples, state.output.samplesMSAA)));
    let resized = false;
    const { output } = state;
    if (this.hasStateChanged({ output })) {
      const { width: width2, height: height2 } = output;
      console.assert(Number.isInteger(width2) && Number.isInteger(height2));
      canvas.width = width2;
      canvas.height = height2;
      resized = true;
      this.changed = true;
      this.buffers?.dispose();
      this.buffers = new RenderBuffers(gl, width2, height2, effectiveSamplesMSAA, this.resourceBin("FrameBuffers"));
    }
    const derivedState = state;
    derivedState.effectiveSamplesMSAA = effectiveSamplesMSAA;
    if (resized || state.camera !== prevState?.camera) {
      const snapDist = 1024;
      const dir = vec3_exports.sub(vec3_exports.create(), state.camera.position, this.localSpaceTranslation).map((c) => Math.abs(c));
      const dist4 = Math.max(dir[0], dir[2]);
      if (dist4 >= snapDist) {
        let snap2 = function(v) {
          return Math.round(v / snapDist) * snapDist;
        };
        var snap = snap2;
        this.localSpaceTranslation = vec3_exports.fromValues(snap2(state.camera.position[0]), 0, snap2(state.camera.position[2]));
      }
      derivedState.localSpaceTranslation = this.localSpaceTranslation;
      derivedState.matrices = matricesFromRenderState(state);
      derivedState.viewFrustum = createViewFrustum(state, derivedState.matrices);
    }
    this.currentState = derivedState;
    this.pickBuffersValid = false;
    this.updateCameraUniforms(derivedState);
    this.updateClippingUniforms(derivedState);
    this.isOrtho = derivedState.camera.kind == "orthographic";
    mat4_exports.copy(this.viewClipMatrix, derivedState.matrices.getMatrix(1 /* View */, 2 /* Clip */));
    mat4_exports.copy(this.viewWorldMatrix, derivedState.matrices.getMatrix(1 /* View */, 0 /* World */));
    mat3_exports.copy(this.viewWorldMatrixNormal, derivedState.matrices.getMatrixNormal(1 /* View */, 0 /* World */));
    if (!this.pause) {
      for (const module of this.modules) {
        module?.update(derivedState);
      }
    }
    this.linkAsyncPrograms();
    const { width, height } = canvas;
    const { buffers } = this;
    buffers.readBuffersNeedUpdate = true;
    const frameBufferName = effectiveSamplesMSAA > 1 ? "colorMSAA" : "color";
    const frameBuffer = buffers.frameBuffers[frameBufferName];
    buffers.invalidate(frameBufferName, 7 /* all */);
    glState(gl, { viewport: { width, height }, frameBuffer });
    glClear(gl, { kind: "DEPTH_STENCIL", depth: 1, stencil: 0 });
    if (this.usePrepass) {
      for (const module of this.modules) {
        if (module && module.prepass) {
          glState(gl, {
            viewport: { width, height },
            frameBuffer,
            drawBuffers: []
            // colorMask: [false, false, false, false],
          });
          module.prepass(derivedState);
          glState(gl, null);
        }
      }
    }
    for (const module of this.modules) {
      if (module) {
        glState(gl, {
          viewport: { width, height },
          frameBuffer,
          drawBuffers: this.drawBuffers(1 /* color */),
          sample: { alphaToCoverage: effectiveSamplesMSAA > 1 }
        });
        module.render(derivedState);
        glState(gl, null);
      }
    }
    drawTimer.end();
    this.buffers.invalidate("colorMSAA", 1 /* color */ | 4 /* depth */);
    this.buffers.invalidate("color", 1 /* color */ | 4 /* depth */);
    this.prevState = derivedState;
    const endTime = performance.now();
    const intervalPromise = new Promise((resolve) => {
      this.prevFrame = { time: this.currentFrameTime, resolve };
    });
    const stats = { ...this.statistics, bufferBytes: 0, textureBytes: 0 };
    for (const bin of this.resourceBins) {
      for (const { kind, byteSize } of bin.resourceInfo) {
        if (kind == "Buffer" || kind == "Renderbuffer") {
          stats.bufferBytes += byteSize;
        }
        if (kind == "Texture") {
          stats.textureBytes += byteSize;
        }
      }
    }
    const [gpuDrawTime, frameInterval] = await Promise.all([drawTimer.promise, intervalPromise]);
    return {
      cpuTime: {
        draw: endTime - beginTime
      },
      gpuTime: {
        draw: gpuDrawTime
      },
      frameInterval,
      ...stats
    };
  }
  //* @internal */
  clearPickBuffers() {
    glClear(this.gl, { kind: "COLOR", drawBuffer: 1, type: "Uint", color: [4294967295, 0, 0, 0] });
  }
  //* @internal */
  renderPickBuffers() {
    if (!this.pickBuffersValid) {
      if (!this.modules) {
        throw new Error("Context has not been initialized!");
      }
      const { gl, width, height, buffers, currentState } = this;
      if (!currentState) {
        throw new Error("render() was not called!");
      }
      const stateParams = {
        viewport: { width, height },
        frameBuffer: buffers.frameBuffers.pick,
        drawBuffers: this.drawBuffers(2 /* pick */),
        depth: { test: true, writeMask: true }
      };
      glState(gl, stateParams);
      glClear(gl, { kind: "DEPTH_STENCIL", depth: 1, stencil: 0 });
      this.clearPickBuffers();
      for (const module of this.modules) {
        if (module) {
          glState(gl, stateParams);
          module.pick?.(currentState);
          glState(gl, null);
        }
      }
      if (currentState.tonemapping.mode != 0 /* color */) {
        console.log("debug");
        const tonemapModule = this.modules?.find((m) => m.module.kind == "tonemap");
        glState(gl, { viewport: { width, height } });
        tonemapModule?.render(currentState);
        glState(gl, null);
      }
      this.pickBuffersValid = true;
    }
  }
  //* @internal */
  *getLinearDepths(pick) {
    const floats = new Float32Array(pick.buffer);
    for (let i = 3; i < pick.length; i += 4) {
      yield floats[i];
    }
  }
  //* @internal */
  getOutlineObjects(pick) {
    const objs = /* @__PURE__ */ new Set();
    for (let i = 0; i < pick.length; i += 4) {
      const objectId = pick[i];
      if (objectId < 4026531840 && (objectId & 1 << 31) != 0) {
        objs.add(objectId & ~(1 << 31));
      }
    }
    return objs;
  }
  /**
  * scan the pick buffer for deviation values
  * @returns Return pixel coordinates and deviation values for any deviation on screen 
  */
  async getDeviations() {
    this.renderPickBuffers();
    const pickBufferPromise = this.buffers.pickBuffers();
    this.currentPick = (await pickBufferPromise).pick;
    const { currentPick, width, height, canvas, wasm: wasm2 } = this;
    if (currentPick === void 0 || width * height * 4 != currentPick.length) {
      return [];
    }
    const u16 = new Uint16Array(currentPick.buffer);
    const floats = new Float32Array(currentPick.buffer);
    const samples = [];
    const { isOrtho, viewClipMatrixLastPoll, viewWorldMatrixLastPoll } = this;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const buffOffs = ix + iy * width;
        const objectId = currentPick[buffOffs * 4];
        if (objectId != 4294967295) {
          const deviation16 = u16[buffOffs * 8 + 5];
          const dev32 = wasm2.float32(deviation16);
          const deviation = deviation16 !== 0 ? dev32 : void 0;
          if (deviation) {
            const depth = floats[buffOffs * 4 + 3];
            const xCS = (ix + 0.5) / width * 2 - 1;
            const yCS = (iy + 0.5) / height * 2 - 1;
            const scale7 = isOrtho ? 1 : depth;
            const posVS = vec3_exports.fromValues(xCS / viewClipMatrixLastPoll[0] * scale7, yCS / viewClipMatrixLastPoll[5] * scale7, -depth);
            const position = vec3_exports.transformMat4(vec3_exports.create(), posVS, viewWorldMatrixLastPoll);
            samples.push({ x: ix, y: height - iy, deviation, position });
          }
        }
      }
    }
    return samples;
  }
  updateCameraUniforms(state) {
    const { cameraUniformsData, localSpaceTranslation } = this;
    const { output, camera, matrices } = state;
    const { values } = cameraUniformsData;
    const worldViewMatrix = matrices.getMatrix(0 /* World */, 1 /* View */);
    const viewWorldMatrix = matrices.getMatrix(1 /* View */, 0 /* World */);
    const worldLocalMatrix = mat4_exports.fromTranslation(mat4_exports.create(), vec3_exports.negate(vec3_exports.create(), localSpaceTranslation));
    const localWorldMatrix = mat4_exports.fromTranslation(mat4_exports.create(), localSpaceTranslation);
    values.clipViewMatrix = matrices.getMatrix(2 /* Clip */, 1 /* View */);
    values.viewClipMatrix = matrices.getMatrix(1 /* View */, 2 /* Clip */);
    values.viewClipMatrix = matrices.getMatrix(1 /* View */, 2 /* Clip */);
    values.localViewMatrix = mat4_exports.multiply(mat4_exports.create(), worldViewMatrix, localWorldMatrix);
    values.viewLocalMatrix = mat4_exports.multiply(mat4_exports.create(), worldLocalMatrix, viewWorldMatrix);
    values.localViewMatrixNormal = matrices.getMatrixNormal(0 /* World */, 1 /* View */);
    values.viewLocalMatrixNormal = matrices.getMatrixNormal(1 /* View */, 0 /* World */);
    values.windowSize = [output.width, output.height];
    values.near = camera.near;
    this.updateUniformBuffer(this.cameraUniforms, this.cameraUniformsData);
  }
  updateClippingUniforms(state) {
    const { clipping, matrices } = state;
    if (this.hasStateChanged({ clipping, matrices })) {
      const { clippingUniforms, clippingUniformsData } = this;
      const { values } = clippingUniformsData;
      const { enabled, mode, planes } = clipping;
      const normal = vec3_exports.create();
      const position = vec3_exports.create();
      const matrix = matrices.getMatrix(0 /* World */, 1 /* View */);
      const matrixNormal = matrices.getMatrixNormal(0 /* World */, 1 /* View */);
      mat4_exports.getTranslation(position, matrix);
      for (let i = 0; i < planes.length; i++) {
        const { normalOffset } = planes[i];
        const [x, y, z, offset] = normalOffset;
        vec3_exports.set(normal, x, y, z);
        vec3_exports.transformMat3(normal, normal, matrixNormal);
        const distance4 = offset + vec3_exports.dot(position, normal);
        const plane = vec4_exports.fromValues(normal[0], normal[1], normal[2], -distance4);
        const idx = i;
        values[`planes.${idx}`] = plane;
      }
      values["numPlanes"] = enabled ? planes.length : 0;
      values["mode"] = mode;
      this.updateUniformBuffer(clippingUniforms, clippingUniformsData);
    }
  }
  /** @internal */
  updateOutlinesUniforms(plane, color, planeIndex) {
    const { outlineUniforms, outlinesUniformsData } = this;
    const [x, y, z, offset] = plane;
    const normal = vec3_exports.fromValues(x, y, z);
    const distance4 = -offset - vec3_exports.dot(this.localSpaceTranslation, normal);
    const planeLS = vec4_exports.fromValues(normal[0], normal[1], normal[2], -distance4);
    const planeLocalMatrix = orthoNormalBasisMatrixFromPlane(planeLS);
    const localPlaneMatrix = mat4_exports.invert(mat4_exports.create(), planeLocalMatrix);
    const { values } = outlinesUniformsData;
    values.planeLocalMatrix = planeLocalMatrix;
    values.localPlaneMatrix = localPlaneMatrix;
    values.color = color;
    values.planeIndex = planeIndex;
    this.updateUniformBuffer(outlineUniforms, outlinesUniformsData);
  }
  extractPick(pickBuffer, x, y, sampleDiscRadius, pickCameraPlane) {
    const { canvas, wasm: wasm2, width, height } = this;
    const rect = canvas.getBoundingClientRect();
    const cssWidth = rect.width;
    const cssHeight = rect.height;
    const px = Math.min(Math.max(0, Math.round(x / cssWidth * width)), width);
    const py = Math.min(Math.max(0, Math.round((1 - (y + 0.5) / cssHeight) * height)), height);
    const floats = new Float32Array(pickBuffer.buffer);
    const r = Math.ceil(sampleDiscRadius);
    const r2 = sampleDiscRadius * sampleDiscRadius;
    let x0 = px - r;
    let x1 = px + r + 1;
    let y0 = py - r;
    let y1 = py + r + 1;
    if (x0 < 0)
      x0 = 0;
    if (x1 > width)
      x1 = width;
    if (y0 < 0)
      y0 = 0;
    if (y1 > height)
      y1 = height;
    const samples = [];
    const { isOrtho, viewClipMatrixLastPoll, viewWorldMatrixLastPoll } = this;
    const f16Max = 65504;
    for (let iy = y0; iy < y1; iy++) {
      const dy = iy - py;
      for (let ix = x0; ix < x1; ix++) {
        const dx = ix - px;
        if (dx * dx + dy * dy > r2)
          continue;
        const buffOffs = ix + iy * width;
        let objectId = pickBuffer[buffOffs * 4];
        if (objectId != 4294967295) {
          const isReservedId = objectId >= 4026531840;
          const depth = pickCameraPlane ? 0 : floats[buffOffs * 4 + 3];
          const [nx16, ny16, nz16, deviation16] = new Uint16Array(pickBuffer.buffer, buffOffs * 16 + 4, 4);
          const nx = wasm2.float32(nx16);
          const ny = wasm2.float32(ny16);
          const nz = wasm2.float32(nz16);
          const dev32 = wasm2.float32(deviation16);
          const deviation = deviation16 !== 0 ? dev32 : void 0;
          const xCS = (ix + 0.5) / width * 2 - 1;
          const yCS = (iy + 0.5) / height * 2 - 1;
          const scale7 = isOrtho ? 1 : depth;
          const posVS = vec3_exports.fromValues(xCS / viewClipMatrixLastPoll[0] * scale7, yCS / viewClipMatrixLastPoll[5] * scale7, -depth);
          const position = vec3_exports.transformMat4(vec3_exports.create(), posVS, viewWorldMatrixLastPoll);
          const normal = vec3_exports.fromValues(nx, ny, nz);
          vec3_exports.normalize(normal, normal);
          const clippingOutline = isReservedId ? false : (objectId & 1 << 31) != 0;
          objectId = isReservedId ? objectId : objectId & ~(1 << 31);
          const sample = { x: ix - px, y: iy - py, position, normal, objectId, deviation, depth, clippingOutline };
          samples.push(sample);
        }
      }
    }
    return samples;
  }
  /**
   * Pick information about underlying object and geometry.
   * @param x Center x coordinate in CSS pixels.
   * @param y Center y coordinate in CSS pixels.
   * @param options More details of pick operation.
   * @returns A set of pick samples of the specified sample disc.
   */
  async pick(x, y, options) {
    const sampleDiscRadius = options?.sampleDiscRadius ?? 0;
    const callAsync = options?.async ?? true;
    const pickCameraPlane = options?.pickCameraPlane ?? false;
    if (sampleDiscRadius < 0)
      return [];
    this.renderPickBuffers();
    const pickBufferPromise = this.buffers.pickBuffers();
    if (callAsync) {
      this.currentPick = (await pickBufferPromise).pick;
    } else {
      pickBufferPromise.then(({ pick }) => {
        this.currentPick = pick;
      });
    }
    const { currentPick, width, height } = this;
    if (currentPick === void 0 || width * height * 4 != currentPick.length) {
      return [];
    }
    return this.extractPick(currentPick, x, y, sampleDiscRadius, pickCameraPlane);
  }
};
function isPromise(promise) {
  return !!promise && typeof Reflect.get(promise, "then") === "function";
}

// /projects/Novorender/ts/dist/core3d/init.ts
function initCore3D(deviceProfile, canvas, imports, setRenderContext) {
  const options = {
    alpha: true,
    antialias: true,
    depth: false,
    desynchronized: false,
    failIfMajorPerformanceCaveat: true,
    powerPreference: "high-performance",
    premultipliedAlpha: true,
    preserveDrawingBuffer: true,
    stencil: false
  };
  let renderContext;
  let context = { renderContext: void 0 };
  let animId;
  canvas.addEventListener("webglcontextlost", function(event) {
    event.preventDefault();
    console.info("WebGL Context lost!");
    if (renderContext) {
      renderContext.contextLost();
      context.renderContext = void 0;
    }
    canvas.width = 300;
    canvas.height = 150;
    if (animId !== void 0)
      cancelAnimationFrame(animId);
    animId = void 0;
  }, false);
  canvas.addEventListener("webglcontextrestored", function(event) {
    console.info("WebGL Context restored!");
    createContext();
  }, false);
  async function createContext() {
    renderContext = new RenderContext2(deviceProfile, canvas, imports, options);
    await renderContext.init();
    setRenderContext(renderContext);
  }
  createContext();
  return async (value) => {
    deviceProfile = value;
    await createContext();
  };
}

// /projects/Novorender/ts/dist/core3d/imports/index.ts
async function downloadCore3dImports(map) {
  const { baseUrl } = map;
  const loaderWorker = getWorker(map.loaderWorker ?? "./loaderWorker.js", baseUrl);
  const lutGGXPromise = getLutGGX(map.lutGGX ?? "./lut_ggx.png", baseUrl);
  const wasmInstancePromise = getInstance(map.wasmInstance ?? "./main.wasm", baseUrl);
  const parserWasmPromise = getArrayBuffer(map.parserWasm ?? "./parser.wasm", baseUrl);
  const shadersPromise = getShaders(map.shaders ?? "./shaders.js", baseUrl);
  const logoPromise = getLogo(map.logo ?? "./logo.bin", baseUrl);
  const [lutGGX, wasmInstance, parserWasm, shaders, logo] = await Promise.all([lutGGXPromise, wasmInstancePromise, parserWasmPromise, shadersPromise, logoPromise]);
  return { lutGGX, wasmInstance, parserWasm, loaderWorker, shaders, logo };
}
async function download2(url, kind) {
  const response = await fetch(url, { mode: "cors" });
  if (!response.ok)
    throw new Error(`HTTP error ${response.status}: ${response.statusText}!`);
  return await response[kind]();
}
function isUrl(url) {
  return typeof url == "string" || url instanceof URL;
}
async function getLutGGX(arg, baseUrl) {
  let blob;
  if (isUrl(arg)) {
    const url = new URL(arg, baseUrl);
    blob = await download2(url, "blob");
  } else if (arg instanceof Blob) {
    blob = arg;
  } else {
    return arg;
  }
  return await createImageBitmap(blob);
}
async function getInstance(arg, baseUrl) {
  if (!isUrl(arg)) {
    return arg;
  }
  const url = new URL(arg, baseUrl);
  const response = await fetch(url, { mode: "cors" });
  const { instance } = await WebAssembly.instantiateStreaming(response);
  return instance.exports;
}
async function getArrayBuffer(arg, baseUrl) {
  if (!isUrl(arg)) {
    return arg;
  }
  const url = new URL(arg, baseUrl);
  const response = await fetch(url, { mode: "cors" });
  if (!response.ok) {
    throw new Error(`Could not download wasm instance from: ${url}`);
  }
  return await response.arrayBuffer();
}
function getWorker(arg, baseUrl) {
  if (!isUrl(arg)) {
    return arg;
  }
  const url = new URL(arg, baseUrl);
  return new Worker(url, { type: "module", name: "loader" });
}
async function getLogo(arg, baseUrl) {
  if (!isUrl(arg)) {
    return arg;
  }
  const url = new URL(arg, baseUrl);
  return await download2(url, "arrayBuffer");
}
async function getShaders(arg, baseUrl) {
  if (!isUrl(arg)) {
    return arg;
  }
  const url = new URL(arg, baseUrl);
  const { shaders } = await import(
    /* webpackIgnore: true */
    url.toString()
  );
  return shaders;
}

// /projects/Novorender/ts/dist/core3d/benchmark/benchmark.ts
var Benchmark = class _Benchmark {
  canvas;
  gl;
  static size = 1024;
  static numPixels = _Benchmark.size * _Benchmark.size;
  constructor() {
    const options = {
      alpha: true,
      antialias: false,
      depth: false,
      desynchronized: false,
      failIfMajorPerformanceCaveat: true,
      powerPreference: "high-performance",
      premultipliedAlpha: true,
      preserveDrawingBuffer: false,
      stencil: false
    };
    const { size } = _Benchmark;
    const canvas = this.canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    canvas.style.backgroundColor = "red";
    canvas.style.position = "absolute";
    canvas.style.top = "0";
    canvas.style.left = "0";
    canvas.style.right = "0";
    canvas.style.bottom = "0";
    canvas.style.zIndex = "10";
    document.body.appendChild(canvas);
    const gl = canvas.getContext("webgl2", options);
    if (!gl)
      throw new Error("Unable to create WebGL 2 context!");
    this.gl = gl;
  }
  /** Dispose of created GPU resources. */
  dispose() {
    const { gl, canvas } = this;
    document.body.removeChild(canvas);
    const ext = gl.getExtension("WEBGL_lose_context");
    ext?.loseContext();
  }
};

// /projects/Novorender/ts/dist/core3d/benchmark/util.ts
function waitFrame() {
  return new Promise((resolve) => {
    function animate(time) {
      resolve(time);
    }
    requestAnimationFrame(animate);
  });
}
async function measure(action) {
  const elapsed = [];
  let prevTime;
  async function tick() {
    const time = await waitFrame();
    if (prevTime != void 0) {
      elapsed.push(time - prevTime);
    }
    prevTime = time;
  }
  const frames = 6;
  for (let i = 0; i < frames; i++) {
    await tick();
  }
  elapsed.sort((a, b) => a - b);
  const medianInterval = elapsed[Math.round(elapsed.length / 2)];
  const fps = Math.round(1e3 / medianInterval);
  console.log({ fps });
  let iterations = 1;
  for (; ; ) {
    prevTime = void 0;
    elapsed.length = 0;
    for (let i = 0; i < frames; i++) {
      await tick();
      for (let j = 0; j < iterations; j++) {
        action(j);
      }
    }
    elapsed.sort((a, b) => a - b);
    const averageFrameInterval = elapsed.slice(1, elapsed.length - 1).reduce((a, b) => a + b) / (elapsed.length - 2);
    if (averageFrameInterval > 100) {
      return averageFrameInterval / iterations;
    }
    iterations = Math.max(iterations + 1, Math.round(iterations * 1.75));
    console.log(iterations);
  }
}

// /projects/Novorender/ts/dist/core3d/benchmark/fillrate.ts
var FillrateProfiler = class {
  /**
   * @param benchmark The benchmark context to use.
   * @param shaders The shader imports.
   */
  constructor(benchmark, shaders) {
    this.benchmark = benchmark;
    const { gl } = this.benchmark;
    this.program = glCreateProgram(gl, shaders.fillrate);
    this.uniforms = glUniformLocations(gl, this.program, ["seed"]);
  }
  program;
  uniforms;
  /**
   * Measure fill rate by rendering a series of noisy, semi-transparent quads.
   * @returns Fill rate estimate in pixels/second.
   * @remarks
   * This test is quite inaccurate and does not match close to the nominal fill rate of a GPU, particularly on tile based mobile GPUs.
   * The result should only serve as a rough estimate.
   */
  async measure() {
    const { benchmark, program, uniforms } = this;
    const { gl } = benchmark;
    const { size, numPixels } = Benchmark;
    gl.getError();
    const numQuads = 128;
    glState(gl, {
      viewport: { width: size, height: size },
      program,
      blend: {
        enable: true,
        srcRGB: "SRC_ALPHA",
        dstRGB: "ONE_MINUS_SRC_ALPHA",
        srcAlpha: "ONE",
        dstAlpha: "ONE"
      },
      depth: {
        test: false,
        writeMask: false
      }
    });
    function render(iteration) {
      gl.uniform1f(uniforms.seed, Math.random());
      glDraw(gl, { kind: "arrays_instanced", mode: "TRIANGLE_STRIP", count: 4, instanceCount: numQuads });
      gl.flush();
    }
    glClear(gl, { kind: "back_buffer", color: [0, 0, 0, 1] });
    const time = await measure(render);
    const rate = numPixels * numQuads * 1e3 / time;
    return rate;
  }
};

// /projects/Novorender/ts/dist/core3d/benchmark/pointrate.ts
var PointrateProfiler = class {
  /**
   * @param benchmark The benchmark context to use.
   * @param shaders The shader imports.
   */
  constructor(benchmark, shaders) {
    this.benchmark = benchmark;
    const { gl } = this.benchmark;
    this.program = glCreateProgram(gl, shaders.pointrate);
    this.uniforms = glUniformLocations(gl, this.program, ["color"]);
  }
  program;
  uniforms;
  /**
   * Measure fill rate by rendering a series of noisy, semi-transparent point primitives.
   * @returns Primitive/point rate estimate in primitives/second.
   * @remarks
   * This test is quite inaccurate and does not match close to the nominal primitive/triangle rate of a GPU, particularly on tile based mobile GPUs.
   * Points are being used instead of triangles since they more closely reflect the maximum theoretical primitive rate of most GPUs.
   * The result should only serve as a rough estimate.
   */
  async measure() {
    const { benchmark, program, uniforms } = this;
    const { gl } = benchmark;
    const { size, numPixels } = Benchmark;
    gl.getError();
    const numOverdraws = 8;
    glState(gl, {
      viewport: { width: size, height: size },
      program,
      blend: {
        enable: false
      },
      depth: {
        test: false,
        writeMask: false
      }
    });
    function render(iteration) {
      gl.uniform4f(uniforms.color, Math.random(), Math.random(), Math.random(), 1);
      glDraw(gl, { kind: "arrays_instanced", mode: "POINTS", count: numPixels, instanceCount: numOverdraws });
    }
    glClear(gl, { kind: "back_buffer", color: [0, 0, 0, 1] });
    const time = await measure(render);
    const rate = numPixels * numOverdraws * 1e3 / time;
    return rate;
  }
};

// /projects/Novorender/ts/dist/core3d/gltf/loader.ts
async function request(url, abortController) {
  const signal = abortController?.signal;
  const response = await fetch(url.toString(), { mode: "cors", signal });
  if (!response.ok) {
    throw new Error(`HTTP Error: ${response.status}: ${response.statusText} (${url})`);
  }
  return response;
}
async function downloadJson(url, abortController) {
  const response = await request(url, abortController);
  return await response.json();
}
async function downloadArrayBuffer(url, abortController) {
  const response = await request(url, abortController);
  return await response.arrayBuffer();
}
async function downloadBlob(url, abortController) {
  const response = await request(url, abortController);
  return await response.blob();
}
var BINARY_HEADER_MAGIC = "glTF";
var BINARY_HEADER_LENGTH = 12;
var BINARY_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
function parseGLB(data) {
  const headerView = new DataView(data, 0, BINARY_HEADER_LENGTH);
  const decoder = new TextDecoder();
  const header = {
    magic: decoder.decode(new Uint8Array(data, 0, 4)),
    version: headerView.getUint32(4, true),
    length: headerView.getUint32(8, true)
  };
  if (header.magic !== BINARY_HEADER_MAGIC) {
    throw new Error("Unsupported glTF-Binary header.");
  } else if (header.version < 2) {
    throw new Error("Unsupported legacy gltf file detected.");
  }
  let json;
  let buffer;
  const chunkView = new DataView(data, BINARY_HEADER_LENGTH);
  let chunkIndex = 0;
  while (chunkIndex < chunkView.byteLength) {
    const chunkLength = chunkView.getUint32(chunkIndex, true);
    chunkIndex += 4;
    const chunkType = chunkView.getUint32(chunkIndex, true);
    chunkIndex += 4;
    if (chunkType === BINARY_CHUNK_TYPES.JSON) {
      const contentArray = new Uint8Array(data, BINARY_HEADER_LENGTH + chunkIndex, chunkLength);
      json = decoder.decode(contentArray);
      json = json.substring(0, json.lastIndexOf("}") + 1);
    } else if (chunkType === BINARY_CHUNK_TYPES.BIN) {
      const contentArray = new Uint8Array(data, BINARY_HEADER_LENGTH + chunkIndex, chunkLength);
      const binaryChunk = new Uint8Array(chunkLength);
      binaryChunk.set(contentArray);
      buffer = binaryChunk.buffer;
    }
    chunkIndex += chunkLength;
  }
  if (!json) {
    throw new Error("glTF-Binary: JSON content not found.");
  }
  if (!buffer) {
    throw new Error("glTF-Binary: Binary chunk not found.");
  }
  return { json, buffer };
}
async function loadData(url, abortController) {
  const path = url.pathname.toLowerCase();
  let gltf;
  let buffers;
  if (path.endsWith(".gltf")) {
    gltf = await downloadJson(url);
    const bufferPromises = (gltf.buffers ?? []).map(async (buf) => {
      const bufferUrl = new URL(buf.uri, url);
      if (!bufferUrl.search)
        bufferUrl.search = url.search ?? "";
      return downloadArrayBuffer(bufferUrl, abortController);
    });
    buffers = await Promise.all(bufferPromises);
  } else if (path.endsWith(".glb")) {
    const glb = await downloadArrayBuffer(url, abortController);
    const { json, buffer } = parseGLB(glb);
    gltf = JSON.parse(json);
    buffers = [buffer];
  } else {
    throw new Error(`Unknown GLTF file extension: "${url}"!`);
  }
  const imageBlobPromises = gltf.images?.map((img) => {
    if (img.uri) {
      const imageUrl = new URL(img.uri, url);
      return downloadBlob(imageUrl, abortController);
    }
  }) ?? [];
  const externalImageBlobs = await Promise.all(imageBlobPromises);
  return { gltf, buffers, externalImageBlobs };
}

// /projects/Novorender/ts/dist/core3d/gltf/parser.ts
function decomposeMatrix(transform) {
  const [sx, sy, sz] = mat4_exports.getScaling(vec3_exports.create(), transform);
  let scale7 = (sx + sy + sz) / 3;
  const epsilon = 1e-5;
  if (scale7 > 1 - epsilon && scale7 < 1 + epsilon) {
    scale7 = void 0;
  }
  const rotation = quat_exports.fromMat3(quat_exports.create(), mat3_exports.fromMat4(mat3_exports.create(), transform));
  const position = vec3_exports.fromValues(transform[12], transform[13], transform[14]);
  return { rotation, position, scale: scale7 };
}
function getTransform(node) {
  const { matrix, translation, rotation, scale: scale7 } = node;
  const transform = mat4_exports.create();
  if (matrix) {
    mat4_exports.set(transform, ...matrix);
  } else if (translation || rotation) {
    const t = translation ? vec3_exports.fromValues(...translation) : vec3_exports.create();
    const r = rotation ? quat_exports.fromValues(...rotation) : quat_exports.create();
    const s = scale7 ? vec3_exports.fromValues(...rotation) : vec3_exports.fromValues(1, 1, 1);
    mat4_exports.fromRotationTranslationScale(transform, r, t, s);
  }
  return transform;
}
async function parseGLTF(buffers, gltf, externalImageBlobs, baseObjectId) {
  const { extensionsRequired, extensionsUsed } = gltf;
  if (extensionsUsed && extensionsUsed.length != 0 && extensionsUsed[0] != "KHR_materials_unlit") {
    console.warn(`The following glTF extensions were used, but are not supported: ${extensionsUsed.join(", ")}!`);
  }
  if (extensionsRequired && extensionsRequired.length != 0 && extensionsRequired[0] != "KHR_materials_unlit") {
    throw new Error(`The following glTF extensions were required, but are not supported: ${extensionsRequired.join(", ")}!`);
  }
  const filters = {
    [9728 /* NEAREST */]: "NEAREST",
    [9729 /* LINEAR */]: "LINEAR",
    [9984 /* NEAREST_MIPMAP_NEAREST */]: "NEAREST_MIPMAP_NEAREST",
    [9985 /* LINEAR_MIPMAP_NEAREST */]: "LINEAR_MIPMAP_NEAREST",
    [9986 /* NEAREST_MIPMAP_LINEAR */]: "NEAREST_MIPMAP_LINEAR",
    [9987 /* LINEAR_MIPMAP_LINEAR */]: "LINEAR_MIPMAP_LINEAR"
  };
  const wrappings = {
    [33071 /* CLAMP_TO_EDGE */]: "CLAMP_TO_EDGE",
    [33648 /* MIRRORED_REPEAT */]: "MIRRORED_REPEAT",
    [10497 /* REPEAT */]: "REPEAT"
  };
  const attributeNames = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "texCoord0",
    TEXCOORD_1: "texCoord1",
    COLOR_0: "color0"
  };
  const attributeCompontentTypes = {
    [5126 /* FLOAT */]: "FLOAT",
    [5120 /* BYTE */]: "BYTE",
    [5122 /* SHORT */]: "SHORT",
    [5124 /* INT */]: "INT",
    [5121 /* UNSIGNED_BYTE */]: "UNSIGNED_BYTE",
    [5123 /* UNSIGNED_SHORT */]: "UNSIGNED_SHORT",
    [5125 /* UNSIGNED_INT */]: "UNSIGNED_INT"
  };
  const attributeComponentCounts = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4
  };
  const attributeCompontentTypePrefixes = {
    [5126 /* FLOAT */]: "FLOAT",
    [5120 /* BYTE */]: "INT",
    [5122 /* SHORT */]: "INT",
    [5124 /* INT */]: "INT",
    [5121 /* UNSIGNED_BYTE */]: "UNSIGNED_INT",
    [5123 /* UNSIGNED_SHORT */]: "UNSIGNED_INT",
    [5125 /* UNSIGNED_INT */]: "UNSIGNED_INT"
  };
  const topologies = {
    [0 /* POINTS */]: "POINTS",
    [1 /* LINES */]: "LINES",
    [2 /* LINE_LOOP */]: "LINE_LOOP",
    [3 /* LINE_STRIP */]: "LINE_STRIP",
    [4 /* TRIANGLES */]: "TRIANGLES",
    [5 /* TRIANGLE_STRIP */]: "TRIANGLE_STRIP",
    [6 /* TRIANGLE_FAN */]: "TRIANGLE_FAN"
  };
  const bufferTypes = {
    [5121 /* UNSIGNED_BYTE */]: Uint8Array,
    [5123 /* UNSIGNED_SHORT */]: Uint16Array,
    [5125 /* UNSIGNED_INT */]: Uint32Array,
    [5120 /* BYTE */]: Int8Array,
    [5122 /* SHORT */]: Int16Array,
    [5124 /* INT */]: Int32Array,
    [5126 /* FLOAT */]: Float32Array
  };
  const bufferViews = gltf.bufferViews.map((v) => {
    return new Uint8Array(buffers[v.buffer], v.byteOffset, v.byteLength);
  });
  function getImageBlob(image) {
    const bufferView = gltf.bufferViews[image.bufferView];
    const begin = bufferView.byteOffset ?? 0;
    const end = bufferView.byteLength ? begin + bufferView.byteLength : void 0;
    const buffer = buffers[bufferView.buffer].slice(begin, end);
    return new Blob([buffer]);
  }
  const imagePromises = gltf.images?.map(async (img, idx) => {
    let blob = externalImageBlobs[idx] ?? getImageBlob(img);
    if (img.mimeType) {
      blob = new Blob([blob], { type: img.mimeType });
    }
    const image = await createImageBitmap(blob, { colorSpaceConversion: "none" });
    const { width, height } = image;
    const params = { kind: "TEXTURE_2D", width, height, generateMipMaps: true, internalFormat: "RGBA8", type: "UNSIGNED_BYTE", image };
    return { params };
  }) ?? [];
  const images = await Promise.all(imagePromises);
  const samplers = gltf.samplers?.map((s) => {
    const { magFilter, minFilter, wrapS, wrapT } = s;
    const minificationFilter = filters[minFilter ?? 9987 /* LINEAR_MIPMAP_LINEAR */];
    const magnificationFilter = filters[magFilter ?? 9729 /* LINEAR */];
    const wrap2 = wrapS && wrapT ? [wrappings[wrapS], wrappings[wrapT]] : ["REPEAT", "REPEAT"];
    return { minificationFilter, magnificationFilter, wrap: wrap2 };
  }) ?? [];
  const textures = gltf.textures?.map((t) => {
    const image = images[t.source];
    const sampler = samplers[t.sampler];
    return { image, sampler };
  }) ?? [];
  const defaultGGXMaterial = { kind: "ggx" };
  const defaultUnlitMaterial = { kind: "unlit" };
  const materials = gltf.materials?.map((m, i) => {
    const isUnlit = m.extensions && "KHR_materials_unlit" in m.extensions;
    const { pbrMetallicRoughness, normalTexture, occlusionTexture, emissiveTexture, emissiveFactor, alphaMode, alphaCutoff, doubleSided } = m;
    function getTexInfo(texInfo) {
      if (texInfo) {
        const transform = void 0;
        if ("scale" in texInfo) {
          return {
            texture: textures[texInfo.index] ?? null,
            texCoord: texInfo.texCoord,
            scale: texInfo.scale,
            transform
          };
        } else if ("strength" in texInfo) {
          return {
            texture: textures[texInfo.index] ?? null,
            texCoord: texInfo.texCoord,
            strength: texInfo.strength,
            transform
          };
        }
        return {
          texture: textures[texInfo.index] ?? null,
          texCoord: texInfo.texCoord,
          transform
        };
      }
    }
    if (isUnlit) {
      return {
        kind: "unlit",
        doubleSided,
        alphaMode,
        alphaCutoff,
        baseColorFactor: pbrMetallicRoughness?.baseColorFactor,
        baseColorTexture: getTexInfo(pbrMetallicRoughness?.baseColorTexture)
      };
    } else {
      return {
        kind: "ggx",
        doubleSided,
        alphaMode,
        alphaCutoff,
        baseColorFactor: pbrMetallicRoughness?.baseColorFactor,
        metallicFactor: pbrMetallicRoughness?.metallicFactor,
        roughnessFactor: pbrMetallicRoughness?.roughnessFactor,
        emissiveFactor,
        baseColorTexture: getTexInfo(pbrMetallicRoughness?.baseColorTexture),
        metallicRoughnessTexture: getTexInfo(pbrMetallicRoughness?.metallicRoughnessTexture),
        normalTexture: getTexInfo(normalTexture),
        occlusionTexture: getTexInfo(occlusionTexture),
        emissiveTexture: getTexInfo(emissiveTexture)
      };
    }
  }) ?? [];
  const meshes = gltf.meshes?.map((m) => {
    const primitives = m.primitives.map((p) => {
      const attributes = {};
      for (const [key, value] of Object.entries(p.attributes)) {
        const name = attributeNames[key];
        const accessor = gltf.accessors[value];
        console.assert(!accessor.sparse);
        const bufferView = gltf.bufferViews[accessor.bufferView];
        const buffer = bufferViews[accessor.bufferView];
        const componentType = accessor.componentType;
        const prefix = attributeCompontentTypePrefixes[componentType];
        const type = accessor.type;
        const kind = accessor.type == "SCALAR" ? prefix : `${prefix}_${type}`;
        const attrib = {
          kind,
          buffer,
          componentType: attributeCompontentTypes[componentType],
          componentCount: attributeComponentCounts[type],
          normalized: accessor.normalized ?? false,
          byteStride: bufferView.byteStride ?? 0,
          byteOffset: accessor.byteOffset ?? 0
        };
        Reflect.set(attributes, name, attrib);
      }
      ;
      const indicesAccessor = p.indices != void 0 ? gltf.accessors[p.indices] : void 0;
      const count = indicesAccessor ? indicesAccessor.count : gltf.accessors[p.attributes["POSITION"]].count;
      const ib = bufferViews[indicesAccessor?.bufferView ?? -1];
      const IndexBufferType = indicesAccessor ? bufferTypes[indicesAccessor.componentType] : void 0;
      const indices = IndexBufferType ? new IndexBufferType(ib.buffer, ib.byteOffset + (indicesAccessor.byteOffset ?? 0), indicesAccessor.count) : count;
      const mode = topologies[p.mode] ?? "TRIANGLES";
      const geometry = {
        primitiveType: mode,
        attributes,
        indices
      };
      const defaultMaterial2 = (p.mode ?? 4) < 4 ? defaultUnlitMaterial : defaultGGXMaterial;
      const material = materials[p.material ?? -1] ?? defaultMaterial2;
      return { geometry, material };
    });
    return { primitives };
  }) ?? [];
  const objects = [];
  if (gltf.scenes && gltf.nodes) {
    const rootNodes = gltf.scenes[gltf.scene ?? 0].nodes;
    if (rootNodes) {
      let traverseNodeTree2 = function(nodeIndex, parentTransform) {
        const node = gltf.nodes[nodeIndex];
        const transform = getTransform(node);
        if (parentTransform) {
          mat4_exports.multiply(transform, parentTransform, transform);
        }
        if (node.mesh != void 0) {
          mat4_exports.rotateX(transform, transform, common_exports.toRadian(90));
          const instance = decomposeMatrix(transform);
          const mesh = meshes[node.mesh];
          const obj = { instances: [instance], mesh, baseObjectId };
          objects.push(obj);
        }
        if (node.children) {
          for (const child of node.children) {
            traverseNodeTree2(child, transform);
          }
        }
      };
      var traverseNodeTree = traverseNodeTree2;
      for (const rootNodeIndex of rootNodes) {
        traverseNodeTree2(rootNodeIndex);
      }
    }
  }
  return objects;
}

// /projects/Novorender/ts/dist/core3d/gltf/index.ts
async function downloadGLTF(url, baseObjectId, abortController) {
  const { gltf, buffers, externalImageBlobs } = await loadData(url, abortController);
  return parseGLTF(buffers, gltf, externalImageBlobs, baseObjectId);
}

// /projects/Novorender/ts/dist/offline/storage.ts
var RequestFormatter = class {
  constructor(baseUrl, parser, formatter, mode) {
    this.baseUrl = baseUrl;
    this.parser = parser;
    this.formatter = formatter;
    this.mode = mode;
  }
  /**
   * 
   * @param dir The storage directory name.
   * @param file The storage file name.
   * @param signal A signal for aborting the request.
   * @param applyQuery Whether or not to apply query string to request url.
   * @returns A Request to feed to fetch() API and/or to match against cache entries.
   */
  request(dir, file, query, signal) {
    const { baseUrl, formatter, mode } = this;
    const url = new URL(formatter(dir, file), baseUrl);
    if (query)
      url.search = query;
    return new Request(url, { mode, signal });
  }
  /**
  * Decode request into directory and file name.
  * @param request A request generated from the {@link request} function.
  * @returns Request directory and file name, if url matches asset pattern, undefined otherwise.
  */
  tryDecode(request2) {
    const { parser } = this;
    const { pathname } = new URL(request2.url);
    return parser(pathname);
  }
  /**
   * Decode request into directory and file name.
   * @param request A request generated from the {@link request} function.
   * @returns Request directory and file name.
   */
  decode(request2) {
    const result = this.tryDecode(request2);
    if (!result)
      throw new Error("Request does not match valid pattern!");
    return result;
  }
};

// /projects/Novorender/ts/dist/offline/cache.ts
async function createCacheStorage(version3, requestFormatter) {
  const storage = new OfflineStorageCache(version3, requestFormatter);
  await storage.init();
  return storage;
}
var cacheQueryOptions = {
  ignoreSearch: true
  // SAS key will change over time, so ignore
};
var OfflineStorageCache = class {
  constructor(version3, requestFormatter) {
    this.version = version3;
    this.requestFormatter = requestFormatter;
  }
  dirs = /* @__PURE__ */ new Map();
  get prefix() {
    return `${this.version}_`;
  }
  cacheName(dirName) {
    return `${this.prefix}${dirName}`;
  }
  // initialize existing directories from storage
  async init() {
    const { prefix, dirs } = this;
    var keys = await caches.keys();
    for (const key of keys) {
      if (key.startsWith(prefix)) {
        const name = key.slice(prefix.length);
        const cache = await caches.open(key);
        const dir = new OfflineDirectoryCache(this, cache, name);
        dirs.set(name, dir);
      }
    }
  }
  isAsset(request2) {
    return this.requestFormatter.tryDecode(request2) != void 0;
  }
  async fetch(request2) {
    return await caches.match(request2, cacheQueryOptions);
  }
  get existingDirectories() {
    return this.dirs.values();
  }
  hasDirectory(name) {
    return this.dirs.has(name);
  }
  async directory(name) {
    const { dirs } = this;
    let dir = dirs.get(name);
    if (!dir) {
      dir = await this.addDirectory(name);
      dirs.set(name, dir);
    }
    return dir;
  }
  async addDirectory(name) {
    const cacheName = this.cacheName(name);
    const cache = await caches.open(cacheName);
    const dir = new OfflineDirectoryCache(this, cache, name);
    return dir;
  }
  async deleteAll() {
    for (const key of await caches.keys()) {
      await caches.delete(key);
    }
    this.dirs.clear();
  }
};
var OfflineDirectoryCache = class {
  constructor(context, cache, name) {
    this.context = context;
    this.cache = cache;
    this.name = name;
  }
  request(name) {
    const { context } = this;
    const { requestFormatter } = context;
    return requestFormatter.request(this.name, name);
  }
  async *files() {
    const { context, cache } = this;
    const { requestFormatter } = context;
    const requests = await cache.keys(void 0, cacheQueryOptions);
    for await (const request2 of requests) {
      const { file } = requestFormatter.decode(request2);
      yield file;
    }
  }
  // async size(name: string) {
  //     const { cache } = this;
  //     const request = this.request(name);
  //     const response = await cache.match(request, cacheQueryOptions);
  //     if (response?.ok) {
  //         const contentLength = response.headers.get("Content-Length");
  //         if (contentLength != undefined) {
  //             const size = Number.parseInt(contentLength);
  //             if (!Number.isNaN(size)) {
  //                 return size;
  //             }
  //         }
  //     }
  //     throw new Error(`No valid cache entry found for "${name}"!`);
  // }
  async get(name) {
    const { cache } = this;
    const request2 = this.request(name);
    const response = await cache.match(request2, cacheQueryOptions);
    if (response?.ok) {
      return response;
    }
  }
  // async open(name: string): Promise<ReadableStream | undefined> {
  //     const response = await this.get(name);
  //     return response?.body!;
  // }
  async read(name) {
    const response = await this.get(name);
    return response?.arrayBuffer();
  }
  async write(name, buffer) {
    const { cache } = this;
    const request2 = this.request(name);
    const init2 = {
      status: 200,
      headers: {
        "Content-Length": buffer.byteLength.toString()
      }
    };
    const response = new Response(buffer, init2);
    await cache.put(request2, response);
  }
  async deleteFiles(names) {
    const { cache } = this;
    for (const name of names) {
      const request2 = this.request(name);
      const success = await cache.delete(request2, cacheQueryOptions);
      if (!success) {
        console.warn(`Failed to delete ${name} from cache!`);
      }
    }
  }
  async delete() {
    const { context, name } = this;
    const { version: version3 } = context;
    const key = `${name}_${version3}`;
    const result = await caches.delete(key);
    console.assert(result);
  }
};

// /projects/Novorender/ts/dist/offline/opfs/promiseBag.ts
var PromiseBag = class {
  promises = /* @__PURE__ */ new Map();
  currentId = 0;
  newId() {
    const id = this.currentId++;
    this.currentId &= 65535;
    return id;
  }
  create(id) {
    return new Promise((resolve) => {
      this.promises.set(id, { resolve });
    });
  }
  resolve(id, result) {
    const { promises } = this;
    const pendingPromise = promises.get(id);
    if (pendingPromise) {
      promises.delete(id);
      const { resolve } = pendingPromise;
      resolve(result);
    }
  }
};

// /projects/Novorender/ts/dist/offline/opfs/index.ts
async function createOPFSStorage(version3, requestFormatter, worker) {
  const storage = new OfflineStorageOPFS(version3, requestFormatter, worker);
  await storage.init();
  return storage;
}
var OfflineStorageOPFS = class {
  constructor(version3, requestFormatter, worker) {
    this.version = version3;
    this.requestFormatter = requestFormatter;
    this.worker = worker;
    worker.onmessage = (message) => {
      const { data } = message;
      this.promises.resolve(data.id, data);
    };
  }
  promises = new PromiseBag();
  dirs = /* @__PURE__ */ new Map();
  // initialize existing directories from storage
  async init() {
    const { worker, promises, dirs } = this;
    const id = promises.newId();
    const msg = { kind: "dirs", id };
    worker.postMessage(msg);
    const response = await promises.create(id);
    if (response.error) {
      throw new Error(response.error);
    }
    for (const name of response.dirs) {
      const dir = new OfflineDirectoryOPFS(this, name);
      dirs.set(name, dir);
    }
  }
  isAsset(request2) {
    return this.requestFormatter.tryDecode(request2) != void 0;
  }
  async fetch(request2) {
    const { worker, requestFormatter, promises } = this;
    const { dir, file } = requestFormatter.decode(request2);
    const id = promises.newId();
    const msg = { kind: "read", id, dir, file };
    worker.postMessage(msg);
    const response = await promises.create(id);
    if (!response.error && response.buffer) {
      return new Response(response.buffer, { status: 200, headers: { "Content-Type": "application/octet-stream", "Content-Length": `${response.buffer.byteLength}` } });
    }
  }
  get existingDirectories() {
    return this.dirs.values();
  }
  hasDirectory(name) {
    return this.dirs.has(name);
  }
  async directory(name) {
    const { dirs } = this;
    let dir = dirs.get(name);
    if (!dir) {
      dir = await this.addDirectory(name);
      dirs.set(name, dir);
    }
    return dir;
  }
  async addDirectory(name) {
    const { worker, promises } = this;
    const id = promises.newId();
    const msg = { kind: "create_dir", id, dir: name };
    worker.postMessage(msg);
    const response = await promises.create(id);
    if (response.error) {
      throw new Error(response.error);
    }
    return new OfflineDirectoryOPFS(this, name);
  }
  async deleteAll() {
    const { worker, promises } = this;
    const id = promises.newId();
    const msg = { kind: "delete_all", id };
    worker.postMessage(msg);
    const response = await promises.create(id);
    if (response.error) {
      throw new Error(response.error);
    }
    this.dirs.clear();
  }
};
var OfflineDirectoryOPFS = class {
  constructor(context, name) {
    this.context = context;
    this.name = name;
  }
  request(name) {
    const { context } = this;
    const { requestFormatter } = context;
    return requestFormatter.request(this.name, name);
  }
  async *files() {
    const { context, name } = this;
    const { worker, promises } = context;
    const id = promises.newId();
    const msg = { kind: "files", id, dir: name };
    worker.postMessage(msg);
    const response = await promises.create(id);
    if (response.error) {
      throw new Error(response.error);
    }
    for (const file of response.files) {
      yield file;
    }
  }
  async read(name) {
    const { context } = this;
    const { worker, promises } = context;
    const id = promises.newId();
    const msg = { kind: "read", id, dir: this.name, file: name };
    worker.postMessage(msg);
    const response = await promises.create(id);
    if (response.error) {
      console.warn(response.error);
    }
    return response.buffer;
  }
  async write(name, buffer) {
    const { context } = this;
    const { worker, promises } = context;
    const id = promises.newId();
    const msg = { kind: "write", id, dir: this.name, file: name, buffer };
    worker.postMessage(msg, [buffer]);
    const response = await promises.create(id);
    if (response.error) {
      throw new Error(response.error);
    }
  }
  async deleteFiles(names) {
    const { context } = this;
    const { worker, promises } = context;
    const id = promises.newId();
    const msg = { kind: "delete_files", id, dir: this.name, files: [...names] };
    worker.postMessage(msg);
    const response = await promises.create(id);
    if (response.error) {
      throw new Error(response.error);
    }
  }
  async delete() {
    const { context } = this;
    const { worker, promises } = context;
    const id = promises.newId();
    const msg = { kind: "delete_dir", id, dir: this.name };
    worker.postMessage(msg);
    context.dirs.delete(this.name);
    const response = await promises.create(id);
    if (response.error) {
      throw new Error(response.error);
    }
  }
};

// /projects/Novorender/ts/dist/offline/manifest.ts
var SceneManifest = class {
  /** A map of manifest filenames and their respective byte sizes. */
  _files = /* @__PURE__ */ new Map();
  // The manifest file entries.
  get files() {
    return this._files.entries();
  }
  /** The total byte size of all the files in this manifest. */
  totalByteSize;
  /** The number of files. */
  numFiles;
  /**
   * @param data The entries of this manifest.
   */
  constructor(data) {
    const { _files } = this;
    let totalByteSize = 0;
    let numFiles = 0;
    for (const [name, size] of data) {
      _files.set(name, size);
      totalByteSize += size;
      numFiles++;
    }
    this.totalByteSize = totalByteSize;
    this.numFiles = numFiles;
  }
};
async function readManifest(dir) {
  let data = [];
  const buffer = await dir.read("manifest.json");
  if (buffer) {
    const json = new TextDecoder().decode(buffer);
    data = JSON.parse(json);
  }
  return new SceneManifest(data);
}

// /projects/Novorender/ts/dist/offline/util.ts
function defaultRequestFormatter() {
  const re = /^\/(?<dir>[0-9a-f]{32})\/webgl2_bin\/(?<file>.+)$/;
  const parser = (str7) => str7.match(re)?.groups;
  const formatter = (dir, file) => `/${dir}/webgl2_bin/${file}`;
  const baseUrl = new URL("https://blobs.novorender.com/");
  return new RequestFormatter(baseUrl, parser, formatter, "cors");
}
function errorMessage(value) {
  function isError(value2) {
    return value2 && "message" in value2;
  }
  return isError(value) ? value.message : typeof value == "string" ? value : value.toString();
}

// /projects/Novorender/ts/dist/offline/scene.ts
var OfflineScene = class {
  constructor(context, dir, manifest) {
    this.context = context;
    this.dir = dir;
    this.manifest = manifest;
  }
  /** Logger for errors and status updates. */
  logger;
  /** The scene id. */
  get id() {
    return this.dir.name;
  }
  /** Delete all downloaded files for this scene and remove it from the context's list of offline scenes. */
  async delete() {
    const { dir, context, logger } = this;
    const { scenes } = context;
    const { name } = dir;
    logger?.status("deleting");
    await dir.delete();
    scenes.delete(name);
    context.logger?.status("scene deleted");
    return;
  }
  /**
   * Incrementally synchronize scene files with online storage.
   * @param abortSignal A signal to abort downloads/synchronization.
   * @returns True, if completed successfully, false if not.
   * @remarks
   * Synchronization may be resumed after an abort/failure.
   * It compares the file manifest of local files with the online version and downloads only the difference.
   * Errors are logged in the {@link logger}.
   */
  async sync(abortSignal, sasKey) {
    const { dir, manifest, logger, context } = this;
    const { requestFormatter } = context.storage;
    if (!navigator.onLine) {
      logger?.status("offline");
      logger?.error("You must be online to synchronize files!");
      return false;
    }
    const existingFiles = new Map(manifest.files);
    async function scanFiles() {
      const files = dir.files();
      for await (const filename of files) {
        if (!filename.endsWith(".json")) {
          existingFiles.set(filename, 0);
        }
      }
    }
    ;
    const scanFilesPromise = scanFiles();
    await scanFilesPromise;
    try {
      logger?.status("synchronizing");
      logger?.info?.("fetching manifest");
      const manifestRequest = requestFormatter.request(dir.name, "manifest.json", sasKey, abortSignal);
      const manifestResponse = await fetch(manifestRequest);
      if (!manifestResponse.ok) {
        throw new Error(manifestResponse.statusText);
      }
      const manifestData = await manifestResponse.json();
      if (abortSignal.aborted) {
        logger?.status("aborted");
        return false;
      }
      const onlineManifest = new SceneManifest(manifestData);
      const { totalByteSize } = onlineManifest;
      const debounce = debouncer();
      logger?.info?.("fetching new files");
      let totalDownload = 0;
      logger?.progress?.(totalDownload, totalByteSize);
      const maxSimulataneousDownloads = 8;
      const downloadQueue = new Array(maxSimulataneousDownloads);
      for (const [name, size] of onlineManifest.files) {
        if (!existingFiles.has(name)) {
          const fileRequest = requestFormatter.request(dir.name, name, sasKey, abortSignal);
          let idx = downloadQueue.findIndex((e) => !e);
          if (idx < 0) {
            await Promise.race(downloadQueue);
            idx = downloadQueue.findIndex((e) => !e);
            console.assert(idx >= 0);
          }
          const downloadPromise = download3();
          downloadQueue[idx] = downloadPromise;
          downloadPromise.finally(() => {
            downloadQueue[idx] = void 0;
          });
          async function download3() {
            let fileResponse = await fetch(fileRequest);
            if (fileResponse.ok) {
              const buffer = await fileResponse.arrayBuffer();
              await dir.write(name, buffer);
              totalDownload += size;
            } else {
              throw new Error(`Could not fetch ${name}!`);
            }
          }
        } else {
          totalDownload += size;
        }
        if (debounce(100)) {
          logger?.progress?.(totalDownload, totalByteSize);
        }
      }
      await Promise.all(downloadQueue);
      logger?.progress?.(void 0, void 0);
      const manifestBuffer = new TextEncoder().encode(JSON.stringify(manifestData)).buffer;
      await dir.write("manifest.json", manifestBuffer);
      this.manifest = onlineManifest;
      logger?.info?.("cleanup");
      for (const [name] of onlineManifest.files) {
        existingFiles.delete(name);
      }
      await dir.deleteFiles(existingFiles.keys());
      logger?.status("synchronized");
      return true;
    } catch (error) {
      if (typeof error == "object" && error instanceof DOMException && error.code == DOMException.ABORT_ERR) {
        logger?.status("aborted");
      } else {
        logger?.status("error");
        logger?.error(errorMessage(error));
      }
      return false;
    }
  }
};
function debouncer() {
  let prevTime = performance.now();
  return function(minInterval) {
    const now = performance.now();
    if (now - prevTime > minInterval) {
      prevTime = now;
      return true;
    } else {
      return false;
    }
  };
}

// /projects/Novorender/ts/dist/offline/state.ts
async function createOfflineViewState(storage) {
  const storageEstimate = "estimate" in navigator.storage ? await navigator.storage.estimate() : void 0;
  const context = new OfflineViewState(storage, storageEstimate);
  const { scenes } = context;
  for (const dir of storage.existingDirectories) {
    const manifest = await readManifest(dir);
    const scene = new OfflineScene(context, dir, manifest);
    scenes.set(dir.name, scene);
  }
  return context;
}
var OfflineViewState = class {
  constructor(storage, initialStorageEstimate) {
    this.storage = storage;
    this.initialStorageEstimate = initialStorageEstimate;
  }
  /** Map of active offline scenes */
  scenes = /* @__PURE__ */ new Map();
  /** Logger for errors and status updates. */
  logger;
  /**
   * Add a new scene to offline storage.
   * @param id: The scene id.
   * @returns The offline scene, or undefined if error.
   * @remarks
   * This function will merely mark the scene as an offline candidate.
   * You need to call {@link OfflineScene.sync} for the scene to be downloaded and ready for offline use.
   * Errors are logged in the {@link logger}.
   */
  async addScene(id) {
    const { storage, scenes, logger } = this;
    if (scenes.has(id)) {
      logger?.error("scene already added");
    }
    try {
      logger?.status("adding scene");
      const manifest = new SceneManifest([]);
      const dir = await storage.directory(id);
      try {
        const scene = new OfflineScene(this, dir, manifest);
        scenes.set(id, scene);
        logger?.status("scene added");
        return scene;
      } catch (error) {
        dir.delete();
        throw error;
      }
    } catch (error) {
      logger?.error(errorMessage(error));
    }
  }
  /**
   * Delete all offline data and remove every offline scene.
   * @returns True if success, False if an error occurred.
   * @remarks
   * Errors are logged in the {@link logger}.
   */
  async deleteAll() {
    const { logger, storage, scenes } = this;
    try {
      logger?.status("clearing cache");
      storage.deleteAll();
      scenes.clear();
      logger?.status("cache cleared");
      return true;
    } catch (error) {
      logger?.error(errorMessage(error));
      return false;
    }
  }
};

// /projects/Novorender/ts/dist/offline/serviceWorker/index.ts
async function serviceWorkerHandleMessage(event) {
  const { source, data } = event;
  switch (data.kind) {
    case "connect": {
      const { port } = data;
      const storage = port ? await createOPFSOfflineStorage(port) : await createCacheOfflineStorage();
      if (source && source instanceof Client) {
        console.log(`Client ${source.id} connected to service worker!`);
        const clientId = source.id;
        clientStorages.set(clientId, storage);
        navigator.locks.request(clientId, {}, (lock) => {
          console.log(`Client ${clientId} disconnected from service worker!`);
          clientStorages.set(clientId, null);
        });
        const client = await clients.get(clientId);
        client?.postMessage({ kind: "connected" });
      }
      break;
    }
  }
}
async function serviceWorkerFetch(request2, clientId, cacheName) {
  const storage = getStorage(clientId);
  let response;
  if (storage) {
    response = await fetchFromStorage(request2, storage);
  }
  if (!response) {
    response = await fetchFromCache(request2, cacheName);
  }
  if (!response.ok) {
    console.warn(`HTTP error: ${response.status}, ${response.statusText}`);
  }
  return response;
}
var clientStorages = /* @__PURE__ */ new Map();
async function connectToClient(clientId) {
  const client = await clients.get(clientId);
  if (client) {
    client.postMessage({ kind: "connect", clientId });
  }
}
function getStorage(clientId) {
  let storage = clientStorages.get(clientId);
  if (storage === void 0) {
    storage = null;
    clientStorages.set(clientId, storage);
    connectToClient(clientId);
  }
  return storage;
}
async function fetchFromStorage(request2, storage) {
  let response;
  const entry = storage.requestFormatter.tryDecode(request2);
  if (entry) {
    if (storage.hasDirectory(entry.dir)) {
      response = await storage.fetch(request2) ?? Response.error();
      if (!response.ok) {
        if (navigator.onLine) {
          response = await fetch(request2);
          if (response.ok) {
            const buffer = await response.clone().arrayBuffer();
            if (entry) {
              const { dir, file } = entry;
              (await storage.directory(dir)).write(file, buffer);
            }
          }
        } else {
          console.warn(`failed fetch: ${new URL(request2.url).pathname}`);
        }
      }
    } else {
      response = await fetch(request2);
    }
  }
  return response;
}
async function fetchFromCache(request2, cacheName) {
  let response;
  if (navigator.onLine) {
    response = await fetch(request2);
    const hasQuery = new URL(request2.url).search.length > 0;
    if (response.ok && !hasQuery) {
      const cache = await caches.open(cacheName);
      await cache.put(request2, response.clone());
    }
  } else {
    const cache = await caches.open(cacheName);
    response = await cache.match(request2) ?? Response.error();
  }
  return response;
}

// /projects/Novorender/ts/dist/offline/index.ts
var schemaVersion = "1.0";
async function enableOffline(serviceWorkerUrl, ioWorkerUrl, sasKey) {
  const ioWorker = ioWorkerUrl ? new Worker(ioWorkerUrl, { type: "module", name: "IO" }) : void 0;
  const dispose = await enableServiceWorker(serviceWorkerUrl, ioWorker, sasKey);
  return { ioWorker, dispose };
}
async function enableServiceWorker(serviceWorkerUrl, ioWorker, sasKey) {
  let disable = () => {
  };
  if (serviceWorkerUrl) {
    if ("serviceWorker" in navigator) {
      const { serviceWorker } = navigator;
      const { controller } = serviceWorker;
      if (ioWorker && controller) {
        let disableResolve = void 0;
        let connectedResolve = void 0;
        let disablePromise = new Promise((resolve) => {
          disableResolve = resolve;
        });
        let connectedPromise = new Promise((resolve) => {
          connectedResolve = resolve;
        });
        serviceWorker.onmessage = async (event) => {
          const { data } = event;
          switch (data.kind) {
            case "connect": {
              const { clientId } = data;
              navigator.locks.request(clientId, { ifAvailable: true }, (lock) => {
                if (lock) {
                  const promise = new Promise((resolve) => {
                    disableResolve(resolve);
                  });
                  return promise;
                } else {
                  console.warn(`Could not obtain service worker client lock ${clientId}!`);
                }
              });
              const channel = new MessageChannel();
              const { port1, port2 } = channel;
              ioWorker.postMessage({ kind: "connect", port: port1 }, [port1]);
              controller.postMessage({ kind: "connect", port: port2 }, [port2]);
              break;
            }
            case "connected": {
              connectedResolve();
              break;
            }
          }
        };
        disable = await disablePromise;
        await connectedPromise;
        console.log("Service worker connected!");
      }
      if (navigator.onLine) {
        try {
          await registerServiceWorker(serviceWorkerUrl);
        } catch (error) {
          console.warn(`Service worker registration failed: ${error}`);
        }
      }
    } else {
      console.warn(`Service worker is not supported!`);
    }
  }
  return disable;
}
async function manageOfflineStorage(ioWorker) {
  const storage = ioWorker ? await createOPFSStorage(schemaVersion, defaultRequestFormatter(), ioWorker) : await createCacheStorage(schemaVersion, defaultRequestFormatter());
  const context = await createOfflineViewState(storage);
  return context;
}
async function createCacheOfflineStorage() {
  const storage = await createCacheStorage(schemaVersion, defaultRequestFormatter());
  return storage;
}
async function createOPFSOfflineStorage(worker) {
  const storage = await createOPFSStorage(schemaVersion, defaultRequestFormatter(), worker);
  return storage;
}
async function registerServiceWorker(url) {
  try {
    const registration = await navigator.serviceWorker.register(url, { type: "module", updateViaCache: "none" });
    if (registration.installing) {
    } else if (registration.waiting) {
    }
    return registration;
  } catch (error) {
    console.error(`Registration failed with ${error}`);
  }
}

// /projects/Novorender/ts/node_modules/comlink/dist/esm/comlink.mjs
var proxyMarker = Symbol("Comlink.proxy");
var createEndpoint = Symbol("Comlink.endpoint");
var releaseProxy = Symbol("Comlink.releaseProxy");
var finalizer = Symbol("Comlink.finalizer");
var throwMarker = Symbol("Comlink.thrown");
var isObject = (val) => typeof val === "object" && val !== null || typeof val === "function";
var proxyTransferHandler = {
  canHandle: (val) => isObject(val) && val[proxyMarker],
  serialize(obj) {
    const { port1, port2 } = new MessageChannel();
    expose(obj, port1);
    return [port2, [port2]];
  },
  deserialize(port) {
    port.start();
    return wrap(port);
  }
};
var throwTransferHandler = {
  canHandle: (value) => isObject(value) && throwMarker in value,
  serialize({ value }) {
    let serialized;
    if (value instanceof Error) {
      serialized = {
        isError: true,
        value: {
          message: value.message,
          name: value.name,
          stack: value.stack
        }
      };
    } else {
      serialized = { isError: false, value };
    }
    return [serialized, []];
  },
  deserialize(serialized) {
    if (serialized.isError) {
      throw Object.assign(new Error(serialized.value.message), serialized.value);
    }
    throw serialized.value;
  }
};
var transferHandlers = /* @__PURE__ */ new Map([
  ["proxy", proxyTransferHandler],
  ["throw", throwTransferHandler]
]);
function isAllowedOrigin(allowedOrigins, origin) {
  for (const allowedOrigin of allowedOrigins) {
    if (origin === allowedOrigin || allowedOrigin === "*") {
      return true;
    }
    if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
      return true;
    }
  }
  return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
  ep.addEventListener("message", function callback(ev) {
    if (!ev || !ev.data) {
      return;
    }
    if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
      console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
      return;
    }
    const { id, type, path } = Object.assign({ path: [] }, ev.data);
    const argumentList = (ev.data.argumentList || []).map(fromWireValue);
    let returnValue;
    try {
      const parent = path.slice(0, -1).reduce((obj2, prop) => obj2[prop], obj);
      const rawValue = path.reduce((obj2, prop) => obj2[prop], obj);
      switch (type) {
        case "GET":
          {
            returnValue = rawValue;
          }
          break;
        case "SET":
          {
            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
            returnValue = true;
          }
          break;
        case "APPLY":
          {
            returnValue = rawValue.apply(parent, argumentList);
          }
          break;
        case "CONSTRUCT":
          {
            const value = new rawValue(...argumentList);
            returnValue = proxy(value);
          }
          break;
        case "ENDPOINT":
          {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port2);
            returnValue = transfer(port1, [port1]);
          }
          break;
        case "RELEASE":
          {
            returnValue = void 0;
          }
          break;
        default:
          return;
      }
    } catch (value) {
      returnValue = { value, [throwMarker]: 0 };
    }
    Promise.resolve(returnValue).catch((value) => {
      return { value, [throwMarker]: 0 };
    }).then((returnValue2) => {
      const [wireValue, transferables] = toWireValue(returnValue2);
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
      if (type === "RELEASE") {
        ep.removeEventListener("message", callback);
        closeEndPoint(ep);
        if (finalizer in obj && typeof obj[finalizer] === "function") {
          obj[finalizer]();
        }
      }
    }).catch((error) => {
      const [wireValue, transferables] = toWireValue({
        value: new TypeError("Unserializable return value"),
        [throwMarker]: 0
      });
      ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
    });
  });
  if (ep.start) {
    ep.start();
  }
}
function isMessagePort(endpoint) {
  return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
  if (isMessagePort(endpoint))
    endpoint.close();
}
function wrap(ep, target) {
  return createProxy(ep, [], target);
}
function throwIfProxyReleased(isReleased) {
  if (isReleased) {
    throw new Error("Proxy has been released and is not useable");
  }
}
function releaseEndpoint(ep) {
  return requestResponseMessage(ep, {
    type: "RELEASE"
  }).then(() => {
    closeEndPoint(ep);
  });
}
var proxyCounter = /* @__PURE__ */ new WeakMap();
var proxyFinalizers = "FinalizationRegistry" in globalThis && new FinalizationRegistry((ep) => {
  const newCount = (proxyCounter.get(ep) || 0) - 1;
  proxyCounter.set(ep, newCount);
  if (newCount === 0) {
    releaseEndpoint(ep);
  }
});
function registerProxy(proxy2, ep) {
  const newCount = (proxyCounter.get(ep) || 0) + 1;
  proxyCounter.set(ep, newCount);
  if (proxyFinalizers) {
    proxyFinalizers.register(proxy2, ep, proxy2);
  }
}
function unregisterProxy(proxy2) {
  if (proxyFinalizers) {
    proxyFinalizers.unregister(proxy2);
  }
}
function createProxy(ep, path = [], target = function() {
}) {
  let isProxyReleased = false;
  const proxy2 = new Proxy(target, {
    get(_target, prop) {
      throwIfProxyReleased(isProxyReleased);
      if (prop === releaseProxy) {
        return () => {
          unregisterProxy(proxy2);
          releaseEndpoint(ep);
          isProxyReleased = true;
        };
      }
      if (prop === "then") {
        if (path.length === 0) {
          return { then: () => proxy2 };
        }
        const r = requestResponseMessage(ep, {
          type: "GET",
          path: path.map((p) => p.toString())
        }).then(fromWireValue);
        return r.then.bind(r);
      }
      return createProxy(ep, [...path, prop]);
    },
    set(_target, prop, rawValue) {
      throwIfProxyReleased(isProxyReleased);
      const [value, transferables] = toWireValue(rawValue);
      return requestResponseMessage(ep, {
        type: "SET",
        path: [...path, prop].map((p) => p.toString()),
        value
      }, transferables).then(fromWireValue);
    },
    apply(_target, _thisArg, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const last = path[path.length - 1];
      if (last === createEndpoint) {
        return requestResponseMessage(ep, {
          type: "ENDPOINT"
        }).then(fromWireValue);
      }
      if (last === "bind") {
        return createProxy(ep, path.slice(0, -1));
      }
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "APPLY",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    },
    construct(_target, rawArgumentList) {
      throwIfProxyReleased(isProxyReleased);
      const [argumentList, transferables] = processArguments(rawArgumentList);
      return requestResponseMessage(ep, {
        type: "CONSTRUCT",
        path: path.map((p) => p.toString()),
        argumentList
      }, transferables).then(fromWireValue);
    }
  });
  registerProxy(proxy2, ep);
  return proxy2;
}
function myFlat(arr) {
  return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
  const processed = argumentList.map(toWireValue);
  return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
var transferCache = /* @__PURE__ */ new WeakMap();
function transfer(obj, transfers) {
  transferCache.set(obj, transfers);
  return obj;
}
function proxy(obj) {
  return Object.assign(obj, { [proxyMarker]: true });
}
function toWireValue(value) {
  for (const [name, handler2] of transferHandlers) {
    if (handler2.canHandle(value)) {
      const [serializedValue, transferables] = handler2.serialize(value);
      return [
        {
          type: "HANDLER",
          name,
          value: serializedValue
        },
        transferables
      ];
    }
  }
  return [
    {
      type: "RAW",
      value
    },
    transferCache.get(value) || []
  ];
}
function fromWireValue(value) {
  switch (value.type) {
    case "HANDLER":
      return transferHandlers.get(value.name).deserialize(value.value);
    case "RAW":
      return value.value;
  }
}
function requestResponseMessage(ep, msg, transfers) {
  return new Promise((resolve) => {
    const id = generateUUID();
    ep.addEventListener("message", function l(ev) {
      if (!ev.data || !ev.data.id || ev.data.id !== id) {
        return;
      }
      ep.removeEventListener("message", l);
      resolve(ev.data);
    });
    if (ep.start) {
      ep.start();
    }
    ep.postMessage(Object.assign({ id }, msg), transfers);
  });
}
function generateUUID() {
  return new Array(4).fill(0).map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
}

// /projects/Novorender/ts/dist/measure/modules/base.ts
var BaseModule = class {
  constructor(worker, parent) {
    this.worker = worker;
    this.parent = parent;
  }
};

// /projects/Novorender/ts/dist/measure/modules/collision/module.ts
var CollisionModule = class {
  constructor(worker, parent) {
    this.worker = worker;
    this.parent = parent;
  }
  /** 
   * Returns collision values between 2 entities
   * currently only works for two cylinders
   */
  async collision(a, b, setting) {
    if (a.drawKind == "face" && b.drawKind == "face") {
      const workerScene = await this.worker;
      return await workerScene.faceToFaceCollision(
        a.ObjectId,
        a.pathIndex,
        a.instanceIndex,
        b.ObjectId,
        b.pathIndex,
        b.instanceIndex,
        setting
      );
    }
    return void 0;
  }
};

// /projects/Novorender/ts/dist/measure/calculations_2d.ts
function lineSegmentIntersection(lineA, lineB) {
  const dirA = vec2_exports.sub(vec2_exports.create(), lineA.end, lineA.start);
  const dirB = vec2_exports.sub(vec2_exports.create(), lineB.end, lineB.start);
  const axb = dirA[0] * dirB[1] - dirA[1] * dirB[0];
  const startDir = vec2_exports.sub(vec2_exports.create(), lineB.start, lineA.start);
  if (axb == 0) {
    return void 0;
  }
  const t = (startDir[0] * dirB[1] - startDir[1] * dirB[0]) / axb;
  const u = (startDir[0] * dirA[1] - startDir[1] * dirA[0]) / axb;
  if (0 <= t && t <= 1 && (0 <= u && u <= 1)) {
    return {
      p: vec2_exports.scaleAndAdd(vec2_exports.create(), lineA.start, dirA, t),
      t,
      u
    };
  }
  return void 0;
}

// /projects/Novorender/ts/dist/measure/modules/draw/module.ts
var SCREEN_SPACE_EPSILON = 1e-6;
var DrawModule = class extends BaseModule {
  constructor(worker, parent, drawContext) {
    super(worker, parent);
    this.worker = worker;
    this.parent = parent;
    this.drawContext = drawContext;
  }
  /** @ignore */
  async getEntitiyObjects(entity, setting) {
    const workerScene = await this.worker;
    switch (entity.drawKind) {
      case "edge": {
        const wsVertices = await workerScene.getTesselatedEdge(
          entity.ObjectId,
          entity.pathIndex,
          entity.instanceIndex
        );
        return {
          kind: "edge",
          parts: [{ vertices3D: wsVertices, drawType: "lines" }]
        };
      }
      case "face": {
        const drawObjects = await workerScene.getFaceDrawObject(
          entity.ObjectId,
          entity.pathIndex,
          entity.instanceIndex,
          setting
        );
        return drawObjects;
      }
      case "vertex": {
        return {
          kind: "vertex",
          parts: [{ vertices3D: [entity.parameter], drawType: "vertex" }]
        };
      }
      case "curveSegment": {
        const wsVertices = await workerScene.tesselateCurveSegment(
          entity.ObjectId,
          entity.pathIndex,
          entity.instanceIndex
        );
        return {
          kind: "curveSegment",
          parts: [{ vertices3D: wsVertices, drawType: "lines" }]
        };
      }
    }
  }
  /** 
   * Updates the input draw objects with new 2d info based on camera properties
   * @param drawProduct The product that will be updated based on current camera.
   * @returns Corresponding 3D position at the view plane in world space, or undefined if there is no active render context.
   */
  updateProuct(drawProduct) {
    FillDrawInfo2D(this.drawContext, drawProduct.objects);
  }
  /** Converts world space lines to on screen space lines 
   * @param points World space points that will be projected to screen space
   * @returns Screen space points, a path that will cut to the edge of the screen, 
   * points2d, all the points in 2d space regadless if they are within the current canvas size
   * and the original points removed from screen points
   */
  toScreenSpace(points) {
    const { drawContext } = this;
    const { width, height, camera } = drawContext;
    const { camMat, projMat } = getPathMatrices(width, height, camera);
    return toPathPointsFromMatrices(
      points,
      camMat,
      projMat,
      camera.near,
      width,
      height,
      camera.kind == "orthographic"
    );
  }
  /** Converts world space points to on screen space points
   * @param points World space points that will be projected to screen space
   * @returns Screen space points regadless if they are within the current canvas size
   */
  toMarkerPoints(points) {
    const { drawContext } = this;
    const { width, height, camera } = drawContext;
    const { camMat, projMat } = getPathMatrices(width, height, camera);
    return points.map((p) => vec3_exports.transformMat4(vec3_exports.create(), p, camMat)).map((p, i, arr) => {
      if (camera.kind === "orthographic") {
        if (p[2] > 0 && p[2] < 0.1) {
          p[2] = -1e-4;
        }
      }
      if (p[2] > SCREEN_SPACE_EPSILON) {
        return void 0;
      }
      return toScreen(projMat, width, height, p);
    });
  }
  /** Returns a hierarcical structure of the element, describing how it should be drawn in 2d
   * @param entity the entity that is being drawn to screen, this can be any object that furfill the DrawableEntity interface {@link DrawableEntity}
   * @param setting settings on how the entity is supposed to be displayed
   * @returns  hierarcical structure of the element, describing how it should be drawn in 2d, including labels and angles
   */
  async getDrawEntity(entity, setting) {
    let drawObjects = [];
    let kind = void 0;
    if (entity.drawKind == "manhole") {
      drawObjects = await this.parent.manhole.getManholeDrawObject(entity);
      kind = "manhole";
    } else if (entity.drawKind == "measureResult") {
      drawObjects = [getResultDrawObject(entity)];
      kind = "measureResult";
    } else {
      const drawObject = await this.getEntitiyObjects(entity, setting);
      if (drawObject) {
        drawObjects = [drawObject];
      }
      kind = "basic";
    }
    if (drawObjects) {
      FillDrawInfo2D(this.drawContext, drawObjects);
    }
    return {
      kind,
      objects: drawObjects
    };
  }
  /** Converts a list of points to a drawable polygon or linestrip
   * @param points Set of points describing a polygon or linestrip
   * @param setting settings on how the entity is supposed to be displayed
   * @returns  hierarcical structure of the element, describing how it should be drawn in 2d, including labels and angles
   */
  getDrawObjectFromPoints(points, closed = true, angles = true, generateLineLabels = false) {
    if (points.length === 0) {
      return void 0;
    }
    const parts = [];
    if (points.length === 1) {
      parts.push({ drawType: "vertex", vertices3D: points });
    } else {
      let text = void 0;
      if (generateLineLabels) {
        const labels = [];
        for (let i = 1; i < points.length; ++i) {
          labels.push(vec3_exports.dist(points[i - 1], points[i]).toFixed(3));
        }
        text = [labels];
      }
      parts.push({ drawType: closed ? "filled" : "lines", vertices3D: points, text });
    }
    const drawObjects = [];
    drawObjects.push({ kind: "complex", parts });
    if (angles) {
      const endIdx = closed ? points.length : points.length - 1;
      for (let i = closed ? 0 : 1; i < endIdx; ++i) {
        const anglePt = points[i];
        const fromPIdx = i === 0 ? points.length - 1 : i - 1;
        const toPIdx = i === points.length - 1 ? 0 : i + 1;
        const fromP = points[fromPIdx];
        const toP = points[toPIdx];
        const diffA = vec3_exports.sub(vec3_exports.create(), points[fromPIdx], anglePt);
        const diffB = vec3_exports.sub(vec3_exports.create(), points[toPIdx], anglePt);
        const angle3 = vec3_exports.angle(diffA, diffB) * (180 / Math.PI);
        if (angle3 > 0.1) {
          parts.push({ text: angle3.toFixed(1) + "\xB0", drawType: "angle", vertices3D: [vec3_exports.clone(anglePt), vec3_exports.clone(fromP), vec3_exports.clone(toP)] });
        }
      }
    }
    FillDrawInfo2D(this.drawContext, drawObjects);
    return { kind: "basic", objects: drawObjects };
  }
  /** Returns a draw object that places a text based on input points.
   * @param points Set of points for where the text should be placed.
   * @param text Text
   * @returns  Draw product for displaying the text at chosen locations
   */
  getDrawText(points, text) {
    if (points.length === 0) {
      return void 0;
    }
    const parts = [];
    parts.push({ drawType: "text", vertices3D: points, text });
    const drawObjects = [];
    drawObjects.push({ kind: "complex", parts });
    FillDrawInfo2D(this.drawContext, drawObjects);
    return { kind: "basic", objects: drawObjects };
  }
  /** Returns a draw object that traces intersection between the 2d paths and displays the 3d distance as a label
   * @param objects Products that are being traced.
   * @param line Line that traces over objects.
   * @returns  Draw product for displaying lines between intersections and distance lables.
   */
  getTraceDrawOject(objects, line) {
    if (objects.length > 1) {
      const intersections = [];
      const emptyVertex = vec3_exports.create();
      objects.forEach((obj) => {
        if (obj.kind == "basic") {
          obj.objects.forEach((drawobj) => {
            if (drawobj.kind == "complex" || drawobj.kind == "curveSegment" || drawobj.kind == "edge") {
              drawobj.parts.forEach((part) => {
                if (part.vertices2D && (part.drawType == "lines" || part.drawType == "curveSegment" || part.drawType == "filled")) {
                  for (let i = 1; i < part.vertices2D.length; ++i) {
                    if (vec3_exports.equals(part.vertices3D[i - 1], emptyVertex) || vec3_exports.equals(part.vertices3D[i], emptyVertex)) {
                      continue;
                    }
                    const lineB = { start: part.vertices2D[i - 1], end: part.vertices2D[i] };
                    const intersection = lineSegmentIntersection(line, lineB);
                    if (intersection) {
                      const dir = vec3_exports.sub(vec3_exports.create(), part.vertices3D[i], part.vertices3D[i - 1]);
                      intersections.push({ intersection, point3d: vec3_exports.scaleAndAdd(vec3_exports.create(), part.vertices3D[i - 1], dir, intersection.u) });
                    }
                  }
                }
              });
            }
          });
        }
      });
      if (intersections.length > 1) {
        intersections.sort((a, b) => a.intersection.t - b.intersection.t);
        const vertices3D = [vec3_exports.create()];
        const vertices2D = [line.start];
        const labels = [""];
        intersections.forEach((intersection) => {
          vertices2D.push(intersection.intersection.p);
        });
        vertices2D.push(line.end);
        for (let i = 0; i < intersections.length; ++i) {
          if (i != 0) {
            labels.push(vec3_exports.dist(intersections[i].point3d, intersections[i - 1].point3d).toFixed(3));
          }
          vertices3D.push(intersections[i].point3d);
        }
        vertices3D.push(vec3_exports.create());
        labels.push("");
        const parts2 = [];
        parts2.push({ drawType: "lines", vertices3D, vertices2D, text: [labels] });
        const drawObjects2 = [];
        drawObjects2.push({ kind: "complex", parts: parts2 });
        return { kind: "basic", objects: drawObjects2 };
      }
    }
    const parts = [];
    parts.push({ drawType: "lines", vertices3D: [], vertices2D: [line.start, line.end] });
    const drawObjects = [];
    drawObjects.push({ kind: "complex", parts });
    return { kind: "basic", objects: drawObjects };
  }
  /** returs the 2d normal of the first draw part the line hits  
   * @param object Product with parts
   * @param line Line that needs to intersect the product. 
   * @returns  The 2d normal of the drawn object at the intersection of the input line.
   */
  get2dNormal(object, line) {
    if (object.kind != "basic") {
      return void 0;
    }
    const intersections = [];
    const emptyVertex = vec3_exports.create();
    object.objects.forEach((drawobj) => {
      if (drawobj.kind == "complex" || drawobj.kind == "curveSegment" || drawobj.kind == "edge") {
        drawobj.parts.forEach((part) => {
          if (part.vertices2D && (part.drawType == "lines" || part.drawType == "curveSegment" || part.drawType == "filled")) {
            for (let i = 1; i < part.vertices2D.length; ++i) {
              if (vec3_exports.equals(part.vertices3D[i - 1], emptyVertex) || vec3_exports.equals(part.vertices3D[i], emptyVertex)) {
                continue;
              }
              const lineB = { start: part.vertices2D[i - 1], end: part.vertices2D[i] };
              const intersection = lineSegmentIntersection(line, lineB);
              if (intersection) {
                intersections.push({ intersection, line: lineB });
              }
            }
          }
        });
      }
    });
    if (intersections.length > 0) {
      intersections.sort((a, b) => a.intersection.t - b.intersection.t);
      const line2 = intersections[0].line;
      const dx = line2.end[0] - line2.start[0];
      const dy = line2.end[1] - line2.start[1];
      const normal = vec2_exports.fromValues(-dy, dx);
      vec2_exports.normalize(normal, normal);
      return {
        normal,
        position: intersections[0].intersection.p
      };
    }
    return void 0;
  }
};
function getPathMatrices(width, height, camera) {
  const camMat = mat4_exports.fromRotationTranslation(
    mat4_exports.create(),
    camera.rotation,
    camera.position
  );
  mat4_exports.invert(camMat, camMat);
  if (camera.kind == "pinhole") {
    const projMat = mat4_exports.perspective(
      mat4_exports.create(),
      common_exports.toRadian(camera.fov),
      width / height,
      camera.near,
      camera.far
    );
    return { camMat, projMat };
  } else {
    const aspect = width / height;
    const halfHeight = camera.fov / 2;
    const halfWidth = halfHeight * aspect;
    const projMat = mat4_exports.ortho(
      mat4_exports.create(),
      -halfWidth,
      halfWidth,
      -halfHeight,
      halfHeight,
      camera.near,
      camera.far
    );
    return { camMat, projMat };
  }
}
function toPathPointsFromMatrices(points, camMat, projMat, near, width, height, ortho2) {
  const clip = (p, p0) => {
    const d = vec3_exports.sub(vec3_exports.create(), p0, p);
    vec3_exports.scale(d, d, (-near - p[2]) / d[2]);
    return vec3_exports.add(d, d, p);
  };
  const points2d = [];
  const removedIndices = [];
  const addedIndices = [];
  const sv = points.map((v) => vec3_exports.transformMat4(vec3_exports.create(), v, camMat));
  if (ortho2) {
    for (const p of sv) {
      if (p[2] > 0 && p[2] < 0.1) {
        p[2] = -1e-4;
      }
    }
  }
  const screenPoints = sv.reduce((tail, head, i) => {
    if (head[2] > SCREEN_SPACE_EPSILON) {
      if (i === 0 || sv[i - 1][2] > 0) {
        removedIndices.push(i);
        return tail;
      }
      const p0 = clip(sv[i - 1], head);
      const _p2 = toScreen(projMat, width, height, p0);
      points2d.push(_p2);
      return tail.concat([_p2]);
    }
    const _p = toScreen(projMat, width, height, head);
    points2d.push(_p);
    if (i !== 0 && sv[i - 1][2] > SCREEN_SPACE_EPSILON) {
      const p0 = clip(head, sv[i - 1]);
      const _p0 = toScreen(projMat, width, height, p0);
      addedIndices.push(i);
      return tail.concat([_p0], [_p]);
    }
    return tail.concat([_p]);
  }, []);
  if (screenPoints.length) {
    return { screenPoints, points2d, removedIndices, addedIndices };
  }
  return void 0;
}
function toScreen(projMat, width, height, p) {
  const _p = vec4_exports.transformMat4(
    vec4_exports.create(),
    vec4_exports.fromValues(p[0], p[1], p[2], 1),
    projMat
  );
  const pt = vec2_exports.fromValues(
    Math.round((_p[0] * 0.5 / _p[3] + 0.5) * width),
    Math.round((0.5 - _p[1] * 0.5 / _p[3]) * height)
  );
  return pt.every((num) => !Number.isNaN(num) && Number.isFinite(num)) ? pt : vec2_exports.fromValues(-100, -100);
}
function FillDrawInfo2D(context, drawObjects) {
  const { width, height, camera } = context;
  const { camMat, projMat } = getPathMatrices(width, height, camera);
  for (const drawObject of drawObjects) {
    for (const drawPart of drawObject.parts) {
      const points = toPathPointsFromMatrices(
        drawPart.vertices3D,
        camMat,
        projMat,
        camera.near,
        width,
        height,
        camera.kind == "orthographic"
      );
      if (points) {
        const { screenPoints, removedIndices, addedIndices } = points;
        drawPart.vertices2D = screenPoints;
        if (removedIndices.length > 0 || addedIndices.length > 0) {
          if (drawPart.text && Array.isArray(drawPart.text)) {
            drawPart.text[0] = drawPart.text[0].reduce((tail, head, i) => {
              if (addedIndices.find((v) => v == i) != void 0 && removedIndices.find((v) => v == i - 1) == void 0) {
                return tail.concat(["", head]);
              }
              if (removedIndices.find((v) => v == i) != void 0 && removedIndices.find((v) => v == i + 1) != void 0) {
                return tail;
              } else {
                return tail.concat(head);
              }
            }, []);
          }
          const newVert3d = [];
          drawPart.vertices3D.forEach((v, i) => {
            if (addedIndices.find((v2) => v2 == i) != void 0 && removedIndices.find((v2) => v2 == i - 1) == void 0) {
              newVert3d.concat([vec3_exports.create(), v]);
            } else if (removedIndices.find((v2) => v2 == i) == void 0 || removedIndices.find((v2) => v2 == i + 1) == void 0) {
              return newVert3d.push(v);
            }
            drawPart.vertices3D = newVert3d;
          });
        }
      }
      if (drawPart.voids) {
        drawPart.voids.forEach((drawVoid, j) => {
          const voidPoints = toPathPointsFromMatrices(
            drawVoid.vertices3D,
            camMat,
            projMat,
            camera.near,
            width,
            height,
            camera.kind == "orthographic"
          );
          if (voidPoints) {
            const { screenPoints, removedIndices, addedIndices } = voidPoints;
            drawVoid.vertices2D = screenPoints;
            if ((removedIndices.length > 0 || addedIndices.length > 0) && drawPart.text && Array.isArray(drawPart.text)) {
              drawPart.text[j + 1] = drawPart.text[j + 1].reduce((tail, head, i) => {
                if (addedIndices.find((v) => v == i) != void 0 && removedIndices.find((v) => v == i - 1) == void 0) {
                  return tail.concat(["", head]);
                }
                if (removedIndices.find((v) => v == i) != void 0 && removedIndices.find((v) => v == i + 1) != void 0) {
                  return tail;
                } else {
                  return tail.concat(head);
                }
              }, []);
            }
          }
        });
      }
    }
  }
}
function getResultDrawObject(result) {
  const parts = [];
  if (result.measureInfoA?.point && result.measureInfoB?.point) {
    const measurePoints = [result.measureInfoA?.point, result.measureInfoB?.point];
    const flip = measurePoints[0][2] > measurePoints[1][2];
    let pts = flip ? [measurePoints[1], measurePoints[0]] : [measurePoints[0], measurePoints[1]];
    const diff = vec3_exports.sub(vec3_exports.create(), pts[0], pts[1]);
    const measureLen = vec3_exports.len(diff);
    parts.push({ name: "result", text: measureLen.toFixed(3), drawType: "lines", vertices3D: [vec3_exports.clone(measurePoints[0]), vec3_exports.clone(measurePoints[1])] });
    pts = [
      pts[0],
      vec3_exports.fromValues(pts[1][0], pts[0][1], pts[0][2]),
      vec3_exports.fromValues(pts[1][0], pts[1][1], pts[0][2]),
      pts[1]
    ];
    parts.push({ name: "x-axis", text: Math.abs(diff[0]).toFixed(3), drawType: "lines", vertices3D: [vec3_exports.clone(pts[0]), vec3_exports.clone(pts[1])] });
    parts.push({ name: "y-axis", text: Math.abs(diff[1]).toFixed(3), drawType: "lines", vertices3D: [vec3_exports.clone(pts[1]), vec3_exports.clone(pts[2])] });
    parts.push({ name: "z-axis", text: Math.abs(diff[2]).toFixed(3), drawType: "lines", vertices3D: [vec3_exports.clone(pts[2]), vec3_exports.clone(pts[3])] });
    const planarDiff = vec2_exports.len(vec2_exports.fromValues(diff[0], diff[1]));
    const xyPt1 = vec3_exports.fromValues(pts[0][0], pts[0][1], Math.min(pts[0][2], pts[3][2]));
    const xyPt2 = vec3_exports.fromValues(pts[3][0], pts[3][1], Math.min(pts[0][2], pts[3][2]));
    parts.push({ name: "xy-plane", text: planarDiff.toFixed(3), drawType: "lines", vertices3D: [xyPt1, xyPt2] });
    const zDiff = vec3_exports.sub(vec3_exports.create(), pts[2], pts[3]);
    const angle3 = vec3_exports.angle(diff, zDiff) * (180 / Math.PI);
    if (angle3 > 0.1) {
      const fromP = flip ? vec3_exports.clone(measurePoints[1]) : vec3_exports.clone(measurePoints[0]);
      const toP = vec3_exports.clone(pts[2]);
      parts.push({ name: "z-angle", text: angle3.toFixed(1) + "\xB0", drawType: "angle", vertices3D: [vec3_exports.clone(pts[3]), fromP, toP] });
    }
    const xzDiff = vec3_exports.sub(vec3_exports.create(), xyPt1, xyPt2);
    const xzAngle = vec3_exports.angle(diff, xzDiff) * (180 / Math.PI);
    if (xzAngle > 0.1) {
      const fromP = flip ? vec3_exports.clone(measurePoints[0]) : vec3_exports.clone(measurePoints[1]);
      parts.push({ name: "xz-angle", text: xzAngle.toFixed(1) + "\xB0", drawType: "angle", vertices3D: [vec3_exports.clone(xyPt1), fromP, vec3_exports.clone(xyPt2)] });
    }
  }
  if (result.angle) {
    parts.push({
      name: "cylinder-angle",
      text: (result.angle.radians * (180 / Math.PI)).toFixed(1) + "\xB0",
      drawType: "angle",
      vertices3D: [vec3_exports.clone(result.angle.angleDrawInfo[0]), vec3_exports.clone(result.angle.angleDrawInfo[1]), vec3_exports.clone(result.angle.angleDrawInfo[2])]
    });
    if (result.angle.additionalLine) {
      parts.push({ name: "cylinder-angle-line", drawType: "lines", vertices3D: [vec3_exports.clone(result.angle.additionalLine[0]), vec3_exports.clone(result.angle.additionalLine[1])] });
    }
  }
  if (result.normalPoints) {
    const dist4 = vec3_exports.len(vec3_exports.sub(vec3_exports.create(), result.normalPoints[0], result.normalPoints[1]));
    parts.push({ name: "normal", text: dist4.toFixed(3), drawType: "lines", vertices3D: [vec3_exports.clone(result.normalPoints[0]), vec3_exports.clone(result.normalPoints[1])] });
  }
  return { parts, kind: "complex" };
}

// /projects/Novorender/ts/dist/measure/modules/followPath/module.ts
var FollowModule = class extends BaseModule {
  /**
   * @ignore
   */
  async followParametricEntity(id, entity, setting) {
    const workerScene = await this.worker;
    let parameterBounds = void 0;
    let emulatedCurve = void 0;
    let type = void 0;
    switch (entity.drawKind) {
      case "edge": {
        type = "edge";
        parameterBounds = await workerScene.getParameterBoundsForCurve(
          id,
          entity.pathIndex,
          "edge"
        );
        break;
      }
      case "face": {
        const cylinderData = await workerScene.getCylinderCurve(
          id,
          entity.pathIndex,
          entity.instanceIndex,
          setting
        );
        if (cylinderData) {
          type = "cylinder";
          parameterBounds = cylinderData[0];
          emulatedCurve = {
            start: cylinderData[1][0],
            dir: vec3_exports.normalize(
              vec3_exports.create(),
              vec3_exports.subtract(
                vec3_exports.create(),
                cylinderData[1][1],
                cylinderData[1][0]
              )
            )
          };
        }
        break;
      }
      case "curveSegment": {
        type = "curve";
        parameterBounds = await workerScene.getParameterBoundsForCurve(
          id,
          entity.pathIndex,
          "curveSegment"
        );
        break;
      }
    }
    if (parameterBounds && type) {
      async function getCameraValues(t) {
        if (emulatedCurve) {
          const param = t < 0 ? 0 : t > parameterBounds.end ? parameterBounds.end : t;
          return {
            position: vec3_exports.scaleAndAdd(
              vec3_exports.create(),
              emulatedCurve.start,
              emulatedCurve.dir,
              param
            ),
            normal: vec3_exports.negate(vec3_exports.create(), emulatedCurve.dir)
          };
        }
        const curveVaues = await workerScene.evalCurve(
          id,
          entity.pathIndex,
          entity.instanceIndex,
          t,
          entity.drawKind == "edge" ? "edge" : "curveSegment"
        );
        if (curveVaues) {
          return { position: curveVaues[0], normal: curveVaues[1] };
        }
      }
      const selectedEntity = {
        ...entity,
        ObjectId: id,
        drawKind: entity.drawKind
      };
      return {
        type,
        ids: [id],
        selectedEntity,
        parameterBounds,
        getCameraValues
      };
    }
  }
  /** Returns an object that can be used to calculate camera positions that follow the object
   * Supports Edges, curve segments and cylinder      
   * @param object The object being selected.
   * @param selectionPosition Function need the selected position to select a subpart of the object in case it is composed of several parts. 
   * @param setting Settings. 
   * @returns Follow path object that will conain information as well as a function to use for following the parametric object,
   *  undefined if the current picked part is not eligble for follow path
   */
  async followParametricObjectFromPosition(id, selectionPosition, setting) {
    const workerScene = await this.worker;
    const pos = vec3_exports.copy(vec3_exports.create(), selectionPosition);
    const pickedEntity = await workerScene.pickEntity(id, pos);
    if (pickedEntity.entity && pickedEntity.entity.drawKind != "vertex") {
      return this.followParametricEntity(id, pickedEntity.entity, setting);
    }
    return void 0;
  }
  /** Returns an object that can be used to calculate camera posisiotns that follow the objects
   * Supports multiple cylinder,
   * In case of one object, and that object only containing one curve segment it will return curve segment
   * @param ids Set of object ids to follow, can be line segments or cylinders. 
   * @param setting Settings. 
   * @returns Follow path object that will conain information as well as a function to use for following the parametric object,
   *  undefined if there are no objects the can be followed in the ids list
   */
  async followParametricObjects(ids, setting) {
    const workerScene = await this.worker;
    if (ids.length == 1) {
      const entity = await workerScene.viableFollowPathEntity(ids[0]);
      if (entity != void 0 && entity.drawKind != "vertex") {
        return this.followParametricEntity(ids[0], entity);
      }
    }
    const lineStrip = await workerScene.getLineStripFromCylinders(ids, setting);
    if (lineStrip.length > 1) {
      let len5 = 0;
      for (let i = 1; i < lineStrip.length; ++i) {
        len5 += vec3_exports.dist(lineStrip[i - 1], lineStrip[i]);
      }
      const parameterBounds = { start: 0, end: len5 };
      async function getCameraValues(t) {
        const param = t < 0 ? 0 : t > parameterBounds.end ? parameterBounds.end : t;
        let i = 1;
        let length5 = 0;
        let prevLength = 0;
        let currLength = 0;
        for (; i < lineStrip.length; ++i) {
          currLength = vec3_exports.dist(lineStrip[i - 1], lineStrip[i]);
          length5 += currLength;
          if (length5 > param) {
            break;
          }
          prevLength = length5;
        }
        if (i == lineStrip.length) {
          const dir2 = vec3_exports.subtract(
            vec3_exports.create(),
            lineStrip[i - 2],
            lineStrip[i - 1]
          );
          return {
            position: lineStrip[i - 1],
            normal: vec3_exports.normalize(dir2, dir2)
          };
        }
        const dir = vec3_exports.subtract(
          vec3_exports.create(),
          lineStrip[i - 1],
          lineStrip[i]
        );
        return {
          position: vec3_exports.lerp(
            vec3_exports.create(),
            lineStrip[i - 1],
            lineStrip[i],
            (param - prevLength) / currLength
          ),
          normal: vec3_exports.normalize(dir, dir)
        };
      }
      return {
        type: lineStrip.length == 2 ? "cylinder" : "cylinders",
        ids,
        selectedEntity: void 0,
        parameterBounds,
        getCameraValues
      };
    }
    return void 0;
  }
};

// /projects/Novorender/ts/dist/measure/modules/manhole/module.ts
var ManholeModule = class extends BaseModule {
  /** 
   * Give manhole measure object to inspect from objectId, 
   * note that this object can be used for all measurement {@link measure}
   * and aslo be drawn {@link DrawableEntity}
   * @param ObjectId The object Id where the api try to fetch manhole object from
   * @returns Values for manhole measurement, 
  */
  async measure(objectId) {
    const workerScene = await this.worker;
    return workerScene.getManholeValues(objectId);
  }
  /**
   * @ignore
  */
  async getManholeDrawObject(entity) {
    const workerScene = await this.worker;
    return workerScene.getManholeDrawObject(entity);
  }
};

// /projects/Novorender/ts/dist/measure/modules/core/module.ts
var CoreModule = class extends BaseModule {
  /**
   * Measure object, if b is undefined then single measure values are returned else the measurement between 2 objects
   * Standard measuring function for measure single or between 2 parametric objects.
   * @param a The entity that is being measured, this can either be a parametric object or a single point
   * @param b If this is defined then the measure function will return the measurement between a and b.
   * @param settingA settings for object a
   * @param settingB settings for object b
   * @returns  Measurement values either for a single object or between the objects
   */
  async measure(a, b, settingA, settingB) {
    return b ? await this.measurePair(a, b, settingA, settingB) : await this.measureSingle(a, settingA);
  }
  /** Returns the measure entity for given object and location, measure entity is a single part of a parametric object,
   * such as surface, edge or vertex. If the object and position does not contain parametric data a single vertex will be returned
   * @param id The object id of selected object
   * @param selectionPosition selected position, this is required to select the individual part of the parametric object
   * @param tolerance Tolerance for picking, the distance used is in meters
   * @returns Selected measure entity, this will be a vertex if nothing can be selected at the location
   * status if the object is loaded, and connection point where the parametric object has been selected.
   */
  async pickMeasureEntity(id, selectionPosition, tolerance) {
    const workerScene = await this.worker;
    const pos = vec3_exports.copy(vec3_exports.create(), selectionPosition);
    return await workerScene.pickEntity(id, pos, tolerance);
  }
  /** Returns the measure entity for given object and location if the current object is selected
   *  This is much faster than pickMeasureEntity and can be used for hover
   * @param id The object id of selected object
   * @param selectionPosition selected position, this is required to select the individual part of the parametric object
   * @param tolerance Tolerance for picking, the distance used is in meters
   * @returns Selected measure entity, this will be undefined if nothing is selectable at current position
   * **/
  async pickMeasureEntityOnCurrentObject(id, selectionPosition, tolerance) {
    const workerScene = await this.worker;
    const pos = vec3_exports.copy(vec3_exports.create(), selectionPosition);
    return await workerScene.pickEntityOnCurrentObject(id, pos, tolerance);
  }
  /**
   * @ignore
   * @privateRemarks not currently in use
   */
  async getParametricProduct(productId) {
    const workerScene = await this.worker;
    return await workerScene.getProductObject(productId);
  }
  /**
   * @ignore
   * @privateRemarks not currently in use
   */
  async getCameraValues(a, cameraDir) {
    const workerScene = await this.worker;
    return workerScene.getCameraValuesFromFace(
      a.ObjectId,
      a.pathIndex,
      a.instanceIndex,
      cameraDir
    );
  }
  /** 
   * Swaps between inner and outer cylinder, returns undefined if there is only one
   * @param entity Entity to be swapped
   * @param to Force cylinder to either be inner or outer
   * @returns Returns a new entity of the selected cylinder, if there is only one cylinder undefined is returned.
   */
  async swapCylinder(entity, to) {
    if (entity.drawKind == "face") {
      const workerScene = await this.worker;
      const pathIdx = await workerScene.swapCylinder(
        entity.ObjectId,
        entity.pathIndex,
        entity.instanceIndex,
        to
      );
      if (pathIdx != void 0) {
        return {
          ...entity,
          pathIndex: pathIdx
        };
      }
    }
  }
  /**
   * Calculates the area from polygon. Treat polygon as closed, Z is treated as height and is ignored.
   * @param vertices Vertices defining the polygon, last and first vertex will be connected to create a closed polygon
   * @param normals Normals used to define the plane where the area is measured. IF the difference is too high it will use Z as the normal 
   * @returns The area of the selected polygon, do note this is 2d calulation and height is ignored
   */
  areaFromPolygon(vertices, normals) {
    if (vertices.length == 0) {
      return { area: void 0, polygon: [] };
    }
    if (vertices.length != normals.length) {
      throw new MeasureError(
        "Area measurement",
        "Number of normals and vertices needs to be equal"
      );
    }
    let useXYPlane = false;
    const epsilon = 1e-3;
    const normal = normals[0];
    for (let i = 1; i < normals.length; ++i) {
      if (1 - Math.abs(vec3_exports.dot(normal, normals[i])) > epsilon) {
        useXYPlane = true;
        break;
      }
    }
    if (useXYPlane) {
      let total2 = 0;
      const polygon2 = [];
      for (let i = 0; i < vertices.length; i++) {
        let addX = vertices[i][0];
        let addY = vertices[i == vertices.length - 1 ? 0 : i + 1][1];
        let subX = vertices[i == vertices.length - 1 ? 0 : i + 1][0];
        let subY = vertices[i][1];
        total2 += addX * addY * 0.5;
        total2 -= subX * subY * 0.5;
        polygon2.push(
          vec3_exports.fromValues(vertices[i][0], vertices[i][1], vertices[0][2])
        );
      }
      return { area: Math.abs(total2), polygon: polygon2 };
    }
    const polygon = [];
    polygon.push(vertices[0]);
    const vertex = vertices[0];
    for (let i = 1; i < vertices.length; ++i) {
      const v = vertices[i];
      const vo = vec3_exports.subtract(vec3_exports.create(), v, vertex);
      const dist4 = vec3_exports.dot(vo, normal) * -1;
      polygon.push(vec3_exports.scaleAndAdd(vec3_exports.create(), v, normal, dist4));
    }
    if (polygon.length == 1) {
      return { area: 0, polygon };
    }
    const xDir = vec3_exports.subtract(vec3_exports.create(), polygon[1], polygon[0]);
    vec3_exports.normalize(xDir, xDir);
    const yDir = vec3_exports.cross(vec3_exports.create(), normal, xDir);
    vec3_exports.normalize(yDir, yDir);
    const polygon2d = [];
    polygon2d.push(vec2_exports.fromValues(0, 0));
    for (let i = 1; i < vertices.length; ++i) {
      const p = polygon[i];
      const po = vec3_exports.subtract(vec3_exports.create(), p, vertex);
      polygon2d.push(vec2_exports.fromValues(vec3_exports.dot(po, xDir), vec3_exports.dot(po, yDir)));
    }
    let total = 0;
    for (let i = 0; i < polygon2d.length; i++) {
      let addX = polygon2d[i][0];
      let addY = polygon2d[i == vertices.length - 1 ? 0 : i + 1][1];
      let subX = polygon2d[i == vertices.length - 1 ? 0 : i + 1][0];
      let subY = polygon2d[i][1];
      total += addX * addY * 0.5;
      total -= subX * subY * 0.5;
    }
    return { area: Math.abs(total), polygon };
  }
  /**
   * Measure between multiple points. Will return the angles, segment length and total length
   * @param vertices Vertices defining the line strip to be measured
   * @returns Angles, segment length and total length of the input linestrip
   */
  measureLineStrip(vertices) {
    let totalLength = 0;
    let segmentLengts = [];
    let angles = [];
    let prevSeg = void 0;
    for (let i = 1; i < vertices.length; ++i) {
      const l = vec3_exports.dist(vertices[i - 1], vertices[i]);
      totalLength += l;
      segmentLengts.push(l);
      const dir = vec3_exports.sub(vec3_exports.create(), vertices[i], vertices[i - 1]);
      vec3_exports.normalize(dir, dir);
      if (prevSeg != void 0) {
        let angle3 = vec3_exports.angle(prevSeg, dir);
        if (angle3 > Math.PI) {
          angle3 = Math.PI * 2 - angle3;
        }
        angles.push(angle3);
      }
      vec3_exports.negate(dir, dir);
      prevSeg = dir;
    }
    return { totalLength, linestrip: vertices, segmentLengts, angles };
  }
  /**
  * @ignore
  */
  async measurePair(a, b, settingA, settingB) {
    if (a.drawKind == "vertex") {
      if (b.drawKind == "vertex") {
        return this.pointToPoint(a.parameter, b.parameter);
      }
      return this.measureToPoint(b, a.parameter, settingB);
    }
    if (b.drawKind == "vertex") {
      return this.measureToPoint(a, b.parameter, settingA);
    }
    const workerScene = await this.worker;
    const entities = [
      { object: a, settings: settingA },
      { object: b, settings: settingB }
    ];
    entities.sort((a2, b2) => a2.object.drawKind.localeCompare(b2.object.drawKind));
    const [A, B] = entities;
    const kindCombo = `${A.object.drawKind}_${B.object.drawKind}`;
    switch (kindCombo) {
      case "curveSegment_curveSegment":
        return await workerScene.segmentToSegmentMeasure(
          A.object.ObjectId,
          A.object.pathIndex,
          A.object.instanceIndex,
          B.object.ObjectId,
          B.object.pathIndex,
          B.object.instanceIndex
        );
      case "curveSegment_edge":
        return await workerScene.segmentToEdgeMeasure(
          A.object.ObjectId,
          A.object.pathIndex,
          A.object.instanceIndex,
          B.object.ObjectId,
          B.object.pathIndex,
          B.object.instanceIndex
        );
      case "curveSegment_face":
        return await workerScene.segmentToFaceMeasure(
          A.object.ObjectId,
          A.object.pathIndex,
          A.object.instanceIndex,
          B.object.ObjectId,
          B.object.pathIndex,
          B.object.instanceIndex,
          B.settings
        );
      case "edge_edge":
        return await workerScene.edgeToEdgeMeasure(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          b.ObjectId,
          b.pathIndex,
          b.instanceIndex
        );
      case "edge_face":
        return await workerScene.edgeToFaceMeasure(
          A.object.ObjectId,
          A.object.pathIndex,
          A.object.instanceIndex,
          B.object.ObjectId,
          B.object.pathIndex,
          B.object.instanceIndex,
          B.settings
        );
      case "face_face":
        return await workerScene.faceToFaceMeasure(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          b.ObjectId,
          b.pathIndex,
          b.instanceIndex,
          A.settings,
          B.settings
        );
    }
  }
  /**
   * @ignore
   */
  async measureSingle(a, setting) {
    const workerScene = await this.worker;
    switch (a.drawKind) {
      case "curveSegment":
        return await workerScene.getCurveValues(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          "curveSegment"
        );
      case "edge":
        return await workerScene.getCurveValues(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          "edge"
        );
      case "face":
        return await workerScene.getFaceValues(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          setting
        );
    }
  }
  /**
   * @ignore
   */
  async measureToPoint(a, b, setting) {
    const point = vec3_exports.copy(vec3_exports.create(), b);
    if (a.drawKind == "vertex") {
      return this.pointToPoint(a.parameter, point);
    }
    const workerScene = await this.worker;
    switch (a.drawKind) {
      case "curveSegment":
        return await workerScene.segmentToPointMeasure(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          point
        );
      case "edge":
        return await workerScene.edgeToPointMeasure(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          point
        );
      case "face":
        return await workerScene.faceToPointMeasure(
          a.ObjectId,
          a.pathIndex,
          a.instanceIndex,
          point,
          setting
        );
    }
  }
  /**
   * @ignore
   * Measure distance between 2 points
   */
  pointToPoint(a, b) {
    const diff = vec3_exports.sub(vec3_exports.create(), a, b);
    return {
      drawKind: "measureResult",
      distance: vec3_exports.len(diff),
      distanceX: Math.abs(diff[0]),
      distanceY: Math.abs(diff[1]),
      distanceZ: Math.abs(diff[2]),
      measureInfoA: { point: vec3_exports.copy(vec3_exports.create(), a) },
      measureInfoB: { point: vec3_exports.copy(vec3_exports.create(), b) }
    };
  }
};

// /projects/Novorender/ts/dist/measure/modules/profile/module.ts
var ProfileModule = class extends BaseModule {
  /** 
   * Returns the profile view of a linestrip where x is the length of the line and y is the height
   * This function can be used if an object contains multiple unconnected entities.
   * @param entity The parametric entity used to create the profile
   * @param setting Settings
   * @returns Profile where x is the length of the line and y is the height,
   *  it supports curve segments and cylinders, othwerwise it retuns undefiend
   */
  async viewFromEntity(entity, setting) {
    const workerScene = await this.worker;
    switch (entity.drawKind) {
      case "curveSegment": {
        return await workerScene.curveSegmentProfile(
          entity.ObjectId,
          entity.pathIndex,
          entity.instanceIndex
        );
      }
      case "face": {
        return await workerScene.cylinderProfile(
          entity.ObjectId,
          entity.pathIndex,
          entity.instanceIndex,
          setting
        );
      }
    }
    return void 0;
  }
  /**
  * Returns the profile view of selected objects where x is the length of the line and y is the height,
  * currently only supports cylinders
  * @param products Products used to create a profile, this can be a list of line segments, line strips or connected cylinders
   * @param setting Settings
  * @returns Profile where x is the length of the line and y is the height,
  *  it supports curve segments and cylinders, othwerwise it retuns undefiend
  */
  async viewFromMultiSelect(products, setting) {
    const workerScene = await this.worker;
    const profile = await workerScene.multiSelectProfile(products, setting);
    if (typeof profile === "string") {
      throw new MeasureError("Profile error", profile);
    }
    return profile;
  }
  reverse(inProfile) {
    const endParam = inProfile.profilePoints[inProfile.profilePoints.length - 1][0];
    const rProfile = [];
    for (let i = inProfile.profilePoints.length - 1; i >= 0; --i) {
      const p = inProfile.profilePoints[i];
      rProfile.push(vec2_exports.fromValues((p[0] - endParam) * -1, p[1]));
    }
    return {
      profilePoints: rProfile,
      slopes: inProfile.slopes.reverse(),
      startElevation: inProfile.endElevation,
      endElevation: inProfile.startElevation,
      top: inProfile.top,
      bottom: inProfile.bottom
    };
  }
};

// /projects/Novorender/ts/dist/measure/modules/road/module.ts
var RoadModule = class extends BaseModule {
  /**
   * @ignore
   * In development
   */
  async getProfile(roadId) {
    const workerScene = await this.worker;
    return workerScene.getRoadProfile(roadId);
  }
  /**
   * @ignore
   * In development
   */
  async getCrossSlope(roadId) {
    const workerScene = await this.worker;
    return workerScene.getRoadCrossSlope(roadId);
  }
  /**
   * Get cross sections at a spesific profile in the road.
   * @param roadIds Unqiue string id for each road, can be found in the data api
   * @param profileNumber Distance along the center line where the cross section should be cut
   * @returns 
   */
  async getCrossSections(roadIds, profileNumber) {
    const workerScene = await this.worker;
    const sections = await Promise.all(roadIds.map((rId) => workerScene.getCrossSection(rId, profileNumber)));
    const s = sections.filter((s2) => s2 != void 0);
    return s;
  }
};

// /projects/Novorender/ts/dist/measure/measure_view.ts
var MeasureView3 = class {
  /** @ignore */
  constructor(worker, workers, drawContext) {
    this.worker = worker;
    this.drawContext = drawContext;
    this.workers = workers;
    this.collision = new CollisionModule(worker, this);
    this.draw = new DrawModule(worker, this, drawContext);
    this.followPath = new FollowModule(worker, this);
    this.manhole = new ManholeModule(worker, this);
    this.core = new CoreModule(worker, this);
    this.profile = new ProfileModule(worker, this);
    this.road = new RoadModule(worker, this);
  }
  /**
   * Module for collision calculations, see {@link CollisionModule}
   */
  collision;
  /**
   * Module for drawing measure objects on screen, see {@link DrawModule}
   */
  draw;
  /**
   * Module for following parameteric objects such as line strips and cylinders, see {@link FollowModule}
   */
  followPath;
  /**
   * Module for inspecting and measuring manholes, see {@link ManholeModule}
   */
  manhole;
  /**
   * Module for general measuring functions, see {@link CoreModule}
   */
  core;
  /**
   * Module for 2d profiles from lines or cylinders, see {@link ProfileModule}
   */
  profile;
  /**
   * Module for road spesific calulations and data, see {@link RoadModule}
   */
  road;
  /** @ignore */
  workers;
  async loadScene(sceneUrl) {
    const workerScene = await this.worker;
    workerScene.loadScene(sceneUrl.toString());
  }
  /**
   * Cleanup if measure module is no longer needed
   */
  async dispose() {
    const { workers } = this;
    if (workers) {
      const { measure: measure3 } = workers;
      await measure3.service.terminate();
      measure3.service[releaseProxy]();
    }
  }
};
function createWorkers(url) {
  const measureWorker = new Worker(url, { type: "module", name: "Measure" });
  const measureService = wrap(measureWorker);
  const workers = {
    measure: {
      worker: measureWorker,
      service: measureService
    }
  };
  measureService.initialize(url);
  return workers;
}
async function createMeasureView(drawContext, imports) {
  const workers = createWorkers(imports.measureWorker.toString());
  const tool = await workers.measure.service.createMeasureTool();
  const measureView = new MeasureView3(tool, workers, drawContext);
  await tool.init(imports.nurbsWasm);
  return measureView;
}
var MeasureError = class extends Error {
  constructor(type, message) {
    super(message);
    this.type = type;
  }
};

// /projects/Novorender/ts/dist/measure/imports.ts
async function downloadMeasureImports(map) {
  const { baseUrl } = map;
  const measureWorker = getWorkerUrl(map.measureWorker ?? "./measureWorker.js", baseUrl);
  const wasmInstancePromise = getInstance2(map.nurbsWasm ?? "./nurbs.wasm", baseUrl);
  const nurbsWasm = await wasmInstancePromise;
  return { nurbsWasm, measureWorker };
}
function isUrl2(url) {
  return typeof url == "string" || url instanceof URL;
}
async function getInstance2(arg, baseUrl) {
  if (!isUrl2(arg)) {
    return arg;
  }
  const url = new URL(arg, baseUrl);
  const response = await fetch(url, { mode: "cors" });
  if (!response.ok) {
    throw new Error(`Could not download wasm instance from: ${url}`);
  }
  return await response.arrayBuffer();
}
function getWorkerUrl(arg, baseUrl) {
  return new URL(arg, baseUrl);
}

// /projects/Novorender/ts/dist/web_app/device.ts
function getDeviceProfile(tier, resolutionScaling) {
  const outline = tier >= 1;
  let maxGPUBytes = [5e8, 75e7, 2e9, 5e9][tier];
  const maxPrimitives = [6e6, 12e6, 2e7, 3e7][tier];
  const maxSamples = [4, 4, 8, 16][tier];
  const detailBias = [0.1, 0.35, 0.75, 1][tier];
  let renderResolution = [0.5, 0.75, 1, 1][tier];
  if (resolutionScaling) {
    renderResolution *= resolutionScaling;
  }
  let adreno600 = false;
  let slowShaderRecompile = false;
  const canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = 1;
  document.body.appendChild(canvas);
  const gl = canvas.getContext("webgl", { failIfMajorPerformanceCaveat: true });
  canvas.remove();
  if (gl) {
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const renderer = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl?.VERSION);
    if (RegExp("Apple GPU").test(renderer)) {
      maxGPUBytes = 5e8;
    }
    if (RegExp("Adreno.+6[0-9][0-9]").test(renderer)) {
      adreno600 = true;
    } else if (RegExp("Apple M1").test(renderer) || RegExp("Iris").test(renderer)) {
      slowShaderRecompile = true;
    }
  }
  const coreProfile = {
    features: {
      outline
    },
    limits: {
      maxGPUBytes,
      maxPrimitives,
      maxSamples
    },
    quirks: {
      adreno600,
      slowShaderRecompile
    },
    detailBias
  };
  return {
    ...coreProfile,
    renderResolution,
    framerateTarget: 30,
    tier
  };
}

// /projects/Novorender/ts/dist/web_app/controller/input.ts
var ControllerInput = class _ControllerInput {
  /** The underlying HTMLElement providing input events. */
  domElement;
  /** A set of optional callbacks for controllers that wants to handle certain input events themselves. */
  callbacks;
  /** The current values of each input axis. */
  axes;
  /** The current list of individual touch contact points. */
  touchPoints = [];
  _keys = /* @__PURE__ */ new Set();
  _mouseButtonDown = false;
  _zoomY = 0;
  _zoomX = 0;
  _touchMovePrev = [0, 0];
  _touchZoomDistancePrev = 0;
  prevTouchCenter = void 0;
  _mouseWheelLastActive = 0;
  static _gestureKeys = ["KeyW", "KeyS", "KeyA", "KeyD", "KeyQ", "KeyE", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
  /** Whether to use {@link https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API | mouse pointer lock} or not. */
  usePointerLock = true;
  /**
   * @param domElement The HTMLElement to subscribe to input events from.
   */
  constructor(domElement) {
    this.domElement = domElement ?? document.body;
    this.connect();
    this.axes = {};
    this.resetAxes();
  }
  /** Unsubscribe from input events. */
  dispose() {
    this.disconnect();
  }
  /** Return the client width of the input {@link domElement}. */
  get width() {
    return this.domElement.clientWidth;
  }
  /** Return the client height of the input {@link domElement}. */
  get height() {
    return this.domElement.clientHeight;
  }
  /** Current multiplier applied to motion via the Control/Alt keys. */
  get multiplier() {
    const { _keys } = this;
    let m = 1;
    if (_keys.has("Shift"))
      m *= 10;
    if (_keys.has("Control"))
      m *= 10;
    if (_keys.has("Alt"))
      m *= 0.1;
    return m;
  }
  /** Whether the shift key is currently pressed or not. */
  get hasShift() {
    const { _keys } = this;
    if (_keys.has("Shift"))
      return true;
    return false;
  }
  /** The pixel position centering zoom gestures.
   * @remarks
   * This is typically the current cursor position while using the mouse scroll wheel,
   * or the center position between touch points in a pinch gesture.
   */
  get zoomPos() {
    const { width, height, _zoomX, _zoomY } = this;
    if (_zoomX == 0 && _zoomY == 0) {
      return [0, 0];
    }
    return [-(_zoomX - width / 2) / height * 2, (_zoomY - height / 2) / height * 2];
  }
  /** Subscribe to input events from {@link domElement}. */
  connect() {
    const { domElement } = this;
    if (!domElement)
      return;
    const options = false;
    domElement.tabIndex = 0;
    domElement.addEventListener("keydown", this.keydown, options);
    domElement.addEventListener("keyup", this.keyup, options);
    domElement.addEventListener("blur", this.blur, options);
    domElement.addEventListener("click", this.click, options);
    domElement.addEventListener("contextmenu", this.contextmenu, options);
    domElement.addEventListener("mousedown", this.mousedown, options);
    domElement.addEventListener("mouseup", this.mouseup, options);
    domElement.addEventListener("mousemove", this.mousemove, options);
    domElement.addEventListener("wheel", this.wheel, options);
    domElement.addEventListener("touchstart", this.touchstart, options);
    domElement.addEventListener("touchmove", this.touchmove, options);
    domElement.addEventListener("touchend", this.touchend, options);
    domElement.addEventListener("touchcancel", this.touchcancel, options);
    domElement.focus();
  }
  /** Unsubscribe to input events from {@link domElement}. */
  disconnect() {
    const { domElement } = this;
    if (!domElement)
      return;
    const options = false;
    domElement.removeEventListener("keydown", this.keydown, options);
    domElement.removeEventListener("keyup", this.keyup, options);
    domElement.removeEventListener("blur", this.blur, options);
    domElement.removeEventListener("click", this.click, options);
    domElement.removeEventListener("contextmenu", this.contextmenu, options);
    domElement.removeEventListener("mousedown", this.mousedown, options);
    domElement.removeEventListener("mouseup", this.mouseup, options);
    domElement.removeEventListener("mousemove", this.mousemove, options);
    domElement.removeEventListener("wheel", this.wheel, options);
    domElement.removeEventListener("touchstart", this.touchstart, options);
    domElement.removeEventListener("touchmove", this.touchmove, options);
    domElement.removeEventListener("touchend", this.touchend, options);
    domElement.removeEventListener("touchcancel", this.touchcancel, options);
  }
  click = (e) => {
    e.preventDefault();
  };
  contextmenu = (e) => {
    e.preventDefault();
  };
  static isGestureKey(code) {
    return _ControllerInput._gestureKeys.indexOf(code) != -1;
  }
  /** Indicate whether the mouse scroll wheel has recently been moved. */
  isScrolling() {
    return performance.now() - this._mouseWheelLastActive < 100;
  }
  updateModifierKeys(e) {
    const { _keys } = this;
    e.altKey ? _keys.add("Alt") : _keys.delete("Alt");
    e.shiftKey ? _keys.add("Shift") : _keys.delete("Shift");
    e.ctrlKey ? _keys.add("Control") : _keys.delete("Control");
  }
  keydown = (e) => {
    if (_ControllerInput.isGestureKey(e.code)) {
      e.preventDefault();
    }
    this.updateModifierKeys(e);
    this._keys.add(e.code);
    this._zoomX = 0;
    this._zoomY = 0;
  };
  keyup = (e) => {
    if (_ControllerInput.isGestureKey(e.code)) {
      e.preventDefault();
    }
    this.updateModifierKeys(e);
    this._keys.delete(e.code);
  };
  blur = (e) => {
    if ("exitPointerLock" in document)
      document.exitPointerLock();
    this._keys.clear();
  };
  mousedown = async (e) => {
    const { domElement, axes } = this;
    this._mouseButtonDown = true;
    domElement.focus();
    e.preventDefault();
    this.updateModifierKeys(e);
    this.callbacks?.mouseButtonChanged?.(e);
    await this.callbacks?.moveBegin?.(e);
    if (e.buttons & 16 /* forward */) {
      axes.mouse_navigate--;
    } else if (e.buttons & 8 /* backward */) {
      axes.mouse_navigate++;
    }
  };
  mouseup = async (e) => {
    e.preventDefault();
    this.updateModifierKeys(e);
    if ("exitPointerLock" in document)
      document.exitPointerLock();
    this.callbacks?.mouseButtonChanged?.(e);
    this._mouseButtonDown = false;
  };
  wheel = async (e) => {
    const { axes } = this;
    this._zoomX = e.offsetX;
    this._zoomY = e.offsetY;
    this.updateModifierKeys(e);
    await this.callbacks?.moveBegin?.(e);
    this._mouseWheelLastActive = performance.now();
    axes.mouse_wheel += e.deltaY;
  };
  mousemove = (e) => {
    if (e.buttons < 1)
      return;
    if (Math.abs(e.movementX) > 100 || Math.abs(e.movementY) > 100)
      return;
    this.updateModifierKeys(e);
    if (this._mouseButtonDown && this.usePointerLock) {
      e.currentTarget.requestPointerLock();
      this._mouseButtonDown = false;
    }
    const { axes } = this;
    if (e.buttons & 2 /* right */) {
      axes.mouse_rmb_move_x += e.movementX;
      axes.mouse_rmb_move_y += e.movementY;
    } else if (e.buttons & 4 /* middle */) {
      axes.mouse_mmb_move_x += e.movementX;
      axes.mouse_mmb_move_y += e.movementY;
    } else if (e.buttons & 1 /* left */) {
      axes.mouse_lmb_move_x += e.movementX;
      axes.mouse_lmb_move_y += e.movementY;
    }
  };
  touchstart = async (event) => {
    this.touchPoints = Array.from(event.touches).map((touch) => ({ id: touch.identifier, x: Math.round(touch.clientX), y: Math.round(touch.clientY) }));
    const { touchPoints, _touchMovePrev } = this;
    this.callbacks?.touchChanged?.(event);
    switch (touchPoints.length) {
      case 1:
        _touchMovePrev[0] = touchPoints[0].x;
        _touchMovePrev[1] = touchPoints[0].y;
        break;
      default:
        const dx = touchPoints[0].x - touchPoints[1].x;
        const dy = touchPoints[0].y - touchPoints[1].y;
        this._touchZoomDistancePrev = Math.sqrt(dx * dx + dy * dy);
        _touchMovePrev[0] = (touchPoints[0].x + touchPoints[1].x) / 2;
        _touchMovePrev[1] = (touchPoints[0].y + touchPoints[1].y) / 2;
        break;
    }
    await this.callbacks?.moveBegin?.(event);
  };
  touchend = async (event) => {
    this.touchPoints = Array.from(event.touches).map((touch) => ({ id: touch.identifier, x: Math.round(touch.clientX), y: Math.round(touch.clientY) }));
    const { touchPoints, _touchMovePrev } = this;
    this.callbacks?.touchChanged?.(event);
    switch (touchPoints.length) {
      case 0:
        break;
      case 1:
        _touchMovePrev[0] = touchPoints[0].x;
        _touchMovePrev[1] = touchPoints[0].y;
        break;
      default:
        const dx = touchPoints[0].x - touchPoints[1].x;
        const dy = touchPoints[0].y - touchPoints[1].y;
        this._touchZoomDistancePrev = Math.sqrt(dx * dx + dy * dy);
        _touchMovePrev[0] = (touchPoints[0].x + touchPoints[1].x) / 2;
        _touchMovePrev[1] = (touchPoints[0].y + touchPoints[1].y) / 2;
        break;
    }
  };
  touchcancel = (event) => {
    event.preventDefault();
    this.touchPoints = Array.from(event.touches).map((touch) => ({ id: touch.identifier, x: Math.round(touch.clientX), y: Math.round(touch.clientY) }));
  };
  touchmove = (event) => {
    if (event.cancelable)
      event.preventDefault();
    this.touchPoints = Array.from(event.touches).map((touch) => ({ id: touch.identifier, x: Math.round(touch.clientX), y: Math.round(touch.clientY) }));
    const { touchPoints, _touchMovePrev } = this;
    let { x, y } = touchPoints[0];
    const { axes } = this;
    if (touchPoints.length > 1) {
      const dx = touchPoints[0].x - touchPoints[1].x;
      const dy = touchPoints[0].y - touchPoints[1].y;
      const touchZoomDistance = Math.sqrt(dx * dx + dy * dy);
      x = (touchPoints[0].x + touchPoints[1].x) / 2;
      y = (touchPoints[0].y + touchPoints[1].y) / 2;
      const touchCenter = vec2_exports.fromValues(x, y);
      let dist4 = 0;
      if (this.prevTouchCenter) {
        dist4 = vec2_exports.dist(this.prevTouchCenter, touchCenter);
      }
      this.prevTouchCenter = touchCenter;
      const deltaWheel = this._touchZoomDistancePrev - touchZoomDistance;
      this._touchZoomDistancePrev = touchZoomDistance;
      this._zoomX = x;
      this._zoomY = y;
      if (dist4 * 2 < Math.abs(deltaWheel)) {
        if (touchPoints.length == 2) {
          axes.touch_pinch2 += deltaWheel;
        } else {
          axes.touch_pinch3 += deltaWheel;
        }
      }
    }
    switch (touchPoints.length) {
      case 1:
        axes.touch_1_move_x += x - _touchMovePrev[0];
        axes.touch_1_move_y += y - _touchMovePrev[1];
        break;
      case 2:
        axes.touch_2_move_x += x - _touchMovePrev[0];
        axes.touch_2_move_y += y - _touchMovePrev[1];
        break;
      case 3:
        axes.touch_3_move_x += x - _touchMovePrev[0];
        axes.touch_3_move_y += y - _touchMovePrev[1];
        break;
    }
    _touchMovePrev[0] = x;
    _touchMovePrev[1] = y;
  };
  /** Apply time-related state updates.
   * @param elapsedTime The amount of milliseconds passed since the last call to this function.
   */
  animate(elapsedTime) {
    const { axes, _keys } = this;
    const delta = elapsedTime * this.height / 2e3;
    if (_keys.size) {
      if (_keys.has("KeyA"))
        axes.keyboard_ad -= delta;
      if (_keys.has("KeyD"))
        axes.keyboard_ad += delta;
      if (_keys.has("KeyW"))
        axes.keyboard_ws -= delta;
      if (_keys.has("KeyS"))
        axes.keyboard_ws += delta;
      if (_keys.has("KeyQ"))
        axes.keyboard_qe += delta;
      if (_keys.has("KeyE"))
        axes.keyboard_qe -= delta;
      if (_keys.has("ArrowLeft"))
        axes.keyboard_arrow_left_right -= delta;
      if (_keys.has("ArrowRight"))
        axes.keyboard_arrow_left_right = delta;
      ;
      if (_keys.has("ArrowUp"))
        axes.keyboard_arrow_up_down -= delta;
      if (_keys.has("ArrowDown"))
        axes.keyboard_arrow_up_down += delta;
    }
  }
  /** Reset axes to their default/neutral state. */
  resetAxes() {
    const { axes } = this;
    axes.keyboard_ad = 0;
    axes.keyboard_ws = 0;
    axes.keyboard_qe = 0;
    axes.keyboard_arrow_left_right = 0;
    axes.keyboard_arrow_up_down = 0;
    axes.mouse_lmb_move_x = 0;
    axes.mouse_lmb_move_y = 0;
    axes.mouse_rmb_move_x = 0;
    axes.mouse_rmb_move_y = 0;
    axes.mouse_mmb_move_x = 0;
    axes.mouse_mmb_move_y = 0;
    axes.mouse_navigate = 0;
    axes.mouse_navigate = 0;
    axes.mouse_wheel = 0;
    axes.touch_1_move_x = 0;
    axes.touch_1_move_y = 0;
    axes.touch_2_move_x = 0;
    axes.touch_2_move_y = 0;
    axes.touch_3_move_x = 0;
    axes.touch_3_move_y = 0;
    axes.touch_pinch2 = 0;
    axes.touch_pinch3 = 0;
  }
  /** Determine if axes are all at their default/neutral state. */
  axesEmpty() {
    const { axes } = this;
    return axes.keyboard_ad == 0 && axes.keyboard_ws == 0 && axes.keyboard_qe == 0 && axes.keyboard_arrow_left_right == 0 && axes.keyboard_arrow_up_down == 0 && axes.mouse_lmb_move_x == 0 && axes.mouse_lmb_move_y == 0 && axes.mouse_rmb_move_x == 0 && axes.mouse_rmb_move_y == 0 && axes.mouse_mmb_move_x == 0 && axes.mouse_mmb_move_y == 0 && axes.mouse_navigate == 0 && axes.mouse_navigate == 0 && axes.mouse_wheel == 0 && axes.touch_1_move_x == 0 && axes.touch_1_move_y == 0 && axes.touch_2_move_x == 0 && axes.touch_2_move_y == 0 && axes.touch_3_move_x == 0 && axes.touch_3_move_y == 0 && axes.touch_pinch2 == 0 && axes.touch_pinch3 == 0;
  }
};
var MouseButtons = /* @__PURE__ */ ((MouseButtons2) => {
  MouseButtons2[MouseButtons2["none"] = 0] = "none";
  MouseButtons2[MouseButtons2["left"] = 1] = "left";
  MouseButtons2[MouseButtons2["right"] = 2] = "right";
  MouseButtons2[MouseButtons2["middle"] = 4] = "middle";
  MouseButtons2[MouseButtons2["backward"] = 8] = "backward";
  MouseButtons2[MouseButtons2["forward"] = 16] = "forward";
  return MouseButtons2;
})(MouseButtons || {});

// /projects/Novorender/ts/dist/web_app/controller/base.ts
var BaseController = class {
  /**
   * @param input The input source for this controller.
   */
  constructor(input) {
    this.input = input;
  }
  /**
   * Camera controller state generation.
   * @remarks
   * If the controller state changes, the generation count will be incremented once every call to {@link renderStateChanges}.
   * This can be used to detect changes by comparing to a local generation count.
   * The count is wrapped at 0xffffffff, so make sure you use != comparison and not < comparison.
   */
  get generation() {
    return this._generation;
  }
  /** Signal changes to internal state. */
  changed() {
    this._changed = true;
  }
  _changed = true;
  _generation = 0;
  _flyTo;
  _isMoving = false;
  /** The input axes
   * @see {@link ControllerInput.axes}
   */
  get axes() {
    return this.input.axes;
  }
  /** Whether the camera is currently considered moving or not.
   * @see {@link View.isIdleFrame}
   */
  get moving() {
    return this._isMoving;
  }
  /** The input element width.
   * @see {@link ControllerInput.width}
   */
  get width() {
    return this.input.width;
  }
  /** The input element height.
   * @see {@link ControllerInput.height}
   */
  get height() {
    return this.input.height;
  }
  /** The input multiplier.
   * @see {@link ControllerInput.multiplier}
   */
  get multiplier() {
    return this.input.multiplier;
  }
  /** The input zoom position.
   * @see {@link ControllerInput.zoomPos}
   */
  get zoomPos() {
    return this.input.zoomPos;
  }
  /** The input pointer table.
   * @see {@link ControllerInput.touchPoints}
   */
  get pointerTable() {
    return this.input.touchPoints;
  }
  /** The input shift button state.
   * @see {@link ControllerInput.hasShift}
   */
  get hasShift() {
    return this.input.hasShift;
  }
  /** The current fly-to state, if any. */
  get currentFlyTo() {
    return this._flyTo?.current;
  }
  /** Initialize a fly-to transition.
   * @param flyTo The transition parameters
   */
  setFlyTo(flyTo) {
    let { yaw } = flyTo.begin;
    const target = flyTo.end.yaw;
    if (yaw - target < -180)
      yaw += 360;
    else if (yaw - target > 180)
      yaw -= 360;
    const begin = { ...flyTo.begin, yaw };
    this._flyTo = { ...flyTo, begin, currentFlightTime: 0, current: begin };
  }
  /** Apply time sensitive changes to controller state.
   * @param elapsedTime The # of milliseconds elapsed since the last update.
   * @remarks
   * Fly-to animations happens here,
   * as well as motion based on keyboard pressed-state, such as the WASD keys.
   */
  animate(elapsedTime) {
    if (elapsedTime < 0 || elapsedTime > 250)
      elapsedTime = 1e3 / 60;
    this.input.animate(elapsedTime);
    const { _flyTo } = this;
    if (_flyTo) {
      if (_flyTo.currentFlightTime >= _flyTo.totalFlightTime) {
        this._flyTo = void 0;
      } else {
        _flyTo.currentFlightTime += elapsedTime;
        const { currentFlightTime, totalFlightTime, begin, end, current } = _flyTo;
        if (currentFlightTime < totalFlightTime) {
          const lerp5 = (a, b, t2) => a + (b - a) * t2;
          const easeInOut = (t2) => t2 < 0.5 ? 2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 2) / 2;
          const t = easeInOut(currentFlightTime / totalFlightTime);
          const pos = vec3_exports.lerp(vec3_exports.create(), begin.pos, end.pos, t);
          const pitch = lerp5(begin.pitch, end.pitch, t);
          let yaw = lerp5(begin.yaw, end.yaw, t);
          if (yaw < -180)
            yaw += 360;
          else if (yaw > 180)
            yaw -= 360;
          _flyTo.current = { pos, yaw, pitch };
        } else {
          Object.assign(current, end);
        }
      }
    }
  }
  /** Attach this controller to the input object */
  attach() {
    this.input.callbacks = this;
  }
  /** 
   * Handler for mouse buttons events.
   * @virtual
   */
  mouseButtonChanged(event) {
  }
  /** 
   * Handler for touch events.
   * @virtual
   */
  touchChanged(event) {
  }
  /** 
   * Handler for mouse/touch move events.
   * @virtual
   */
  moveBegin(event) {
  }
  /** Move controller to specified position/rotation.
   * @param targetPosition: The position to move to, in world space.
   * @param flyTime: The time, in milliseconds, for the transition animation to last, or 0 for instant update.
   * @param rotation: Optional target rotation, or undefined to retain current rotation.
   * @virtual
   */
  moveTo(targetPosition, flyTime = 1e3, rotation) {
  }
  /** Bring the specified bounding sphere into view.
   * @param boundingSphere: The bounding sphere to move into view.
   * @param flyTime: The time, in milliseconds, for the transition animation to last, or 0 for instant update.
   * @virtual
   * @remarks
   * This function will retain the current camera controller rotation.
   */
  zoomTo(boundingSphere, flyTime = 1e3) {
  }
  /** Retrieve the state changes to be applied to the specified render state.
   * @param state The baseline render state.
   * @param elapsedTime The time elapsed since last call, in milliseconds.
   */
  renderStateChanges(state, elapsedTime) {
    this.animate(elapsedTime);
    const { _changed, input, currentFlyTo } = this;
    if (_changed) {
      this._generation = this._generation + 1 & 4294967295;
      this._changed = false;
    }
    if (input.axesEmpty() && currentFlyTo == void 0 && !_changed) {
      this._isMoving = false;
      return;
    }
    this._isMoving = true;
    if (Object.values(input.axes).some((v) => v != 0) || currentFlyTo || _changed) {
      this.update();
      this.input.resetAxes();
      const changes = this.stateChanges(state);
      return Object.keys(changes).length ? { camera: changes } : void 0;
    }
  }
  /** Compute the distance to a point from the specified view plane.
   * @param point The point to measure distance too
   * @param cameraPosition The position of the camera/view plane.
   * @param cameraRotation The rotation of the camera/view plane.
   * @returns A signed distance from the point to the view plane, i.e. positive for points in front of the plane and negative otherwise.
   */
  static getDistanceFromViewPlane(point, cameraPosition, cameraRotation) {
    const dir = vec3_exports.fromValues(0, 0, -1);
    vec3_exports.transformQuat(dir, dir, cameraRotation);
    const offset = -vec3_exports.dot(dir, cameraPosition);
    return vec3_exports.dot(point, dir) + offset;
  }
};

// /projects/Novorender/ts/dist/web_app/controller/orientation.ts
var PitchRollYawOrientation = class {
  _pitch = 0;
  _yaw = 0;
  _roll = 0;
  _rot;
  /**
   * @param pitch Pitch angle, in degrees.
   * @param yaw Yaw angle, in degrees.
   * @param roll Roll angle, in degrees.
   */
  constructor(pitch = 0, yaw = 0, roll = 0) {
    this.pitch = pitch;
    this.yaw = yaw;
    this.roll = roll;
  }
  /** Pitch angle, in degrees. */
  get pitch() {
    return this._pitch;
  }
  set pitch(value) {
    value = clamp(value, -90, 90);
    if (value != this._pitch) {
      this._pitch = value;
      this._rot = void 0;
    }
  }
  /** Roll angle, in degrees. */
  get roll() {
    return this._roll;
  }
  set roll(value) {
    while (value >= 360)
      value -= 360;
    while (value < 0)
      value += 360;
    if (value != this._roll) {
      this._roll = value;
      this._rot = void 0;
    }
  }
  /** Yaw angle, in degrees. */
  get yaw() {
    return this._yaw;
  }
  set yaw(value) {
    while (value >= 360)
      value -= 360;
    while (value < 0)
      value += 360;
    if (value != this._yaw) {
      this._yaw = value;
      this._rot = void 0;
    }
  }
  /** Rotation expressed as a quaternion.
   * @remarks
   * The rotation will return a new object if after pitch, roll or yaw angles have changed since last time this accessor was called.
   * Othewise, it returns the previous, cached, object.
   * This enables {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality | strict equality}
   * to determine when the rotation remains unchanged.
   * @see {@link https://glmatrix.net/docs/module-quat.html}
   */
  get rotation() {
    if (!this._rot) {
      this._rot = this.computeRotation();
    }
    return this._rot;
  }
  /** Set pitch, roll and yaw angles from rotation quaternion.
   * @param rot The rotation quaternion to decompose into angles.
   */
  decomposeRotation(rot) {
    const { yaw, pitch, roll } = decomposeRotation(rot);
    this.yaw = yaw * 180 / Math.PI;
    this.pitch = pitch * 180 / Math.PI;
    this.roll = roll * 180 / Math.PI;
    this._rot = rot;
  }
  computeRotation() {
    const { _roll, _pitch, _yaw } = this;
    return computeRotation(_roll, _pitch, _yaw);
  }
};
function computeRotation(roll, pitch, yaw) {
  const halfYaw = common_exports.toRadian(yaw) * 0.5;
  const halfPitch = common_exports.toRadian(pitch) * 0.5;
  const halfRoll = common_exports.toRadian(roll) * 0.5;
  const sinRoll = Math.sin(halfRoll);
  const cosRoll = Math.cos(halfRoll);
  const sinPitch = Math.sin(halfPitch);
  const cosPitch = Math.cos(halfPitch);
  const sinYaw = Math.sin(halfYaw);
  const cosYaw = Math.cos(halfYaw);
  const x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
  const y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
  const z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
  const w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
  const flipYZ = quat_exports.fromValues(0.7071067811865475, 0, 0, 0.7071067811865476);
  return quat_exports.mul(quat_exports.create(), flipYZ, quat_exports.fromValues(x, y, z, w));
}
function decomposeRotation(rot) {
  const flipXZ = quat_exports.fromValues(-0.7071067811865475, 0, 0, 0.7071067811865476);
  const [qx, qy, qz, qw] = quat_exports.mul(quat_exports.create(), flipXZ, rot);
  const zAxisY = qy * qz - qx * qw;
  const limit = 0.4999999;
  let yaw = 0;
  let pitch = 0;
  let roll = 0;
  if (zAxisY < -limit) {
    yaw = 2 * Math.atan2(qy, qw);
    pitch = Math.PI / 2;
    roll = 0;
  } else if (zAxisY > limit) {
    yaw = 2 * Math.atan2(qy, qw);
    pitch = -Math.PI / 2;
    roll = 0;
  } else {
    const sqw = qw * qw;
    const sqz = qz * qz;
    const sqx = qx * qx;
    const sqy = qy * qy;
    roll = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
    pitch = Math.asin(-2 * zAxisY);
    yaw = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
  }
  return {
    /** The yaw angle, in radians. */
    yaw,
    /** The pitch angle, in radians. */
    pitch,
    /** The roll angle, in radians. */
    roll
  };
}
function clamp(value, min4, max4) {
  if (value < min4) {
    value = min4;
  } else if (value > max4) {
    value = max4;
  }
  return value;
}
function rotationFromDirection(dir, snapToAxis) {
  const up = common_exports.equals(Math.abs(vec3_exports.dot(vec3_exports.fromValues(0, 0, 1), dir)), 1) ? vec3_exports.fromValues(0, 1, 0) : vec3_exports.fromValues(0, 0, 1);
  if (snapToAxis) {
    vec3_exports.transformQuat(up, up, snapToAxis);
  }
  const right = vec3_exports.cross(vec3_exports.create(), up, dir);
  if (snapToAxis) {
    const [x, y, z] = right;
    right[0] = right[1] = right[2] = 0;
    const ax = Math.abs(x);
    const ay = Math.abs(y);
    const az = Math.abs(z);
    if (ax > ay && ax > az) {
      right[0] = Math.sign(x);
    } else if (ay > az) {
      right[1] = Math.sign(y);
    } else {
      right[2] = Math.sign(z);
    }
  }
  vec3_exports.cross(up, dir, right);
  vec3_exports.normalize(up, up);
  vec3_exports.cross(right, up, dir);
  vec3_exports.normalize(right, right);
  return quat_exports.fromMat3(
    quat_exports.create(),
    mat3_exports.fromValues(right[0], right[1], right[2], up[0], up[1], up[2], dir[0], dir[1], dir[2])
  );
}

// /projects/Novorender/ts/dist/web_app/controller/flight.ts
var FlightController = class _FlightController extends BaseController {
  /**
   * @param input The input source.
   * @param pick The context used for pick queries.
   */
  constructor(input, pick) {
    super(input);
    this.pick = pick;
  }
  /** @internal */
  arrowKeyScale = 0.4;
  /** @internal */
  pivotButton = 2 /* right */;
  /** @internal */
  pivotFingers = 3;
  kind = "flight";
  projection = "pinhole";
  params = {
    linearVelocity: 1,
    rotationalVelocity: 1,
    pickDelay: 200,
    proportionalCameraSpeed: null,
    // { min: 0.2, max: 1000 }
    enableShiftModifierOnWheel: false
  };
  _position = vec3_exports.create();
  _orientation = new PitchRollYawOrientation(-30, 30);
  _pivot;
  _fov = 60;
  resetPickDelay = 3e3;
  lastUpdatedMoveBegin = 0;
  lastUpdate = 0;
  moveBeginDelay = 0;
  recordedMoveBegin = void 0;
  inMoveBegin = false;
  /** Camera position, in world space. */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this.changed();
  }
  /** Computed rotation quaternion, in world space.
   * @remarks
   * This rotation is derived from {@link pitch} and {@link yaw} angles.
   */
  get rotation() {
    return this._orientation.rotation;
  }
  /** The camera pitch angle, in degrees. */
  get pitch() {
    return this._orientation.pitch;
  }
  set pitch(value) {
    this._orientation.pitch = value;
    this.changed();
  }
  /** The camera yaw angle, in degrees. */
  get yaw() {
    return this._orientation.yaw;
  }
  set yaw(value) {
    this._orientation.yaw = value;
    this.changed();
  }
  /** The camera vertical field of view angle, in degrees. */
  get fov() {
    return this._fov;
  }
  set fov(value) {
    this._fov = value;
    this.changed();
  }
  /** The optional pivot point to orbit around, in world space. */
  get pivot() {
    return this._pivot;
  }
  /** Update controller parameters.
   * @param params Set of parameters to change.
   */
  updateParams(params) {
    this.params = mergeRecursive(this.params, params);
  }
  serialize() {
    const { kind, position, _orientation, _fov } = this;
    const { rotation } = _orientation;
    return { kind, position, rotation, fovDegrees: _fov };
  }
  init(params) {
    const { kind, position, rotation, fovDegrees } = params;
    console.assert(kind == this.kind);
    if (position) {
      this._position = position;
    }
    if (rotation) {
      this._orientation.decomposeRotation(rotation);
      this._orientation.roll = 0;
    }
    if (fovDegrees != void 0) {
      this._fov = fovDegrees;
    }
    this.input.callbacks = this;
    this.input.usePointerLock = true;
  }
  autoFit(center, radius) {
    const { _orientation } = this;
    const maxDistance = 1e3;
    const distance4 = Math.min(maxDistance, radius / Math.tan(common_exports.toRadian(this._fov) / 2));
    const dir = vec3_exports.fromValues(0, 0, distance4);
    vec3_exports.transformQuat(dir, dir, _orientation.rotation);
    this._position = vec3_exports.add(vec3_exports.create(), center, dir);
  }
  moveTo(targetPosition, flyTime = 1e3, rotation) {
    const { _orientation, _position } = this;
    if (flyTime) {
      let targetPitch = _orientation.pitch;
      let targetYaw = _orientation.yaw;
      if (rotation) {
        const { pitch, yaw } = decomposeRotation(rotation);
        targetPitch = pitch / Math.PI * 180;
        targetYaw = yaw / Math.PI * 180;
      }
      this.setFlyTo({
        totalFlightTime: flyTime,
        end: { pos: vec3_exports.clone(targetPosition), pitch: targetPitch, yaw: targetYaw },
        begin: { pos: vec3_exports.clone(_position), pitch: _orientation.pitch, yaw: _orientation.yaw }
      });
    } else {
      this._position = targetPosition;
      if (rotation) {
        this._orientation.decomposeRotation(rotation);
      }
      this.changed();
    }
  }
  zoomTo(boundingSphere, flyTime = 1e3) {
    const { _orientation, _position, _fov } = this;
    if (flyTime) {
      const dist4 = Math.max(boundingSphere.radius / Math.tan(common_exports.toRadian(_fov) / 2), boundingSphere.radius);
      const targetPosition = vec3_exports.create();
      vec3_exports.add(targetPosition, vec3_exports.transformQuat(targetPosition, vec3_exports.fromValues(0, 0, dist4), _orientation.rotation), boundingSphere.center);
      this.setFlyTo({
        totalFlightTime: flyTime,
        end: { pos: vec3_exports.clone(targetPosition), pitch: _orientation.pitch, yaw: _orientation.yaw + 0.05 },
        begin: { pos: vec3_exports.clone(_position), pitch: _orientation.pitch, yaw: _orientation.yaw }
      });
    } else {
      const dist4 = boundingSphere.radius / Math.tan(common_exports.toRadian(_fov) / 2);
      this._position = vec3_exports.add(vec3_exports.create(), vec3_exports.transformQuat(vec3_exports.create(), vec3_exports.fromValues(0, 0, dist4), _orientation.rotation), boundingSphere.center);
      this.changed();
    }
  }
  update() {
    const { multiplier, _orientation, params, height, _pivot, zoomPos, currentFlyTo } = this;
    if (currentFlyTo) {
      this._position = vec3_exports.clone(currentFlyTo.pos);
      _orientation.pitch = currentFlyTo.pitch;
      _orientation.yaw = currentFlyTo.yaw;
      this.changed();
      return;
    }
    this.lastUpdate = performance.now();
    let { tx, ty, tz, rx, ry, shouldPivot } = this.getTransformations();
    _orientation.roll = 0;
    const [zoomX, zoomY] = zoomPos;
    if (rx || ry) {
      const rotationalVelocity = (shouldPivot ? 180 : this._fov) * params.rotationalVelocity / height;
      _orientation.pitch += rx * rotationalVelocity;
      _orientation.yaw += ry * rotationalVelocity;
      if (_pivot && shouldPivot && _pivot.active) {
        const { center, offset, distance: distance4 } = _pivot;
        const pos = vec3_exports.fromValues(0, 0, distance4);
        vec3_exports.add(pos, pos, offset);
        vec3_exports.transformQuat(pos, pos, _orientation.rotation);
        this._position = vec3_exports.add(vec3_exports.create(), center, pos);
      }
      this.changed();
    }
    if (tx || ty || tz) {
      if (tz != 0) {
        tx += zoomX * tz * 0.6;
        ty += -zoomY * tz * 0.6;
      }
      const linearVelocity = multiplier * params.linearVelocity / height;
      const worldPosDelta = vec3_exports.transformQuat(vec3_exports.create(), vec3_exports.fromValues(tx * linearVelocity, -ty * linearVelocity, tz * linearVelocity), _orientation.rotation);
      this._position = vec3_exports.add(vec3_exports.create(), this._position, worldPosDelta);
      if (_pivot && _pivot.active) {
        this.setPivot(_pivot.center, _pivot.active);
      }
      this.changed();
    }
  }
  stateChanges(state) {
    const changes = {};
    const { _position, _orientation, _pivot, _fov } = this;
    if (!state || !vec3_exports.exactEquals(state.position, _position)) {
      changes.position = _position;
    }
    if (!state || !quat_exports.exactEquals(state.rotation, _orientation.rotation)) {
      changes.rotation = _orientation.rotation;
    }
    if (!state || _pivot && state.pivot && vec3_exports.exactEquals(state.pivot, _pivot?.center)) {
      changes.pivot = _pivot?.center;
    }
    if (!state || state.fov !== _fov) {
      changes.fov = _fov;
    }
    if (!state) {
      changes.kind = "pinhole";
    }
    return changes;
  }
  async mouseButtonChanged(event) {
    const { pick, pivotButton } = this;
    if (pick) {
      const changes = event.buttons;
      if (changes & pivotButton) {
        const sample = await pick.pick(event.offsetX, event.offsetY);
        if (sample) {
          this.setPivot(sample.position, true);
        } else {
          this.resetPivot(true);
        }
      } else {
        this.resetPivot(false);
      }
    }
  }
  async touchChanged(event) {
    const { pointerTable, pick, pivotFingers } = this;
    if (pointerTable.length == pivotFingers && pick) {
      const x = pointerTable.length > 1 ? Math.round((pointerTable[0].x + pointerTable[1].x) / 2) : pointerTable[0].x;
      const y = pointerTable.length > 1 ? Math.round((pointerTable[0].y + pointerTable[1].y) / 2) : pointerTable[0].y;
      const sample = await pick.pick(x, y);
      if (sample) {
        this.setPivot(sample.position, true);
      } else {
        this.resetPivot(true);
      }
    } else {
      this.resetPivot(false);
    }
  }
  async moveBegin(event) {
    const { pointerTable, pick, resetPickDelay } = this;
    const deltaTime = this.lastUpdate - this.lastUpdatedMoveBegin;
    if (pick == void 0 || deltaTime < this.params.pickDelay || this.inMoveBegin) {
      return;
    }
    this.inMoveBegin = true;
    const setPickPosition = async (x, y) => {
      const sample = await pick.pick(x, y, { async: true });
      if (sample) {
        if (performance.now() - this.lastUpdatedMoveBegin > 2e3) {
          this.moveBeginDelay = performance.now();
        }
        this.recordedMoveBegin = sample.position;
        this.lastUpdatedMoveBegin = performance.now();
      } else if (resetPickDelay < deltaTime) {
        this.recordedMoveBegin = void 0;
        this.lastUpdatedMoveBegin = performance.now();
      }
    };
    if (isTouchEvent(event)) {
      if (pointerTable.length > 1) {
        await setPickPosition(Math.round((pointerTable[0].x + pointerTable[1].x) / 2), Math.round((pointerTable[0].y + pointerTable[1].y) / 2));
      }
    } else {
      await setPickPosition(event.offsetX, event.offsetY);
    }
    this.inMoveBegin = false;
  }
  resetPivot(active) {
    const { _pivot } = this;
    if (_pivot) {
      this.setPivot(_pivot.center, active);
    }
  }
  setPivot(center, active) {
    const { _position, _orientation } = this;
    const distance4 = vec3_exports.distance(center, _position);
    const offset = vec3_exports.fromValues(0, 0, distance4);
    vec3_exports.transformQuat(offset, offset, _orientation.rotation);
    vec3_exports.add(offset, center, offset);
    vec3_exports.sub(offset, _position, offset);
    const invRot = quat_exports.invert(quat_exports.create(), _orientation.rotation);
    vec3_exports.transformQuat(offset, offset, invRot);
    this._pivot = { center, offset, distance: distance4, active };
  }
  /** @internal */
  modifiers() {
    const { params, recordedMoveBegin, _position, _fov } = this;
    const { proportionalCameraSpeed, enableShiftModifierOnWheel } = params;
    let scale7 = 20;
    if (proportionalCameraSpeed && recordedMoveBegin) {
      scale7 = vec3_exports.dist(_position, recordedMoveBegin) * Math.tan(Math.PI / 180 * _fov / 2) * 2;
      const siceMoveDelay = performance.now() - this.moveBeginDelay;
      if (siceMoveDelay < 400) {
        scale7 = Math.min(scale7, 60 + siceMoveDelay * 0.5);
      }
      let mouseWheelModifier = this.input.hasShift && !enableShiftModifierOnWheel ? 0 : clamp(scale7 / 3, proportionalCameraSpeed.min, proportionalCameraSpeed.max);
      const mousePanModifier = clamp(scale7, proportionalCameraSpeed.min, proportionalCameraSpeed.max);
      const touchMovementModifier = clamp(scale7, proportionalCameraSpeed.min, proportionalCameraSpeed.max);
      const pinchModifier = clamp(scale7, proportionalCameraSpeed.min, proportionalCameraSpeed.max);
      return {
        mouseWheelModifier,
        mousePanModifier,
        touchMovementModifier,
        pinchModifier,
        scale: 20
      };
    }
    return {
      mouseWheelModifier: this.input.hasShift && !enableShiftModifierOnWheel ? 0 : scale7,
      mousePanModifier: scale7,
      touchMovementModifier: scale7,
      pinchModifier: scale7,
      scale: scale7
    };
  }
  /** @internal */
  getTransformations() {
    const { axes, arrowKeyScale } = this;
    const rotX = -axes.keyboard_arrow_up_down * arrowKeyScale - axes.mouse_lmb_move_y + axes.touch_1_move_y;
    const rotY = -axes.keyboard_arrow_left_right * arrowKeyScale - axes.mouse_lmb_move_x + axes.touch_1_move_x;
    const pivotX = -axes.mouse_rmb_move_y + -axes.touch_3_move_y;
    const pivotY = -axes.mouse_rmb_move_x + -axes.touch_3_move_x;
    const shouldPivot = Math.abs(rotX) + Math.abs(rotY) < Math.abs(pivotX) + Math.abs(pivotY);
    const { mouseWheelModifier, mousePanModifier, touchMovementModifier, pinchModifier, scale: scale7 } = this.modifiers();
    const tx = axes.keyboard_ad * scale7 - axes.mouse_mmb_move_x * mousePanModifier - axes.touch_2_move_x * touchMovementModifier;
    const ty = axes.keyboard_qe * scale7 - axes.mouse_mmb_move_y * mousePanModifier - axes.touch_2_move_y * touchMovementModifier;
    const tz = axes.keyboard_ws * scale7 + axes.mouse_wheel * mouseWheelModifier + axes.touch_pinch2 * pinchModifier;
    const rx = shouldPivot ? pivotX : rotX;
    const ry = shouldPivot ? pivotY : rotY;
    return { tx, ty, tz, rx, ry, shouldPivot };
  }
  /** FlightController type guard function.
   * @param controller The controller to type guard.
   */
  static is(controller) {
    return controller instanceof _FlightController;
  }
  /** FlightController type assert function.
   * @param controller The controller to type assert.
   */
  static assert(controller) {
    if (!(controller instanceof _FlightController))
      throw new Error("Camera controller is not of type FlightController!");
  }
};
function isTouchEvent(event) {
  return "TouchEvent" in globalThis && event instanceof TouchEvent;
}
var CadMiddlePanController = class extends FlightController {
  constructor(input, pick, params) {
    super(input, pick);
    this.pick = pick;
    this.pivotButton = 1 /* left */;
    this.pivotFingers = 1;
  }
  kind = "cadMiddlePan";
  getTransformations() {
    const { axes, arrowKeyScale } = this;
    const rotX = -axes.keyboard_arrow_up_down * arrowKeyScale - axes.mouse_rmb_move_y + axes.touch_3_move_y;
    const rotY = -axes.keyboard_arrow_left_right * arrowKeyScale - axes.mouse_rmb_move_x + axes.touch_3_move_x;
    const pivotX = -axes.mouse_lmb_move_y + -axes.touch_1_move_y;
    const pivotY = -axes.mouse_lmb_move_x + -axes.touch_1_move_x;
    const shouldPivot = Math.abs(rotX) + Math.abs(rotY) < Math.abs(pivotX) + Math.abs(pivotY);
    const { mouseWheelModifier, mousePanModifier, touchMovementModifier, pinchModifier, scale: scale7 } = this.modifiers();
    const tx = axes.keyboard_ad * scale7 - axes.mouse_mmb_move_x * mousePanModifier - axes.touch_2_move_x * touchMovementModifier;
    const ty = axes.keyboard_qe * scale7 - axes.mouse_mmb_move_y * mousePanModifier - axes.touch_2_move_y * touchMovementModifier;
    const tz = axes.keyboard_ws * scale7 + axes.mouse_wheel * mouseWheelModifier + axes.touch_pinch2 * pinchModifier;
    const rx = shouldPivot ? pivotX : rotX;
    const ry = shouldPivot ? pivotY : rotY;
    return { tx, ty, tz, rx, ry, shouldPivot };
  }
};
var CadRightPanController = class extends FlightController {
  constructor(input, pick, params) {
    super(input, pick);
    this.pick = pick;
    this.pivotButton = 1 /* left */;
    this.pivotFingers = 1;
  }
  kind = "cadRightPan";
  getTransformations() {
    const { axes, arrowKeyScale } = this;
    const rotX = -axes.keyboard_arrow_up_down * arrowKeyScale - axes.mouse_mmb_move_y + axes.touch_3_move_y;
    const rotY = -axes.keyboard_arrow_left_right * arrowKeyScale - axes.mouse_mmb_move_x + axes.touch_3_move_x;
    const pivotX = -axes.mouse_lmb_move_y + -axes.touch_1_move_y;
    const pivotY = -axes.mouse_lmb_move_x + -axes.touch_1_move_x;
    const shouldPivot = Math.abs(rotX) + Math.abs(rotY) < Math.abs(pivotX) + Math.abs(pivotY);
    const { mouseWheelModifier, mousePanModifier, touchMovementModifier, pinchModifier, scale: scale7 } = this.modifiers();
    const tx = axes.keyboard_ad * scale7 - axes.mouse_rmb_move_x * mousePanModifier - axes.touch_2_move_x * touchMovementModifier;
    const ty = axes.keyboard_qe * scale7 - axes.mouse_rmb_move_y * mousePanModifier - axes.touch_2_move_y * touchMovementModifier;
    const tz = axes.keyboard_ws * scale7 + axes.mouse_wheel * mouseWheelModifier + axes.touch_pinch2 * pinchModifier;
    const rx = shouldPivot ? pivotX : rotX;
    const ry = shouldPivot ? pivotY : rotY;
    return { tx, ty, tz, rx, ry, shouldPivot };
  }
};
var SpecialFlightController = class extends FlightController {
  constructor(input, pick, params) {
    super(input, pick);
    this.pick = pick;
    this.pivotButton = 4 /* middle */;
    this.pivotFingers = 1;
  }
  kind = "special";
  getTransformations() {
    const { axes, arrowKeyScale } = this;
    const rotX = -axes.keyboard_arrow_up_down * arrowKeyScale - axes.mouse_rmb_move_y + axes.touch_3_move_y;
    const rotY = -axes.keyboard_arrow_left_right * arrowKeyScale - axes.mouse_rmb_move_x + axes.touch_3_move_x;
    const pivotX = -axes.mouse_mmb_move_y + -axes.touch_1_move_y;
    const pivotY = -axes.mouse_mmb_move_x + -axes.touch_1_move_x;
    const shouldPivot = Math.abs(rotX) + Math.abs(rotY) < Math.abs(pivotX) + Math.abs(pivotY);
    const { mouseWheelModifier, mousePanModifier, touchMovementModifier, pinchModifier, scale: scale7 } = this.modifiers();
    const tx = axes.keyboard_ad * scale7 - axes.mouse_lmb_move_x * mousePanModifier - axes.touch_2_move_x * touchMovementModifier;
    const ty = axes.keyboard_qe * scale7 - axes.mouse_lmb_move_y * mousePanModifier - axes.touch_2_move_y * touchMovementModifier;
    const tz = axes.keyboard_ws * scale7 + axes.mouse_wheel * mouseWheelModifier + axes.touch_pinch2 * pinchModifier;
    const rx = shouldPivot ? pivotX : rotX;
    const ry = shouldPivot ? pivotY : rotY;
    return { tx, ty, tz, rx, ry, shouldPivot };
  }
};

// /projects/Novorender/ts/dist/web_app/controller/null.ts
var NullController = class _NullController extends BaseController {
  kind = "null";
  projection = void 0;
  /**
   * @param input The input source.
   */
  constructor(input) {
    super(input);
  }
  serialize() {
    const { kind } = this;
    return { kind };
  }
  init(params) {
    const { kind } = params;
    console.assert(kind == this.kind);
    this.input.usePointerLock = false;
    this.attach();
  }
  autoFit(center, radius) {
  }
  update() {
  }
  stateChanges(state) {
    return {};
  }
  /** NullController type guard function.
   * @param controller The controller to type guard.
   */
  static is(controller) {
    return controller instanceof _NullController;
  }
  /** NullController type assert function.
   * @param controller The controller to type assert.
   */
  static assert(controller) {
    if (!(controller instanceof _NullController))
      throw new Error("Camera controller is not of type NullController!");
  }
};

// /projects/Novorender/ts/dist/web_app/controller/orbit.ts
var OrbitController = class _OrbitController extends BaseController {
  kind = "orbit";
  projection = "pinhole";
  params = {
    maxDistance: 1e3,
    linearVelocity: 1,
    rotationalVelocity: 1
  };
  _orientation = new PitchRollYawOrientation(-30, 30);
  _pivot = vec3_exports.create();
  _distance = 10;
  _fov = 60;
  /**
   * @param input The input source.
   * @param params Optional initialization parameters.
   */
  constructor(input, params) {
    super(input);
    Object.assign(this.params, params);
  }
  /** The current controller parameters. */
  get parameters() {
    return this.params;
  }
  /** Computed position, in world space.
   * @remarks
   * This position is derived from {@link pivot} point, {@link distance}, rotated around {@link pitch} and {@link yaw} angles.
   */
  get position() {
    const { _orientation, _pivot, _distance } = this;
    const pos = vec3_exports.fromValues(0, 0, _distance);
    vec3_exports.transformQuat(pos, pos, _orientation.rotation);
    vec3_exports.add(pos, pos, _pivot);
    return pos;
  }
  /** Computed rotation quaternion, in world space.
   * @remarks
   * This rotation is derived from {@link pitch} and {@link yaw} angles.
   */
  get rotation() {
    return this._orientation.rotation;
  }
  /** The pitch angle around the pivot point, in degrees. */
  get pitch() {
    return this._orientation.pitch;
  }
  set pitch(value) {
    this._orientation.pitch = value;
    this.changed();
  }
  /** The yaw angle around the pivot point, in degrees. */
  get yaw() {
    return this._orientation.yaw;
  }
  set yaw(value) {
    this._orientation.yaw = value;
    this.changed();
  }
  /** The pivot point to orbit around, in world space. */
  get pivot() {
    return this._pivot;
  }
  set pivot(value) {
    this._pivot = value;
    this.changed();
  }
  /** The distance from the pivot point, in meters. */
  get distance() {
    return this._distance;
  }
  set distance(value) {
    this._distance = value;
    this.changed();
  }
  /** The camera vertical field of view angle, in degrees. */
  get fov() {
    return this._fov;
  }
  set fov(value) {
    this._fov = value;
    this.changed();
  }
  /** Update controller parameters.
   * @param params Set of parameters to change.
   */
  updateParams(params) {
    this.params = mergeRecursive(this.params, params);
  }
  serialize(includeDerived = false) {
    const { kind, pivot, _orientation, distance: distance4, fov } = this;
    const { rotation } = _orientation;
    return { kind, pivot, rotation, distance: distance4, fovDegrees: fov, ...includeDerived ? { position: this.position } : void 0 };
  }
  init(params) {
    const { kind, position, rotation, pivot, fovDegrees, distance: distance4 } = params;
    console.assert(kind == this.kind);
    if (fovDegrees != void 0) {
      this._fov = fovDegrees;
    }
    if (pivot) {
      this._pivot = pivot;
    }
    if (rotation) {
      this._orientation.decomposeRotation(rotation);
      this._orientation.roll = 0;
    }
    if (distance4) {
      this._distance = distance4;
      if (!pivot && position && rotation) {
        const tmp = vec3_exports.fromValues(0, 0, -distance4);
        vec3_exports.transformQuat(tmp, tmp, rotation);
        this._pivot = vec3_exports.add(tmp, tmp, position);
      }
    }
    if (position && pivot) {
      const { _orientation } = this;
      if (!distance4) {
        this._distance = vec3_exports.distance(position, pivot);
      }
      if (!rotation) {
        const [x, y, z] = vec3_exports.sub(vec3_exports.create(), position, pivot);
        const pitch = Math.atan2(-y, vec2_exports.len(vec2_exports.fromValues(x, z)));
        const yaw = Math.atan2(x, z);
        _orientation.yaw = yaw * 180 / Math.PI;
        _orientation.pitch = pitch * 180 / Math.PI;
        _orientation.roll = 0;
      }
    }
    this.attach();
    this.changed();
  }
  autoFit(center, radius) {
    const { params } = this;
    this._pivot = center;
    this._distance = Math.min(params.maxDistance, radius / Math.tan(common_exports.toRadian(this._fov) / 2));
    this.changed();
  }
  update() {
    const { axes, multiplier, _pivot, _orientation, _distance, _fov, params, height } = this;
    const tx = axes.keyboard_ad + axes.mouse_rmb_move_x - axes.touch_2_move_x;
    const ty = -axes.keyboard_qe + axes.mouse_rmb_move_y - axes.touch_2_move_y;
    const tz = axes.keyboard_ws * 2 + axes.mouse_mmb_move_y + axes.mouse_wheel / 2 + axes.touch_pinch2 * 2;
    const rx = axes.keyboard_arrow_up_down / 5 + axes.mouse_lmb_move_y + axes.touch_1_move_y;
    const ry = axes.keyboard_arrow_left_right / 5 + axes.mouse_lmb_move_x + axes.touch_1_move_x;
    _orientation.roll = 0;
    const rotationalVelocity = 180 * params.rotationalVelocity / height;
    if (rx || ry) {
      _orientation.pitch += -rx * rotationalVelocity;
      _orientation.yaw += -ry * rotationalVelocity;
      this.changed();
    }
    const fovRatio = Math.tan(Math.PI / 180 * _fov / 2) * 2;
    const linearVelocity = _distance * fovRatio * multiplier * params.linearVelocity / height;
    if (tz) {
      this._distance += tz * linearVelocity;
      this.changed();
    } else if (tx || ty) {
      const worldPosDelta = vec3_exports.transformQuat(vec3_exports.create(), vec3_exports.fromValues(tx * linearVelocity, -ty * linearVelocity, 0), _orientation.rotation);
      this._pivot = vec3_exports.add(vec3_exports.create(), _pivot, worldPosDelta);
      this.changed();
    }
  }
  stateChanges(state) {
    const { _pivot, _orientation, position, _fov } = this;
    const changes = {};
    if (!state || !vec3_exports.exactEquals(state.position, position)) {
      changes.position = position;
    }
    if (!state || state.rotation !== _orientation.rotation) {
      changes.rotation = _orientation.rotation;
    }
    if (!state || state.pivot !== _pivot) {
      changes.pivot = _pivot;
    }
    if (!state || state.fov !== _fov) {
      changes.fov = _fov;
    }
    if (!state) {
      changes.kind = "pinhole";
    }
    return changes;
  }
  /** OrbitController type guard function.
   * @param controller The controller to type guard.
   */
  static is(controller) {
    return controller instanceof _OrbitController;
  }
  /** OrbitController type assert function.
   * @param controller The controller to type assert.
   */
  static assert(controller) {
    if (!(controller instanceof _OrbitController))
      throw new Error("Camera controller is not of type OrbitController!");
  }
};

// /projects/Novorender/ts/dist/web_app/controller/ortho.ts
var OrthoController = class _OrthoController extends BaseController {
  kind = "ortho";
  projection = "orthographic";
  params = {
    stepInterval: 1,
    usePointerLock: false
  };
  _position = vec3_exports.create();
  _orientation = new PitchRollYawOrientation();
  _fov = 50;
  /**
   * @param input The input source.
   */
  constructor(input) {
    super(input);
  }
  /** Camera position, in world space. */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this.changed();
  }
  /** Computed rotation quaternion, in world space.
   * @remarks
   * This rotation is derived from {@link pitch}, {@link yaw} and  {@link roll} angles.
   */
  get rotation() {
    return this._orientation.rotation;
  }
  /** The camera pitch angle, in degrees. */
  get pitch() {
    return this._orientation.pitch;
  }
  set pitch(value) {
    this._orientation.pitch = value;
    this.changed();
  }
  /** The camera yaw angle, in degrees. */
  get yaw() {
    return this._orientation.yaw;
  }
  set yaw(value) {
    this._orientation.yaw = value;
    this.changed();
  }
  /** The camera roll angle, in degrees. */
  get roll() {
    return this._orientation.roll;
  }
  set roll(value) {
    this._orientation.roll = value;
    this.changed();
  }
  /** The camera vertical field of view angle, in meters. */
  get fov() {
    return this._fov;
  }
  set fov(value) {
    this._fov = value;
    this.changed();
  }
  /** Update controller parameters.
   * @param params Set of parameters to change.
   */
  updateParams(params) {
    this.params = mergeRecursive(this.params, params);
    if (this.input.callbacks == this) {
      this.input.usePointerLock = this.params.usePointerLock;
    }
  }
  serialize() {
    const { kind, position, _orientation, _fov } = this;
    const { rotation } = _orientation;
    return { kind, position, rotation, fovMeters: _fov };
  }
  init(params) {
    const { kind, position, rotation, fovMeters, distance: distance4, fovDegrees } = params;
    console.assert(kind == this.kind);
    if (position) {
      this._position = position;
    }
    if (rotation) {
      this._orientation.decomposeRotation(rotation);
    }
    if (fovMeters) {
      this._fov = fovMeters;
    } else if (fovDegrees && distance4) {
      this._fov = _OrthoController.fovFromPerspective(fovDegrees, distance4);
    }
    this.changed();
    this.input.usePointerLock = this.params.usePointerLock;
    this.input.callbacks = this;
  }
  autoFit(center, radius) {
    const { _orientation } = this;
    const dir = vec3_exports.fromValues(0, 0, radius);
    vec3_exports.transformQuat(dir, dir, _orientation.rotation);
    this._position = vec3_exports.add(vec3_exports.create(), center, dir);
    this._orientation.pitch = -90;
    this._orientation.yaw = 0;
    this._orientation.roll = 0;
    this._fov = radius * 2;
    this.changed();
  }
  moveTo(targetPosition, flyTime = 1e3, rotation) {
    const { _orientation, _position } = this;
    if (flyTime) {
      let targetPitch = _orientation.pitch;
      let targetYaw = _orientation.yaw;
      if (rotation) {
        const { pitch, yaw } = decomposeRotation(rotation);
        targetPitch = pitch / Math.PI * 180;
        targetYaw = yaw / Math.PI * 180;
      }
      this.setFlyTo({
        totalFlightTime: flyTime,
        end: { pos: vec3_exports.clone(targetPosition), pitch: targetPitch, yaw: targetYaw },
        begin: { pos: vec3_exports.clone(_position), pitch: _orientation.pitch, yaw: _orientation.yaw }
      });
    } else {
      this._position = targetPosition;
      if (rotation) {
        this._orientation.decomposeRotation(rotation);
      }
      this.changed();
    }
  }
  zoomTo(boundingSphere, flyTime = 1e3) {
    const { _orientation, _position, _fov } = this;
    if (flyTime) {
      const dist4 = Math.max(boundingSphere.radius / Math.tan(common_exports.toRadian(_fov) / 2), boundingSphere.radius);
      const targetPosition = vec3_exports.create();
      vec3_exports.add(targetPosition, vec3_exports.transformQuat(targetPosition, vec3_exports.fromValues(0, 0, dist4), _orientation.rotation), boundingSphere.center);
      this.setFlyTo({
        totalFlightTime: flyTime,
        end: { pos: vec3_exports.clone(targetPosition), pitch: _orientation.pitch, yaw: _orientation.yaw + 0.05 },
        begin: { pos: vec3_exports.clone(_position), pitch: _orientation.pitch, yaw: _orientation.yaw }
      });
    } else {
      const dist4 = boundingSphere.radius / Math.tan(common_exports.toRadian(_fov) / 2);
      this._position = vec3_exports.add(vec3_exports.create(), vec3_exports.transformQuat(vec3_exports.create(), vec3_exports.fromValues(0, 0, dist4), _orientation.rotation), boundingSphere.center);
      this.changed();
    }
  }
  update() {
    const { axes, zoomPos, height, _position, _orientation, hasShift, currentFlyTo } = this;
    if (currentFlyTo) {
      this._position = vec3_exports.clone(currentFlyTo.pos);
      _orientation.pitch = currentFlyTo.pitch;
      _orientation.yaw = currentFlyTo.yaw;
      this.changed();
      return;
    }
    let tx = -axes.keyboard_ad + axes.mouse_lmb_move_x + axes.mouse_rmb_move_x + axes.mouse_mmb_move_x + axes.touch_1_move_x;
    let ty = -axes.keyboard_ws + axes.mouse_lmb_move_y + axes.mouse_rmb_move_y + axes.mouse_mmb_move_y + axes.touch_1_move_y;
    const tz = axes.touch_pinch3 * 0.1 + (hasShift ? axes.mouse_wheel * 0.01 : 0);
    const rz = -axes.keyboard_arrow_left_right / 2;
    const zoom = (hasShift ? 0 : axes.mouse_wheel) + axes.touch_pinch2 - axes.keyboard_qe;
    const [zoomX, zoomY] = zoomPos;
    if (rz) {
      _orientation.roll += rz * 0.2;
      this.changed();
    }
    if (tx || ty || tz || zoom) {
      if (zoom != 0) {
        const dz = 1 + zoom / height;
        tx += zoomX * -zoom * 0.6;
        ty += zoomY * zoom * 0.6;
        this._fov *= dz;
      }
      const scale7 = this._fov / height;
      const deltaPos = vec3_exports.transformQuat(vec3_exports.create(), vec3_exports.fromValues(tx * scale7 * -1, ty * scale7, tz), _orientation.rotation);
      this._position = vec3_exports.add(vec3_exports.create(), _position, deltaPos);
      this.changed();
    }
  }
  stateChanges(state) {
    const changes = {};
    if (!state || state.position !== this._position) {
      changes.position = this._position;
    }
    if (!state || state.rotation !== this._orientation.rotation) {
      changes.rotation = this._orientation.rotation;
    }
    if (!state || state.fov !== this._fov) {
      changes.fov = this._fov;
    }
    if (!state) {
      changes.kind = "orthographic";
    }
    return changes;
  }
  //perspectiveDepth = BaseController.getDistanceFromViewPlane(pivot);
  static fovFromPerspective(perspectiveFov, perspectiveDepth) {
    return Math.max(0.1, perspectiveDepth) * Math.tan(Math.PI / 180 * perspectiveFov / 2) * 2;
  }
  /** OrthoController type guard function.
   * @param controller The controller to type guard.
   */
  static is(controller) {
    return controller instanceof _OrthoController;
  }
  /** OrthoController type assert function.
   * @param controller The controller to type assert.
   */
  static assert(controller) {
    if (!(controller instanceof _OrthoController))
      throw new Error("Camera controller is not of type OrthoController!");
  }
};

// /projects/Novorender/ts/dist/web_app/controller/panorama.ts
var PanoramaController = class _PanoramaController extends BaseController {
  kind = "panorama";
  projection = "pinhole";
  params = {
    rotationalVelocity: 1
  };
  _position = vec3_exports.create();
  _orientation = new PitchRollYawOrientation(-30, 30);
  _fov = 60;
  /**
   * @param input The input source.
   */
  constructor(input) {
    super(input);
  }
  /** Camera position, in world space. */
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value;
    this.changed();
  }
  /** Computed rotation quaternion, in world space.
   * @remarks
   * This rotation is derived from {@link pitch} and {@link yaw} angles.
   */
  get rotation() {
    return this._orientation.rotation;
  }
  /** The camera pitch angle, in degrees. */
  get pitch() {
    return this._orientation.pitch;
  }
  set pitch(value) {
    this._orientation.pitch = value;
    this.changed();
  }
  /** The camera yaw angle, in degrees. */
  get yaw() {
    return this._orientation.yaw;
  }
  set yaw(value) {
    this._orientation.yaw = value;
    this.changed();
  }
  /** The camera vertical field of view angle, in degrees. */
  get fov() {
    return this._fov;
  }
  set fov(value) {
    this._fov = value;
    this.changed();
  }
  /** Update controller parameters.
   * @param params Set of parameters to change.
   */
  updateParams(params) {
    this.params = mergeRecursive(this.params, params);
  }
  serialize() {
    const { kind, position, _orientation, _fov } = this;
    const { rotation } = _orientation;
    return { kind, position, rotation, fovDegrees: _fov };
  }
  init(params) {
    const { kind, position, rotation, fovDegrees } = params;
    console.assert(kind == this.kind);
    if (position) {
      this._position = position;
    }
    if (rotation) {
      this._orientation.decomposeRotation(rotation);
      this._orientation.roll = 0;
    }
    if (fovDegrees != void 0) {
      this._fov = fovDegrees;
    }
    this.input.callbacks = this;
    this.input.usePointerLock = true;
    this.attach();
  }
  autoFit(center, radius) {
    const { _orientation } = this;
    const maxDistance = 1e3;
    const distance4 = Math.min(maxDistance, radius / Math.tan(common_exports.toRadian(this._fov) / 2));
    const dir = vec3_exports.fromValues(0, 0, distance4);
    vec3_exports.transformQuat(dir, dir, _orientation.rotation);
    this._position = vec3_exports.add(vec3_exports.create(), center, dir);
  }
  moveTo(targetPosition, flyTime = 1e3, rotation) {
    const { _orientation, _position } = this;
    if (flyTime) {
      let targetPitch = _orientation.pitch;
      let targetYaw = _orientation.yaw;
      if (rotation) {
        const { pitch, yaw } = decomposeRotation(rotation);
        targetPitch = pitch / Math.PI * 180;
        targetYaw = yaw / Math.PI * 180;
      }
      this.setFlyTo({
        totalFlightTime: flyTime,
        end: { pos: vec3_exports.clone(targetPosition), pitch: targetPitch, yaw: targetYaw },
        begin: { pos: vec3_exports.clone(_position), pitch: _orientation.pitch, yaw: _orientation.yaw }
      });
    } else {
      this._position = targetPosition;
      if (rotation) {
        this._orientation.decomposeRotation(rotation);
      }
      this.changed();
    }
  }
  update() {
    const { axes, _orientation, params, height, _fov, currentFlyTo } = this;
    if (currentFlyTo) {
      this._position = vec3_exports.clone(currentFlyTo.pos);
      _orientation.pitch = currentFlyTo.pitch;
      _orientation.yaw = currentFlyTo.yaw;
      this.changed();
      return;
    }
    const tz = axes.keyboard_ws + axes.mouse_wheel + axes.touch_pinch2;
    const rx = -axes.keyboard_arrow_up_down / 5 - axes.mouse_lmb_move_y + axes.touch_1_move_y;
    const ry = -axes.keyboard_arrow_left_right / 5 - axes.mouse_lmb_move_x + axes.touch_1_move_x;
    _orientation.roll = 0;
    if (rx || ry) {
      const rotationalVelocity = this._fov * params.rotationalVelocity / height;
      _orientation.pitch += rx * rotationalVelocity;
      _orientation.yaw += ry * rotationalVelocity;
      this.changed();
    }
    if (tz) {
      const dz = 1 + tz / height;
      this._fov = Math.max(Math.min(60, _fov * dz), 0.1);
      this.changed();
    }
  }
  stateChanges(state) {
    const changes = {};
    const { _position, _orientation, _fov } = this;
    if (!state || state.position !== _position) {
      changes.position = _position;
    }
    if (!state || state.rotation !== _orientation.rotation) {
      changes.rotation = _orientation.rotation;
    }
    if (!state || state.fov !== _fov) {
      changes.fov = _fov;
    }
    if (!state) {
      changes.kind = "pinhole";
    }
    return changes;
  }
  /** PanoramaController type guard function.
   * @param controller The controller to type guard.
   */
  static is(controller) {
    return controller instanceof _PanoramaController;
  }
  /** PanoramaController type assert function.
   * @param controller The controller to type assert.
   */
  static assert(controller) {
    if (!(controller instanceof _PanoramaController))
      throw new Error("Camera controller is not of type PanoramaController!");
  }
};

// /projects/Novorender/ts/dist/web_app/controller/builtin.ts
function builtinControllers(input, pick) {
  return {
    orbit: new OrbitController(input),
    flight: new FlightController(input, pick),
    ortho: new OrthoController(input),
    panorama: new PanoramaController(input),
    cadMiddlePan: new CadMiddlePanController(input, pick),
    cadRightPan: new CadRightPanController(input, pick),
    special: new SpecialFlightController(input, pick),
    null: new NullController(input)
  };
}

// /projects/Novorender/ts/dist/web_app/flip.ts
var transforms = {
  GLToCAD: flipFuncs(flipGLtoCadVec, flipGLtoCadQuat),
  CADToGL: flipFuncs(flipCADToGLVec2, flipCADToGLQuat)
};
function flipState(changes, transform) {
  flipRecursive(changes, transforms[transform]);
}
function flipFuncs(swapVecFunc, swapQuatFunc) {
  const state = {
    camera: {
      position: swapVecFunc,
      rotation: swapQuatFunc,
      pivot: swapVecFunc
    },
    grid: {
      origin: swapVecFunc,
      axisX: swapVecFunc,
      axisY: swapVecFunc
    },
    cube: {
      position: swapVecFunc
    },
    clipping: {
      planes: flipArray(swapVecFunc)
    },
    outlines: {
      plane: swapVecFunc
    },
    scene: {
      config: {
        center: swapVecFunc,
        offset: swapVecFunc,
        boundingSphere: {
          center: swapVecFunc
        },
        aabb: {
          min: swapVecFunc,
          max: swapVecFunc
        }
      }
    },
    dynamic: {
      objects: flipDynamicObjects(swapVecFunc, swapQuatFunc)
    }
  };
  return state;
}
function flipCADToGLVec2(v) {
  const clone7 = [...v];
  const tmp = clone7[1];
  clone7[1] = clone7[2];
  clone7[2] = -tmp;
  return clone7;
}
function flipGLtoCadVec(v) {
  const clone7 = [...v];
  const tmp = clone7[1];
  clone7[1] = -clone7[2];
  clone7[2] = tmp;
  return clone7;
}
function flipCADToGLQuat(b) {
  let ax = -0.7071067811865475, aw = 0.7071067811865475;
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];
  return quat_exports.fromValues(
    ax * bw + aw * bx,
    aw * by + -ax * bz,
    aw * bz + ax * by,
    aw * bw - ax * bx
  );
}
function flipGLtoCadQuat(b) {
  let ax = 0.7071067811865475, aw = 0.7071067811865475;
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];
  return quat_exports.fromValues(
    ax * bw + aw * bx,
    aw * by + -ax * bz,
    aw * bz + ax * by,
    aw * bw - ax * bx
  );
}
function flipDynamicObjects(swapVecFunc, swapQuatFunc) {
  return function(ar) {
    const flippedObjects = [];
    for (const obj of ar) {
      const flippedInstances = [];
      for (const inst of obj.instances) {
        flippedInstances.push({
          position: swapVecFunc(inst.position),
          rotation: inst.rotation ? swapQuatFunc(inst.rotation) : void 0,
          scale: inst.scale
        });
      }
      flippedObjects.push({ mesh: obj.mesh, instances: flippedInstances, baseObjectId: obj.baseObjectId });
    }
    return flippedObjects;
  };
}
function flipArray(swapFunc) {
  return function(ar) {
    const flippedPlanes = [];
    for (const plane of ar) {
      flippedPlanes.push({
        color: plane.color,
        outline: plane.outline,
        normalOffset: swapFunc(plane.normalOffset)
      });
    }
    return flippedPlanes;
  };
}
function flipRecursive(state, funcs) {
  for (const key in state) {
    const func = funcs ? funcs[key] : void 0;
    const value = state[key];
    if (func && value) {
      if (typeof func == "function") {
        state[key] = func(value);
      } else {
        flipRecursive(value, func);
      }
    }
  }
}

// /projects/Novorender/ts/dist/web_app/buffer_inspect.ts
function inspectDeviations(deviations, screenScaling, settings) {
  const sortedDeviations = deviations.sort((a, b) => settings.deviationPrioritization == "minimum" ? Math.abs(a.deviation) - Math.abs(b.deviation) : Math.abs(b.deviation) - Math.abs(a.deviation));
  const labels = [];
  const linePoints = [];
  const minLabelPixelRadius = 60;
  const minPixelRadiusLine = 20;
  const r2Label = minLabelPixelRadius * minLabelPixelRadius;
  const r2Line = minPixelRadiusLine * minPixelRadiusLine;
  const glCenterPos = settings.projection ? vec3_exports.fromValues(settings.projection.centerPoint3d[0], settings.projection.centerPoint3d[2], -settings.projection.centerPoint3d[1]) : void 0;
  const maxDistFromCl2 = 200;
  for (let i = 0; i < sortedDeviations.length; ++i) {
    const currentSample = sortedDeviations[i];
    let addLabel = true;
    const position = vec2_exports.fromValues(Math.round(currentSample.x / screenScaling), Math.round(currentSample.y / screenScaling));
    for (const pixel of labels) {
      const dx = pixel.position[0] - position[0];
      const dy = pixel.position[1] - position[1];
      const sqrDist4 = dx * dx + dy * dy;
      if (sqrDist4 < r2Label) {
        addLabel = false;
        break;
      }
    }
    if (addLabel && glCenterPos) {
      addLabel = vec3_exports.squaredDistance(glCenterPos, currentSample.position) < maxDistFromCl2;
    }
    if (addLabel) {
      labels.push({ position: vec2_exports.clone(position), deviation: currentSample.deviation.toFixed(3) });
    }
    if (settings.generateLine) {
      let addLinePoint = true;
      for (const pixel of linePoints) {
        const dx = pixel.position[0] - position[0];
        const dy = pixel.position[1] - position[1];
        const sqrDist4 = dx * dx + dy * dy;
        if (sqrDist4 < r2Line) {
          addLinePoint = false;
          break;
        }
      }
      if (addLinePoint && glCenterPos) {
        addLinePoint = vec3_exports.squaredDistance(glCenterPos, currentSample.position) < maxDistFromCl2;
      }
      if (addLinePoint) {
        linePoints.push({ position, position3d: currentSample.position });
      }
    }
  }
  if (settings.projection) {
    for (let i = 0; i < labels.length; ++i) {
      const pos = labels[i].position;
      const dir = vec2_exports.sub(vec2_exports.create(), pos, settings.projection.centerPoint2d);
      vec2_exports.normalize(dir, dir);
      vec2_exports.scaleAndAdd(labels[i].position, pos, dir, 50);
    }
    let anglesIdxMap = [];
    for (let i = 0; i < linePoints.length; ++i) {
      const lp = vec2_exports.sub(vec2_exports.create(), settings.projection.centerPoint2d, linePoints[i].position);
      vec2_exports.normalize(lp, lp);
      let angle3 = Math.atan2(lp[1], lp[0]);
      if (angle3 < -Math.PI / 2) {
        angle3 += Math.PI * 2;
      }
      anglesIdxMap.push({ angle: angle3, i });
    }
    anglesIdxMap = anglesIdxMap.sort((a, b) => a.angle - b.angle);
    if (anglesIdxMap.length > 0) {
      const line = [];
      const line3d = [];
      for (const a of anglesIdxMap) {
        if (line.length > 0) {
          if (vec3_exports.squaredDistance(line3d[line3d.length - 1], linePoints[a.i].position3d) > 50) {
            continue;
          }
        }
        line.push(linePoints[a.i].position);
        line3d.push(linePoints[a.i].position3d);
      }
      return { labels, line };
    }
  }
  return { labels };
}

// /projects/Novorender/ts/dist/web_app/view.ts
var View2 = class {
  /**
   * @param canvas The HtmlCanvasElement used for rendering.
   * @param deviceProfile The device profile describing the host device's GPU performance characteristics and limitations.
   * @param imports Imported, non-javascript resources.
   * @remarks
   * Your browser must run in a {@link https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts | secure}
   * and {@link https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts | cross-origin isolated } context.
   */
  constructor(canvas, deviceProfile, imports, controllersFactory = builtinControllers) {
    this.canvas = canvas;
    this.imports = imports;
    if (!isSecureContext)
      throw new Error("Your browser is not running in an secure context!");
    if (!crossOriginIsolated)
      throw new Error("Your browser is not running in an cross-origin isolated context!");
    this._deviceProfile = deviceProfile;
    this._setDeviceProfile = initCore3D(deviceProfile, canvas, imports, this.setRenderContext);
    this.renderStateGL = defaultRenderState();
    this.renderStateCad = this.createRenderState(this.renderStateGL);
    this._drawContext2d = {
      camera: this.renderState.camera,
      width: 0,
      height: 0
    };
    const input = new ControllerInput(canvas);
    this.controllers = controllersFactory(input, this);
    this._activeController = Object.values(this.controllers)[0];
    this._activeController.attach();
    const resizeObserver = this._resizeObserver = new ResizeObserver(() => {
      this.recalcBaseRenderResolution();
    });
    resizeObserver.observe(canvas);
    this._measureViewPromise = createMeasureView(this._drawContext2d, this.imports);
  }
  /** Available camera controller types. */
  controllers;
  _renderContext;
  _run = true;
  _deviceProfile;
  _setDeviceProfile;
  _stateChanges;
  _activeController;
  _statistics = void 0;
  _measureViewPromise;
  _drawContext2d;
  _resizeObserver;
  /** @internal */
  renderStateGL;
  /** @internal */
  renderStateCad;
  /** @internal */
  prevRenderStateCad;
  // dynamic resolution scaling
  resolutionModifier = 1;
  baseRenderResolution = 1;
  drsHighInterval = 50;
  drsLowInterval = 100;
  lastDrsAdjustTime = 0;
  resolutionTier = 2;
  activeOutline = true;
  currentDetailBias = 1;
  /** Dispose of the view's GPU resources. */
  [Symbol.dispose]() {
    this.dispose();
  }
  /** Dispose of the view's GPU resources. */
  dispose() {
    this._resizeObserver.disconnect();
    this._renderContext?.dispose();
    this._renderContext = void 0;
  }
  // Measure view for the currently loaded scene, used for parametric measure
  get measure() {
    return this._measureViewPromise;
  }
  // The active camera controller.
  get activeController() {
    return this._activeController;
  }
  // The current render context.
  get renderContext() {
    return this._renderContext;
  }
  // The current render state.
  get renderState() {
    return this.renderStateCad;
  }
  // The render state from the previous frame, if any.
  get prevRenderState() {
    return this.prevRenderStateCad;
  }
  // The render statistics from the previous frame, if any.
  get statistics() {
    return this._statistics;
  }
  /**
   * The current device profile.
   * @remarks
   * Setting a new device profile will force a recreation of the entire render context and should generally be avoided.
   * Valid cases for doing so might be users manually overriding the GPU profile of their device, or for testing/diagnostics purposes.
   */
  get deviceProfile() {
    return this._deviceProfile;
  }
  set deviceProfile(value) {
    this._deviceProfile = value;
    this._setDeviceProfile?.(value);
  }
  /** Determine if camera is looking straight down. */
  isTopDown() {
    const { _stateChanges, renderState } = this;
    const rot = _stateChanges?.camera?.rotation ?? renderState.camera.rotation;
    const mat = mat3_exports.fromQuat(mat3_exports.create(), rot);
    return Math.abs(mat[8]) > 0.98;
  }
  /**
   * Convert 2D pixel position to 3D position.
   * @param x Pixel x coordinate, in CSS pixels.
   * @param y Pixel y coordinate, in CSS pixels.
   * @returns Corresponding 3D position at the view plane in world space, or undefined if there is no active render context.
   */
  worldPositionFromPixelPosition(x, y) {
    const { _renderContext, canvas } = this;
    const { width, height } = this.renderState.output;
    if (_renderContext) {
      const rect = canvas.getBoundingClientRect();
      const cssWidth = rect.width;
      const cssHeight = rect.height;
      const px = Math.min(Math.max(0, Math.round(x / cssWidth * width)), width);
      const py = Math.min(Math.max(0, Math.round((1 - (y + 0.5) / cssHeight) * height)), height);
      const xCS = (px + 0.5) / width * 2 - 1;
      const yCS = (py + 0.5) / height * 2 - 1;
      const viewClipMatrix = _renderContext["viewClipMatrix"];
      const viewWorldMatrix = _renderContext["viewWorldMatrix"];
      const posVS = vec3_exports.fromValues(xCS / viewClipMatrix[0], yCS / viewClipMatrix[5], 0);
      const pos = vec3_exports.transformMat4(vec3_exports.create(), posVS, viewWorldMatrix);
      return vec3_exports.fromValues(pos[0], -pos[2], pos[1]);
    }
  }
  /**
   * Retrieve list of available background/IBL environments.
   * @public
   * @param indexUrl
   * The absolute url of the index.json file.
   * @returns A promise of a list of environments.
   */
  async availableEnvironments(indexUrl) {
    let environments = [];
    const response = await fetch(indexUrl.toString());
    if (response.ok) {
      const json = await response.json();
      environments = json.map((name) => {
        return { name, url: new URL(name, indexUrl).toString() + "/", thumnbnailURL: new URL(`thumbnails/${name}.png`, indexUrl).toString() };
      });
    }
    return environments;
  }
  /**
   * Load a scene from a url.
  * @public
  * @param url The absolute url to the folder containing the scene.
  * @param abortSignal Optional abort controller.
  * @remarks
  * The url typically contains the scene id as the latter part of the path, i.e. `https://.../<scene_guid>/`.
  */
  async loadSceneFromURL(url, abortSignal) {
    const measureView = await this._measureViewPromise;
    measureView.loadScene(url);
    const webgl2Bin = new URL(url);
    webgl2Bin.pathname += "webgl2_bin/";
    const scene = await downloadScene(webgl2Bin, abortSignal);
    const stateChanges = { scene };
    flipState(stateChanges, "GLToCAD");
    this.modifyRenderState(stateChanges);
    return stateChanges.scene.config;
  }
  /**
   * Inspect the deviations that is on screen
   * @public
   * @param settings Deviation settings, 
   * @returns Spaced out lables prioritizing the smallest or highest deviation values based on settings. 
   * Also returns a line trough the points if it is able to project the points on a line and the option is given.
   */
  async inspectDeviations(settings) {
    const context = this._renderContext;
    if (context) {
      const scale7 = devicePixelRatio * this.resolutionModifier;
      return inspectDeviations(await context.getDeviations(), scale7, settings);
    }
  }
  /**
   * Get all object ids currently on screen
   * @public
   * @returns returns a set of all object ids on the screen 
   */
  async getOutlineObjectsOnScreen() {
    const context = this._renderContext;
    if (context) {
      context.renderPickBuffers();
      const pick = (await context.buffers.pickBuffers()).pick;
      return context.getOutlineObjects(pick);
    }
  }
  /**
   * Query parametric measure entity for the given coordinates
   * @param x Center x coordinate in css pixels.
   * @param y Center y coordinate in css pixels.
   * @param options Extra options.
   * @returns Parametric measure entity, if non exists in the current location, the poisiton will be retuned.
   */
  async pickMeasureEntity(x, y, options) {
    const sample = await this.pick(x, y, options);
    if (sample) {
      const measureView = await this._measureViewPromise;
      return (await measureView.core.pickMeasureEntity(sample.objectId, sample.position)).entity;
    }
  }
  /**
   * Query object and geometry information for given view coordinate.
   * @param x Center x coordinate in css pixels.
   * @param y Center y coordinate in css pixels.
   * @param options Extra options.
   * @returns The sample within the sample disc that is closest to the camera, if any.
   */
  async pick(x, y, options) {
    const context = this._renderContext;
    if (context) {
      const samples = await context.pick(x, y, options);
      if (samples.length) {
        let sampleType = "surface";
        const edgeNormal1 = vec3_exports.create();
        const edgeNormal2 = vec3_exports.create();
        const edgeThreshold = 0.8;
        const centerSample = samples.reduce((a, b) => {
          if (sampleType == "surface" && vec3_exports.dot(a.normal, b.normal) < edgeThreshold) {
            vec3_exports.copy(edgeNormal1, a.normal);
            vec3_exports.copy(edgeNormal2, b.normal);
            sampleType = "edge";
          }
          if (options?.pickOutline === true) {
            if (b.clippingOutline == false) {
              return a;
            }
          }
          return a.depth < b.depth ? a : b;
        });
        if (sampleType == "edge") {
          samples.forEach((v) => {
            if (vec3_exports.dot(v.normal, edgeNormal1) < edgeThreshold && vec3_exports.dot(v.normal, edgeNormal2) < edgeThreshold) {
              sampleType = "corner";
            }
          });
        }
        if (options?.pickOutline === true && centerSample.clippingOutline == false) {
          return void 0;
        }
        const worldViewMatrixNormal = context.prevState?.matrices.getMatrixNormal(0 /* World */, 1 /* View */) ?? mat3_exports.create();
        const flippedSample = {
          ...centerSample,
          position: vec3_exports.fromValues(centerSample.position[0], -centerSample.position[2], centerSample.position[1]),
          normal: vec3_exports.fromValues(centerSample.normal[0], -centerSample.normal[2], centerSample.normal[1]),
          sampleType,
          normalVS: vec3_exports.transformMat3(vec3_exports.create(), centerSample.normal, worldViewMatrixNormal),
          deviation: this.deviceProfile.quirks.adreno600 ? void 0 : centerSample.deviation
        };
        return flippedSample;
      }
    }
  }
  /**
   * Switch to a new kind of camera controller.
   * @param kind The type of camera controller to switch to.
   * @param initialState Optional initial state for the new camera controller. Undefined properties will be copied/adapted from the current render state.
   * @param options Switch options.
   * @template T Kind of camera controller.
   * @returns The new camera controller.
   * @remarks
   * The function will also set the {@link RenderStateCamera.kind | camera projection model}.
   */
  async switchCameraController(kind, initialState, options) {
    const autoInit = options?.autoInit ?? false;
    function isControllerKind(kind2, controllers2) {
      return kind2 in controllers2;
    }
    if (!isControllerKind(kind, this.controllers))
      throw new Error(`Unknown controller kind: ${kind}!`);
    const { controllers, _renderContext } = this;
    let { _activeController } = this;
    let distance4;
    if (autoInit && _renderContext && _renderContext.prevState) {
      _renderContext.renderPickBuffers();
      const pick = (await _renderContext.buffers.pickBuffers()).pick;
      const depths = _renderContext.getLinearDepths(pick);
      distance4 = Number.MAX_VALUE;
      for (const depth of depths) {
        distance4 = Math.min(distance4, depth);
      }
    }
    const prevState = _activeController.serialize(
      true
      /* include derived properties as well */
    );
    const controller = controllers[kind];
    _activeController = this._activeController = controller;
    const { position, rotation, pivot, fovMeters } = prevState;
    _activeController.init({ kind, position: initialState?.position ?? position, rotation: initialState?.rotation ?? rotation, pivot, distance: distance4, fovMeters: initialState?.fov ?? (kind != "panorama" ? fovMeters : void 0) });
    const changes = _activeController.stateChanges();
    this.modifyRenderState({ camera: changes });
    return controller;
  }
  /**
   * Start the main render loop for the view.
   * @param abortSignal Signal to abort any pending downloads and exit render loop.
   * @remarks
   * This method will not exit until you call {@link exit}.
   */
  async run(abortSignal) {
    let prevState;
    let prevRenderTime = performance.now();
    let wasCameraMoving = false;
    let idleFrameTime = 0;
    let wasIdle = false;
    const frameIntervals = [];
    let possibleChanges = false;
    while (this._run && !(abortSignal?.aborted ?? false)) {
      const { _renderContext, _activeController, deviceProfile } = this;
      const renderTime = await RenderContext2.nextFrame(_renderContext);
      const frameTime = renderTime - prevRenderTime;
      const cameraChanges = _activeController.renderStateChanges(this.renderStateCad.camera, renderTime - prevRenderTime);
      if (cameraChanges) {
        this.modifyRenderState(cameraChanges);
      }
      const isIdleFrame = idleFrameTime > 500;
      if (_renderContext && !_renderContext.isContextLost()) {
        _renderContext.poll();
        if (isIdleFrame) {
          if (deviceProfile.tier > 0 && this.renderState.toonOutline.on == false) {
            this.modifyRenderState({ toonOutline: { on: true }, outlines: { on: true } });
          }
          if (!wasIdle) {
            this.resolutionModifier = Math.min(1, this.baseRenderResolution * 2);
            this.resize();
            this.modifyRenderState({ quality: { detail: 1 } });
            this.currentDetailBias = 1;
            wasIdle = true;
          }
        } else {
          if (wasIdle) {
            this.resolutionModifier = this.baseRenderResolution;
            this.resolutionTier = 2;
            this.modifyRenderState({ toonOutline: { on: false } });
            this.activeOutline = true;
            wasIdle = false;
          } else {
            frameIntervals.push(frameTime);
            this.dynamicQualityAdjustment(frameIntervals);
          }
          const activeDetailModifier = 0.5;
          if (this.renderStateGL.quality.detail != activeDetailModifier) {
            this.currentDetailBias = activeDetailModifier;
            this.modifyRenderState({ quality: { detail: activeDetailModifier } });
          }
        }
        this.animate?.(renderTime);
        if (this._stateChanges) {
          this.applyChanges(this._stateChanges);
          this._stateChanges = void 0;
        }
        const { renderStateGL } = this;
        if (prevState !== renderStateGL || _renderContext.changed) {
          prevState = renderStateGL;
          const statsPromise = _renderContext.render(renderStateGL);
          statsPromise.then((stats) => {
            this._statistics = { render: stats, view: { resolution: this.resolutionModifier, detailBias: deviceProfile.detailBias * this.currentDetailBias, fps: stats.frameInterval ? 1e3 / stats.frameInterval : void 0 } };
            this.render?.(isIdleFrame);
            possibleChanges = true;
          });
        } else if (possibleChanges) {
          this.render?.(isIdleFrame);
          if (isIdleFrame) {
            _renderContext.renderPickBuffers();
          }
        }
      }
      if (this._activeController.moving) {
        wasCameraMoving = true;
        idleFrameTime = 0;
      } else if (!wasCameraMoving) {
        idleFrameTime += frameTime;
      }
      wasCameraMoving = this._activeController.moving;
      prevRenderTime = renderTime;
    }
  }
  /** Signal the render loop to exit.
   * @see {@link run}.
   * @deprecated Use {@link run} `abortSignal` instead.
   */
  exit() {
    this._run = false;
  }
  /** Accumulate render state changes.
   * @param changes The changes to apply to the current view render state.
   * @remarks
   * These changes will be applied and a single call to the {@link modifyRenderState} function just prior to rendering each frame.
   */
  modifyRenderState(changes) {
    this._stateChanges = mergeRecursive(this._stateChanges, changes);
  }
  /**
   * Validate render state changes made since last rendered frame.
   * @param changes The render state changes to validate, or undefined to validate changes applied via {@link View.modifyRenderState} since last rendered frame.
   * @returns An array of validation errors, if any.
   * @see {@link View.modifyRenderState}
   * @remarks
   * Validation is useful for catching potential bugs and problems early.
   * It should not be performed in production code, however, since it is non-trivial in terms of performance, particularly on large sets of dynamic objects.
   */
  validateRenderState(changes) {
    changes ??= this._stateChanges;
    const changesCopy = { ...changes };
    flipState(changesCopy, "CADToGL");
    const newState = mergeRecursive(this.renderStateGL, changesCopy);
    return validateRenderState(newState, changesCopy);
  }
  /** 
   * Callback function to update render context.
   * @param context A new render context.
   * @remarks
   * A new render context may be set each time the underlying webgl context is lost and restored,
   * or when certain state changes are made that forces a recreation of the context, such as setting a new {@link deviceProfile}.
   * @virtual
   */
  setRenderContext = (context) => {
    this._renderContext = context;
    this.useDeviceProfile(this._deviceProfile);
  };
  useDeviceProfile(deviceProfile) {
    this.resolutionModifier = deviceProfile.renderResolution;
    this.baseRenderResolution = deviceProfile.renderResolution;
    this.recalcBaseRenderResolution();
    this.drsHighInterval = 1e3 / deviceProfile.framerateTarget * 1.2;
    this.drsLowInterval = 1e3 / deviceProfile.framerateTarget * 0.9;
  }
  resize() {
    const scale7 = devicePixelRatio * this.resolutionModifier;
    let { width, height } = this.canvas.getBoundingClientRect();
    this._drawContext2d.width = width;
    this._drawContext2d.height = height;
    width = Math.round(width * scale7);
    height = Math.round(height * scale7);
    const { output } = this.renderStateGL;
    if (width != output.width || height != output.height) {
      this.applyChanges({ output: { width, height } });
    }
  }
  recalcBaseRenderResolution() {
    const { deviceProfile } = this;
    if (deviceProfile.tier < 2) {
      const maxRes = deviceProfile.tier == 0 ? 720 * 1280 : 1440 * 2560;
      let baseRenderResolution = deviceProfile.renderResolution / devicePixelRatio;
      const { width, height } = this.canvas.getBoundingClientRect();
      let idleRes = baseRenderResolution * 2 * width * height;
      if (idleRes > maxRes) {
        baseRenderResolution *= maxRes / idleRes;
      }
      this.baseRenderResolution = baseRenderResolution;
      this.resolutionModifier = baseRenderResolution;
    }
    this.resize();
  }
  applyChanges(changes) {
    this.prevRenderStateCad = this.renderStateCad;
    this.renderStateCad = mergeRecursive(this.renderStateCad, changes);
    this._drawContext2d.camera = this.renderStateCad.camera;
    flipState(changes, "CADToGL");
    this.renderStateGL = modifyRenderState(this.renderStateGL, changes);
    this.validate?.(this.renderStateGL, changes);
  }
  createRenderState(state) {
    const clone7 = structuredClone(state);
    flipState(clone7, "GLToCAD");
    return clone7;
  }
  //Dynamically change the quality of rendering based on the last 9 frames 
  dynamicQualityAdjustment(frameIntervals) {
    const samples = 9;
    if (frameIntervals.length == samples) {
      const sortedIntervals = [...frameIntervals];
      sortedIntervals.sort();
      const medianInterval = sortedIntervals[Math.floor(samples / 2)];
      frameIntervals.splice(0, 1);
      const cooldown = 3e3;
      const now = performance.now();
      if (this.activeOutline) {
        const activeOutline = medianInterval < this.drsLowInterval && this.resolutionTier == 2;
        if (this.activeOutline != activeOutline) {
          this.activeOutline = activeOutline;
          this.modifyRenderState({ outlines: { on: this.activeOutline } });
        }
      }
      if (now > this.lastDrsAdjustTime + cooldown) {
        this.dynamicResolutionScaling(medianInterval, now);
      }
    }
  }
  dynamicResolutionScaling(medianInterval, now) {
    const highFrameInterval = this.drsHighInterval;
    const lowFrameInterval = this.drsLowInterval;
    const resolutionTiers = [0.4, 0.6, 1];
    if (medianInterval > highFrameInterval) {
      if (this.resolutionTier != 0) {
        this.resolutionModifier = this.baseRenderResolution * resolutionTiers[--this.resolutionTier];
        this.resize();
      }
      this.lastDrsAdjustTime = now;
      return;
    } else if (medianInterval < lowFrameInterval) {
      if (this.resolutionTier != 2) {
        this.resolutionModifier = this.baseRenderResolution * resolutionTiers[++this.resolutionTier];
        this.lastDrsAdjustTime = now;
        this.resize();
      }
      return;
    }
  }
  static async downloadImports(map) {
    const core3dPromise = downloadCore3dImports(map);
    const measurePromise = downloadMeasureImports(map);
    const [core3d, measure3] = await Promise.all([core3dPromise, measurePromise]);
    return {
      ...core3d,
      ...measure3
    };
  }
};

// /projects/Novorender/ts/dist/web_app/highlight.ts
function createNeutralHighlight() {
  return [
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0
  ];
}
function createTransparentHighlight(opacity) {
  return [
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    opacity,
    0
  ];
}
function createColorSetHighlight(color) {
  const [r, g, b, a] = color;
  return [
    0,
    0,
    0,
    0,
    r,
    0,
    0,
    0,
    0,
    g,
    0,
    0,
    0,
    0,
    b,
    0,
    0,
    0,
    0,
    a ?? 1
  ];
}
function createRGBATransformHighlight(options) {
  const r = normalizeLinearTransform(options.red);
  const g = normalizeLinearTransform(options.green);
  const b = normalizeLinearTransform(options.blue);
  const a = normalizeLinearTransform(options.opacity);
  return [
    r[0],
    0,
    0,
    0,
    r[1],
    0,
    g[0],
    0,
    0,
    g[1],
    0,
    0,
    b[0],
    0,
    b[1],
    0,
    0,
    0,
    a[0],
    a[1]
  ];
}
function createHSLATransformHighlight(options) {
  const [ls, lo] = normalizeLinearTransform(options.lightness);
  const [as, ao] = normalizeLinearTransform(options.opacity);
  function mix(a, b, t) {
    return a + (b - a) * t;
  }
  const ss = options.saturation ?? 1;
  const s0 = mix(1 / 3, 1, ss) * ls;
  const s1 = mix(1 / 3, 0, ss) * ls;
  return [
    s0,
    s1,
    s1,
    0,
    lo,
    s1,
    s0,
    s1,
    0,
    lo,
    s1,
    s1,
    s0,
    0,
    lo,
    0,
    0,
    0,
    as,
    ao
  ];
}
function isLinearTransform(transform) {
  return typeof transform == "object";
}
function normalizeLinearTransform(transform) {
  let scale7 = 1;
  let offset = 0;
  if (isLinearTransform(transform)) {
    if (transform.scale != void 0) {
      scale7 = transform.scale;
    }
    if (transform.offset != void 0) {
      offset = transform.offset;
    }
  } else if (typeof transform == "number") {
    scale7 = 0;
    offset = transform;
  }
  return [scale7, offset];
}

// /projects/Novorender/ts/dist/web_app/geometry.ts
var defaultMaterial = {
  kind: "ggx",
  metallicFactor: 1,
  roughnessFactor: 0.1
};
var defaultInstance = {
  position: vec3_exports.create()
};
function createRandomInstances(count = 1, radius) {
  const instances = [];
  const r = radius ?? count <= 1 ? 0 : Math.pow(count, 1 / 3) * 2;
  const rndCoord = () => (Math.random() * 2 - 1) * r;
  const rndAngle = () => Math.random() * 360;
  for (var i = 0; i < count; i++) {
    const position = vec3_exports.fromValues(rndCoord(), rndCoord(), rndCoord());
    if (vec3_exports.sqrLen(position) > r * r) {
      i--;
      continue;
    }
    const rotation = quat_exports.fromEuler(quat_exports.create(), rndAngle(), rndAngle(), rndAngle());
    instances.push({ position, rotation });
  }
  return instances;
}
function createCubeObject(material) {
  const vertices = createCubeVertices((pos, norm, col) => [...pos, ...norm, ...col]);
  const indices = createCubeIndices();
  material ??= defaultMaterial;
  const attributes = {
    position: { kind: "FLOAT_VEC3", buffer: vertices, byteStride: 36, byteOffset: 0 },
    normal: { kind: "FLOAT_VEC3", buffer: vertices, byteStride: 36, byteOffset: 12 },
    color0: { kind: "FLOAT_VEC3", buffer: vertices, byteStride: 36, byteOffset: 24 }
  };
  const geometry = {
    primitiveType: "TRIANGLES",
    attributes,
    indices
  };
  const primitive = { geometry, material };
  const mesh = { primitives: [primitive] };
  const instances = [defaultInstance];
  return { mesh, instances };
}
function createCubeVertices(pack) {
  function face(x, y, color) {
    const normal = vec3_exports.cross(vec3_exports.create(), y, x);
    function vert(fx, fy) {
      const pos = vec3_exports.clone(normal);
      vec3_exports[fx](pos, pos, x);
      vec3_exports[fy](pos, pos, y);
      return pack(pos, normal, color);
    }
    return [
      ...vert("sub", "sub"),
      ...vert("add", "sub"),
      ...vert("sub", "add"),
      ...vert("add", "add")
    ];
  }
  return new Float32Array([
    ...face([0, 0, -1], [0, 1, 0], [1, 0, 0]),
    // right (1, 0, 0)
    ...face([0, 0, 1], [0, 1, 0], [0, 1, 1]),
    // left (-1, 0, 0)
    ...face([1, 0, 0], [0, 0, 1], [0, 1, 0]),
    // top (0, 1, 0)
    ...face([1, 0, 0], [0, 0, -1], [1, 0, 1]),
    // bottom (0, -1, 0)
    ...face([1, 0, 0], [0, 1, 0], [0, 0, 1]),
    // front (0, 0, 1)
    ...face([-1, 0, 0], [0, 1, 0], [1, 1, 0])
    // back (0, 0, -1)
  ]);
}
function createCubeIndices() {
  let idxOffset = 0;
  function face() {
    const idx = [0, 2, 1, 1, 2, 3].map((i) => i + idxOffset);
    idxOffset += 4;
    return idx;
  }
  return new Uint16Array([
    ...face(),
    ...face(),
    ...face(),
    ...face(),
    ...face(),
    ...face()
  ]);
}
function createSphereObject(detail = 5, material) {
  const radius = 1;
  const { positionBuffer, normalBuffer, texCoordBuffer } = icosahedron(radius, detail);
  material ??= defaultMaterial;
  const attributes = {
    position: { kind: "FLOAT_VEC3", buffer: positionBuffer },
    normal: { kind: "FLOAT_VEC3", buffer: normalBuffer },
    texCoord0: { kind: "FLOAT_VEC2", buffer: texCoordBuffer }
  };
  const geometry = {
    primitiveType: "TRIANGLES",
    attributes,
    indices: positionBuffer.length / 3
  };
  const primitive = { geometry, material };
  const mesh = { primitives: [primitive] };
  return { mesh, instances: [defaultInstance] };
}
function icosahedron(radius, detail) {
  const t = (1 + Math.sqrt(5)) / 2;
  const vertices = [
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    0,
    0,
    -1,
    t,
    0,
    1,
    t,
    0,
    -1,
    -t,
    0,
    1,
    -t,
    t,
    0,
    -1,
    t,
    0,
    1,
    -t,
    0,
    -1,
    -t,
    0,
    1
  ];
  const indices = [
    0,
    11,
    5,
    0,
    5,
    1,
    0,
    1,
    7,
    0,
    7,
    10,
    0,
    10,
    11,
    1,
    5,
    9,
    5,
    11,
    4,
    11,
    10,
    2,
    10,
    7,
    6,
    7,
    1,
    8,
    3,
    9,
    4,
    3,
    4,
    2,
    3,
    2,
    6,
    3,
    6,
    8,
    3,
    8,
    9,
    4,
    9,
    5,
    2,
    4,
    11,
    6,
    2,
    10,
    8,
    6,
    7,
    9,
    8,
    1
  ];
  return polyhedron(vertices, indices, radius, detail);
}
function polyhedron(vertices, indices, radius, detail) {
  const vertexBuffer = [];
  const uvBuffer = [];
  subdivide(detail);
  applyRadius(radius);
  generateUVs();
  const positionBuffer = new Float32Array(vertexBuffer);
  const normalBuffer = new Float32Array(vertexBuffer);
  const texCoordBuffer = new Float32Array(uvBuffer);
  if (detail == 0) {
    computeVertexNormals();
  } else {
    normalizeNormals();
  }
  return { positionBuffer, normalBuffer, texCoordBuffer };
  function subdivide(detail2) {
    const a = vec3_exports.create();
    const b = vec3_exports.create();
    const c = vec3_exports.create();
    for (let i = 0; i < indices.length; i += 3) {
      getVertexByIndex(indices[i + 0], a);
      getVertexByIndex(indices[i + 1], b);
      getVertexByIndex(indices[i + 2], c);
      subdivideFace(a, b, c, detail2);
    }
  }
  function subdivideFace(a, b, c, detail2) {
    const cols = detail2 + 1;
    const v = [];
    for (let i = 0; i <= cols; i++) {
      v[i] = [];
      const aj = vec3_exports.lerp(vec3_exports.create(), a, c, i / cols);
      const bj = vec3_exports.lerp(vec3_exports.create(), b, c, i / cols);
      const rows = cols - i;
      for (let j = 0; j <= rows; j++) {
        if (j === 0 && i === cols) {
          v[i][j] = aj;
        } else {
          v[i][j] = vec3_exports.lerp(vec3_exports.create(), aj, bj, j / rows);
        }
      }
    }
    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < 2 * (cols - i) - 1; j++) {
        const k = Math.floor(j / 2);
        if (j % 2 === 0) {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k]);
          pushVertex(v[i][k]);
        } else {
          pushVertex(v[i][k + 1]);
          pushVertex(v[i + 1][k + 1]);
          pushVertex(v[i + 1][k]);
        }
      }
    }
  }
  function applyRadius(radius2) {
    const vertex = vec3_exports.create();
    for (let i = 0; i < vertexBuffer.length; i += 3) {
      vertex[0] = vertexBuffer[i + 0];
      vertex[1] = vertexBuffer[i + 1];
      vertex[2] = vertexBuffer[i + 2];
      vec3_exports.scale(vertex, vec3_exports.normalize(vertex, vertex), radius2);
      vertexBuffer[i + 0] = vertex[0];
      vertexBuffer[i + 1] = vertex[1];
      vertexBuffer[i + 2] = vertex[2];
    }
  }
  function generateUVs() {
    const vertex = vec3_exports.create();
    for (let i = 0; i < vertexBuffer.length; i += 3) {
      vertex[0] = vertexBuffer[i + 0];
      vertex[1] = vertexBuffer[i + 1];
      vertex[2] = vertexBuffer[i + 2];
      const u = azimuth(vertex) / 2 / Math.PI + 0.5;
      const v = inclination(vertex) / Math.PI + 0.5;
      uvBuffer.push(u, 1 - v);
    }
    correctUVs();
    correctSeam();
  }
  function correctSeam() {
    for (let i = 0; i < uvBuffer.length; i += 6) {
      const x0 = uvBuffer[i + 0];
      const x1 = uvBuffer[i + 2];
      const x2 = uvBuffer[i + 4];
      const max4 = Math.max(x0, x1, x2);
      const min4 = Math.min(x0, x1, x2);
      if (max4 > 0.9 && min4 < 0.1) {
        if (x0 < 0.2)
          uvBuffer[i + 0] += 1;
        if (x1 < 0.2)
          uvBuffer[i + 2] += 1;
        if (x2 < 0.2)
          uvBuffer[i + 4] += 1;
      }
    }
  }
  function pushVertex(vertex) {
    vertexBuffer.push(...vertex);
  }
  function getVertexByIndex(index2, vertex) {
    const stride = index2 * 3;
    vertex[0] = vertices[stride + 0];
    vertex[1] = vertices[stride + 1];
    vertex[2] = vertices[stride + 2];
  }
  function correctUVs() {
    const a = vec3_exports.create();
    const b = vec3_exports.create();
    const c = vec3_exports.create();
    const centroid = vec3_exports.create();
    const uvA = vec2_exports.create();
    const uvB = vec2_exports.create();
    const uvC = vec2_exports.create();
    for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
      vec3_exports.set(a, vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
      vec3_exports.set(b, vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
      vec3_exports.set(c, vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
      vec2_exports.set(uvA, uvBuffer[j + 0], uvBuffer[j + 1]);
      vec2_exports.set(uvB, uvBuffer[j + 2], uvBuffer[j + 3]);
      vec2_exports.set(uvC, uvBuffer[j + 4], uvBuffer[j + 5]);
      vec3_exports.add(centroid, a, b);
      vec3_exports.add(centroid, centroid, c);
      vec3_exports.scale(centroid, centroid, 1 / 3);
      const azi = azimuth(centroid);
      correctUV(uvA, j + 0, a, azi);
      correctUV(uvB, j + 2, b, azi);
      correctUV(uvC, j + 4, c, azi);
    }
  }
  function correctUV(uv, stride, vector, azimuth2) {
    if (azimuth2 < 0 && uv[0] === 1) {
      uvBuffer[stride] = uv[0] - 1;
    }
    if (vector[0] === 0 && vector[2] === 0) {
      uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
    }
  }
  function azimuth(vector) {
    return Math.atan2(vector[2], -vector[0]);
  }
  function inclination(vector) {
    return Math.atan2(-vector[1], Math.sqrt(vector[0] * vector[0] + vector[2] * vector[2]));
  }
  function computeVertexNormals() {
    if (positionBuffer !== void 0) {
      const cb = vec3_exports.create(), ab = vec3_exports.create();
      for (let i = 0, il = positionBuffer.length; i < il; i += 9) {
        const pA = positionBuffer.subarray(i + 0, i + 3);
        const pB = positionBuffer.subarray(i + 3, i + 6);
        const pC = positionBuffer.subarray(i + 6, i + 9);
        vec3_exports.sub(cb, pC, pB);
        vec3_exports.sub(ab, pA, pB);
        vec3_exports.cross(cb, cb, ab);
        vec3_exports.normalize(cb, cb);
        vec3_exports.copy(normalBuffer.subarray(i + 0, i + 3), cb);
        vec3_exports.copy(normalBuffer.subarray(i + 3, i + 6), cb);
        vec3_exports.copy(normalBuffer.subarray(i + 6, i + 9), cb);
      }
    }
  }
  function normalizeNormals() {
    for (let i = 0, il = normalBuffer.length; i < il; i += 3) {
      const normal = normalBuffer.subarray(i, i + 3);
      vec3_exports.normalize(normal, normal);
    }
  }
}

// /projects/Novorender/ts/dist/web_app/index.ts
var packageVersion = "0.0.29";
common_exports.setMatrixArrayType(Array);
export {
  BaseController,
  Benchmark,
  CadMiddlePanController,
  CadRightPanController,
  ClippingId,
  ClippingMode,
  CollisionModule,
  ControllerInput,
  CoordSpace,
  CoreModule,
  CubeId,
  DrawModule,
  FillrateProfiler,
  FlightController,
  FollowModule,
  ManholeModule,
  MeasureError,
  MeasureView3 as MeasureView,
  MouseButtons,
  NullController,
  OrbitController,
  OrthoController,
  PanoramaController,
  PointrateProfiler,
  ProfileModule,
  RenderContext2 as RenderContext,
  RoadModule,
  SpecialFlightController,
  TonemappingMode,
  View2 as View,
  builtinControllers,
  computeRotation,
  createCacheOfflineStorage,
  createCacheStorage,
  createColorSetHighlight,
  createCubeObject,
  createHSLATransformHighlight,
  createMeasureView,
  createNeutralHighlight,
  createOPFSOfflineStorage,
  createOfflineViewState,
  createRGBATransformHighlight,
  createRandomInstances,
  createSphereObject,
  createTransparentHighlight,
  defaultRenderState,
  defaultRequestFormatter,
  downloadCore3dImports,
  downloadGLTF,
  downloadMeasureImports,
  downloadScene,
  enableOffline,
  getDeviceProfile,
  initCore3D,
  inspectDeviations,
  manageOfflineStorage,
  mergeRecursive,
  modifyRenderState,
  packageVersion,
  rotationFromDirection,
  schemaVersion,
  serviceWorkerFetch,
  serviceWorkerHandleMessage,
  validateRenderState
};
/*! Bundled license information:

comlink/dist/esm/comlink.mjs:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=index.js.map
