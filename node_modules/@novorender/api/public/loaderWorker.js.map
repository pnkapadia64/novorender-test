{
  "version": 3,
  "sources": ["/projects/Novorender/ts/dist/core3d/offline.ts", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/download.ts", "/projects/Novorender/ts/dist/core3d/modules/octree/mutex.ts", "/projects/Novorender/ts/node_modules/gl-matrix/esm/common.js", "/projects/Novorender/ts/node_modules/gl-matrix/esm/vec3.js", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/util.ts", "/projects/Novorender/ts/dist/core3d/ktx.ts", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/2_1.ts", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/2_0.ts", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/parser.ts", "/projects/Novorender/ts/node_modules/@novorender/wasm-parser/wasm_parser_bg.js", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/wasm_loader.ts", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/handler.ts", "/projects/Novorender/ts/dist/core3d/modules/octree/worker/index.ts"],
  "sourcesContent": ["const offlineDirs = new Map<string, WeakRef<FileSystemDirectoryHandle> | null>();\r\nconst rootPromise = navigator.storage.getDirectory();\r\n\r\n\r\nasync function getDirHandle(dirname: string) {\r\n    try {\r\n        const root = await rootPromise;\r\n        return await root.getDirectoryHandle(dirname);\r\n    } catch {\r\n    }\r\n}\r\n\r\n/** @internal attempt to read file from OPFS offline storage */\r\nexport async function requestOfflineFile(pathname: string): Promise<Response | undefined> {\r\n    const m = /\\/([\\da-f]{32})(?=\\/).*\\/(.+)$/.exec(pathname);\r\n    if (m && m.length == 3) {\r\n        const [_, dirname, filename] = m;\r\n        let dirHandleRef = await offlineDirs.get(dirname);\r\n        if (dirHandleRef !== null) {\r\n            let dirHandle = dirHandleRef?.deref();\r\n            if (!dirHandle) {\r\n                dirHandle = await getDirHandle(dirname);\r\n                if (dirHandle) {\r\n                    dirHandleRef = new WeakRef(dirHandle);\r\n                    offlineDirs.set(dirname, dirHandleRef);\r\n                } else {\r\n                    offlineDirs.set(dirname, null);\r\n                }\r\n            }\r\n            if (dirHandle) {\r\n                try {\r\n                    const fileHandle = await dirHandle.getFileHandle(filename);\r\n                    const file = await fileHandle.getFile();\r\n                    // console.log(`loading ${filename}`);\r\n                    return new Response(file, { status: 200, headers: { \"Content-Type\": \"application/octet-stream\" } });\r\n                } catch {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // console.log(`skipping ${pathname}`);\r\n}\r\n", "import { requestOfflineFile } from \"core3d/offline\";\r\n\r\n/** @internal */\r\nexport class AbortableDownload {\r\n    result: Promise<ArrayBuffer | undefined> = Promise.resolve(undefined);\r\n    aborted = false;\r\n\r\n    constructor(private readonly download: () => Promise<ArrayBuffer | undefined>) {\r\n    }\r\n\r\n    start() {\r\n        this.result = this.download();\r\n    }\r\n\r\n    abort() {\r\n        this.aborted = true;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class Downloader {\r\n    activeDownloads = 0;\r\n    completeResolve: (() => void) | undefined;\r\n\r\n    constructor(public baseUrl?: URL) {\r\n    }\r\n\r\n    async complete() {\r\n        if (this.activeDownloads > 0) {\r\n            const completePromise = new Promise<void>((resolve, reject) => {\r\n                this.completeResolve = resolve;\r\n            });\r\n            await completePromise;\r\n            this.completeResolve = undefined;\r\n        }\r\n    }\r\n\r\n    private async request(filename: string) {\r\n        const url = new URL(filename, this.baseUrl);\r\n        if (!url.search)\r\n            url.search = this.baseUrl?.search ?? \"\";\r\n        const response = await requestOfflineFile(url.pathname) ?? await fetch(url, { mode: \"cors\" });\r\n        if (!response.ok) {\r\n            throw new Error(`HTTP Error: ${response.status}: ${response.statusText} (${url})`);\r\n        }\r\n        return response;\r\n    }\r\n\r\n    downloadArrayBufferAbortable(filename: string, buffer?: ArrayBuffer): AbortableDownload {\r\n        const self = this;\r\n        const download = new AbortableDownload(buffer != undefined ? downloadAsyncSize : downloadAsync);\r\n        download.start();\r\n        return download;\r\n\r\n        async function downloadAsyncSize() {\r\n            try {\r\n                self.activeDownloads++;\r\n                const response = await self.request(filename);\r\n                if (!response.ok)\r\n                    throw new Error(`HTTP error: ${response.status} ${response.statusText}!`);\r\n                const reader = response.body!.getReader(); // waiting for safari and typescript to include the byob mode here.\r\n                const content = new Uint8Array(buffer!);\r\n                let offset = 0;\r\n                while (!download.aborted) {\r\n                    const { done, value } = await reader.read();\r\n                    if (done)\r\n                        break;\r\n                    content.set(value, offset);\r\n                    offset += value.length;\r\n                }\r\n                if (!download.aborted) {\r\n                    console.assert(offset == content.length);\r\n                    return content.buffer;\r\n                } else {\r\n                    reader.cancel();\r\n                }\r\n            } finally {\r\n                self.activeDownloads--;\r\n                if (self.activeDownloads == 0 && self.completeResolve) {\r\n                    self.completeResolve();\r\n                }\r\n            }\r\n        }\r\n\r\n        async function downloadAsync() {\r\n            try {\r\n                self.activeDownloads++;\r\n                const response = await self.request(filename);\r\n                if (!response.ok)\r\n                    throw new Error(`HTTP error: ${response.status} ${response.statusText}!`);\r\n                // return await response.arrayBuffer(); // sometimes skips/gives up on downloads when previously cancelled, so we use streaming instead.\r\n                const reader = response.body!.getReader();\r\n                const chunks: Uint8Array[] = [];\r\n                let size = 0; // If compressed, we can't use content-length to determine uncompressed length up front, so we must store chunks and then assemble into final buffer.\r\n                while (!download.aborted) {\r\n                    const { done, value } = await reader.read();\r\n                    if (done)\r\n                        break;\r\n                    chunks.push(value);\r\n                    size += value.length;\r\n                }\r\n                if (!download.aborted) {\r\n                    const content = new Uint8Array(size);\r\n                    let offset = 0;\r\n                    for (const chunk of chunks) {\r\n                        content.set(chunk, offset);\r\n                        offset += chunk.length;\r\n                    }\r\n                    return content.buffer;\r\n                } else {\r\n                    reader.cancel();\r\n                }\r\n            } finally {\r\n                self.activeDownloads--;\r\n                if (self.activeDownloads == 0 && self.completeResolve) {\r\n                    self.completeResolve();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "const enum State { unlocked, locked };\r\n\r\n/** @internal */\r\nexport class Mutex {\r\n    readonly _view: Int32Array;\r\n\r\n    constructor(buffer: SharedArrayBuffer) {\r\n        this._view = new Int32Array(buffer, 0, 1);\r\n    }\r\n\r\n    // will loop until lock is available, so be careful using this in main thread\r\n    lockSpin() {\r\n        const { _view } = this;\r\n        for (; ;) {\r\n            if (Atomics.compareExchange(_view, 0, State.unlocked, State.locked) == State.unlocked) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    // blocking call, use in workers only!\r\n    lockSync() {\r\n        console.assert(self.Worker != undefined);\r\n        const { _view } = this;\r\n        for (; ;) {\r\n            if (Atomics.compareExchange(_view, 0, State.unlocked, State.locked) == State.unlocked) {\r\n                return;\r\n            }\r\n            Atomics.wait(_view, 0, State.locked);\r\n        }\r\n    }\r\n\r\n    // safe to use from main thread\r\n    async lockAsync() {\r\n        const { _view } = this;\r\n        for (; ;) {\r\n            if (Atomics.compareExchange(_view, 0, State.unlocked, State.locked) == State.unlocked) {\r\n                return;\r\n            }\r\n            const { async, value } = Atomics.waitAsync(_view, 0, State.locked);\r\n            if (async) {\r\n                await value;\r\n            }\r\n        }\r\n    }\r\n\r\n    unlock() {\r\n        const { _view } = this;\r\n        if (Atomics.compareExchange(_view, 0, State.locked, State.unlocked) != State.locked) {\r\n            throw new Error(\"Mutex is in inconsistent state: unlock on unlocked Mutex.\");\r\n        }\r\n        Atomics.notify(_view, 0);\r\n    }\r\n}", "/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};", "import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();", "export type U8 = Uint8Array;\r\nexport type U16 = Uint16Array;\r\nexport type U32 = Uint32Array;\r\nexport type I8 = Int8Array;\r\nexport type I16 = Int16Array;\r\nexport type I32 = Int32Array;\r\nexport type F16 = Uint16Array;\r\nexport type F32 = Float32Array;\r\nexport type F64 = Float64Array;\r\n\r\nexport type EnumArray<T> = { readonly [index: number]: T; };\r\n\r\ntype TypedArray = Uint8Array | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\r\nexport type Float16Array = Uint16Array;\r\nexport const Float16Array = Uint16Array;\r\n\r\nexport class BufferReader {\r\n    pos = 0;\r\n    private readonly _u8;\r\n    private readonly _u16;\r\n    private readonly _u32;\r\n    private readonly _i8;\r\n    private readonly _i16;\r\n    private readonly _i32;\r\n    private readonly _f16;\r\n    private readonly _f32;\r\n    private readonly _f64;\r\n\r\n    constructor(readonly buffer: ArrayBuffer) {\r\n        this._u8 = new Uint8Array(buffer, 0, Math.floor(buffer.byteLength / Uint8Array.BYTES_PER_ELEMENT));\r\n        this._u16 = new Uint16Array(buffer, 0, Math.floor(buffer.byteLength / Uint16Array.BYTES_PER_ELEMENT));\r\n        this._u32 = new Uint32Array(buffer, 0, Math.floor(buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT));\r\n        this._i8 = new Int8Array(buffer, 0, Math.floor(buffer.byteLength / Int8Array.BYTES_PER_ELEMENT));\r\n        this._i16 = new Int16Array(buffer, 0, Math.floor(buffer.byteLength / Int16Array.BYTES_PER_ELEMENT));\r\n        this._i32 = new Int32Array(buffer, 0, Math.floor(buffer.byteLength / Int32Array.BYTES_PER_ELEMENT));\r\n        this._f16 = new Uint16Array(buffer, 0, Math.floor(buffer.byteLength / Uint16Array.BYTES_PER_ELEMENT));\r\n        this._f32 = new Float32Array(buffer, 0, Math.floor(buffer.byteLength / Float32Array.BYTES_PER_ELEMENT));\r\n        this._f64 = new Float64Array(buffer, 0, Math.floor(buffer.byteLength / Float64Array.BYTES_PER_ELEMENT));\r\n    }\r\n\r\n    private read<T extends TypedArray>(ar: T, size: number): T {\r\n        if (size == 0)\r\n            return ar.subarray(0, 0) as T;\r\n        const align = ar.BYTES_PER_ELEMENT;\r\n        var padding = (align - 1) - ((this.pos + align - 1) % align);\r\n        console.assert(padding >= 0 && padding < align);\r\n        const begin = (this.pos + padding) / align;\r\n        const end = begin + size;\r\n        this.pos = end * ar.BYTES_PER_ELEMENT;\r\n        return ar.subarray(begin, end) as T;\r\n    }\r\n\r\n    get eof() {\r\n        return this.pos == this.buffer.byteLength;\r\n    }\r\n\r\n    u8(size: number) {\r\n        return this.read(this._u8, size);\r\n    }\r\n\r\n    u16(size: number) {\r\n        return this.read(this._u16, size);\r\n    }\r\n\r\n    u32(size: number) {\r\n        return this.read(this._u32, size);\r\n    }\r\n\r\n    i8(size: number) {\r\n        return this.read(this._i8, size);\r\n    }\r\n\r\n    i16(size: number) {\r\n        return this.read(this._i16, size);\r\n    }\r\n\r\n    i32(size: number) {\r\n        return this.read(this._i32, size);\r\n    }\r\n\r\n    f16(size: number) {\r\n        return this.read(this._f16, size);\r\n    }\r\n\r\n    f32(size: number) {\r\n        return this.read(this._f32, size);\r\n    }\r\n\r\n    f64(size: number) {\r\n        return this.read(this._f64, size);\r\n    }\r\n}\r\n", "import type { CubeImages, TextureParams } from \"webgl2\";\r\nimport { GL } from \"webgl2/constants\";\r\n\r\nconst identifier = new Uint8Array([0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A]);\r\nconst HEADER_LEN = 12 + (13 * 4); // identifier + header elements (not including key value meta-data pairs)\r\n\r\nconst textureDataType = {\r\n    [GL.UNSIGNED_BYTE]: \"UNSIGNED_BYTE\",\r\n    [GL.UNSIGNED_SHORT_5_6_5]: \"UNSIGNED_SHORT_5_6_5\",\r\n    [GL.UNSIGNED_SHORT_4_4_4_4]: \"UNSIGNED_SHORT_4_4_4_4\",\r\n    [GL.UNSIGNED_SHORT_5_5_5_1]: \"UNSIGNED_SHORT_5_5_5_1\",\r\n    [GL.HALF_FLOAT]: \"HALF_FLOAT\",\r\n    // [GL.HALF_FLOAT_OES]: \"HALF_FLOAT_OES\",\r\n    [GL.FLOAT]: \"FLOAT\",\r\n    [GL.UNSIGNED_SHORT]: \"UNSIGNED_SHORT\",\r\n    [GL.UNSIGNED_INT]: \"UNSIGNED_INT\",\r\n    [GL.UNSIGNED_INT_24_8]: \"UNSIGNED_INT_24_8\",\r\n    [GL.BYTE]: \"BYTE\",\r\n    [GL.SHORT]: \"SHORT\",\r\n    [GL.INT]: \"INT\",\r\n    // [GL.FLOAT_32_UNSIGNED_INT_24_8_REV]: \"FLOAT_32_UNSIGNED_INT_24_8_REV\",\r\n    [GL.UNSIGNED_INT_5_9_9_9_REV]: \"UNSIGNED_INT_5_9_9_9_REV\",\r\n    [GL.UNSIGNED_INT_2_10_10_10_REV]: \"UNSIGNED_INT_2_10_10_10_REV\",\r\n    [GL.UNSIGNED_INT_10F_11F_11F_REV]: \"UNSIGNED_INT_10F_11F_11F_REV\",\r\n} as const;\r\ntype TextureDataType = keyof typeof textureDataType;\r\n\r\nconst textureFormatBase = {\r\n    [GL.RGB]: \"RGB\",\r\n    [GL.RGBA]: \"RGBA\",\r\n    [GL.ALPHA]: \"ALPHA\",\r\n    [GL.LUMINANCE]: \"LUMINANCE\",\r\n    [GL.LUMINANCE_ALPHA]: \"LUMINANCE_ALPHA\",\r\n    [GL.DEPTH_COMPONENT]: \"DEPTH_COMPONENT\",\r\n    [GL.DEPTH_STENCIL]: \"DEPTH_STENCIL\",\r\n    [GL.SRGB_EXT]: \"SRGB_EXT\",\r\n    [GL.SRGB_ALPHA_EXT]: \"SRGB_ALPHA_EXT\",\r\n    [GL.RED]: \"RED\",\r\n    [GL.RG]: \"RG\",\r\n    [GL.RED_INTEGER]: \"RED_INTEGER\",\r\n    [GL.RG_INTEGER]: \"RG_INTEGER\",\r\n    [GL.RGB_INTEGER]: \"RGB_INTEGER\",\r\n    [GL.RGBA_INTEGER]: \"RGBA_INTEGER\",\r\n} as const;\r\ntype TextureFormatBase = keyof typeof textureFormatBase;\r\n\r\nconst textureFormatUncompressed = {\r\n    [GL.R8]: \"R8\",\r\n    [GL.R8_SNORM]: \"R8_SNORM\",\r\n    [GL.RG8]: \"RG8\",\r\n    [GL.RG8_SNORM]: \"RG8_SNORM\",\r\n    [GL.RGB8]: \"RGB8\",\r\n    [GL.RGB8_SNORM]: \"RGB8_SNORM\",\r\n    [GL.RGB565]: \"RGB565\",\r\n    [GL.RGBA4]: \"RGBA4\",\r\n    [GL.RGB5_A1]: \"RGB5_A1\",\r\n    [GL.RGBA8]: \"RGBA8\",\r\n    [GL.RGBA8_SNORM]: \"RGBA8_SNORM\",\r\n    [GL.RGB10_A2]: \"RGB10_A2\",\r\n    [GL.RGB10_A2UI]: \"RGB10_A2UI\",\r\n    [GL.SRGB8]: \"SRGB8\",\r\n    [GL.SRGB8_ALPHA8]: \"SRGB8_ALPHA8\",\r\n    [GL.R16F]: \"R16F\",\r\n    [GL.RG16F]: \"RG16F\",\r\n    [GL.RGB16F]: \"RGB16F\",\r\n    [GL.RGBA16F]: \"RGBA16F\",\r\n    [GL.R32F]: \"R32F\",\r\n    [GL.RG32F]: \"RG32F\",\r\n    [GL.RGB32F]: \"RGB32F\",\r\n    [GL.RGBA32F]: \"RGBA32F\",\r\n    [GL.R11F_G11F_B10F]: \"R11F_G11F_B10F\",\r\n    [GL.RGB9_E5]: \"RGB9_E5\",\r\n    [GL.R8I]: \"R8I\",\r\n    [GL.R8UI]: \"R8UI\",\r\n    [GL.R16I]: \"R16I\",\r\n    [GL.R16UI]: \"R16UI\",\r\n    [GL.R32I]: \"R32I\",\r\n    [GL.R32UI]: \"R32UI\",\r\n    [GL.RG8I]: \"RG8I\",\r\n    [GL.RG8UI]: \"RG8UI\",\r\n    [GL.RG16I]: \"RG16I\",\r\n    [GL.RG16UI]: \"RG16UI\",\r\n    [GL.RG32I]: \"RG32I\",\r\n    [GL.RG32UI]: \"RG32UI\",\r\n    [GL.RGB8I]: \"RGB8I\",\r\n    [GL.RGB8UI]: \"RGB8UI\",\r\n    [GL.RGB16I]: \"RGB16I\",\r\n    [GL.RGB16UI]: \"RGB16UI\",\r\n    [GL.RGB32I]: \"RGB32I\",\r\n    [GL.RGB32UI]: \"RGB32UI\",\r\n    [GL.RGBA8I]: \"RGBA8I\",\r\n    [GL.RGBA8UI]: \"RGBA8UI\",\r\n    [GL.RGBA16I]: \"RGBA16I\",\r\n    [GL.RGBA16UI]: \"RGBA16UI\",\r\n    [GL.RGBA32I]: \"RGBA32I\",\r\n    [GL.RGBA32UI]: \"RGBA32UI\",\r\n    // [GL.SRGB8_ALPHA8_EXT]: \"SRGB8_ALPHA8_EXT\",\r\n} as const\r\ntype TextureFormatUncompressed = keyof typeof textureFormatUncompressed;\r\ntype TextureFormatUncompressedString = (typeof textureFormatUncompressed)[TextureFormatUncompressed]\r\n\r\nconst textureFormatCompressed = {\r\n    [GL.COMPRESSED_RGB_S3TC_DXT1_EXT]: \"COMPRESSED_RGB_S3TC_DXT1_EXT\",\r\n    [GL.COMPRESSED_RGBA_S3TC_DXT1_EXT]: \"COMPRESSED_RGBA_S3TC_DXT1_EXT\",\r\n    [GL.COMPRESSED_RGBA_S3TC_DXT3_EXT]: \"COMPRESSED_RGBA_S3TC_DXT3_EXT\",\r\n    [GL.COMPRESSED_RGBA_S3TC_DXT5_EXT]: \"COMPRESSED_RGBA_S3TC_DXT5_EXT\",\r\n    [GL.COMPRESSED_R11_EAC]: \"COMPRESSED_R11_EAC\",\r\n    [GL.COMPRESSED_SIGNED_R11_EAC]: \"COMPRESSED_SIGNED_R11_EAC\",\r\n    [GL.COMPRESSED_RG11_EAC]: \"COMPRESSED_RG11_EAC\",\r\n    [GL.COMPRESSED_SIGNED_RG11_EAC]: \"COMPRESSED_SIGNED_RG11_EAC\",\r\n    [GL.COMPRESSED_RGB8_ETC2]: \"COMPRESSED_RGB8_ETC2\",\r\n    [GL.COMPRESSED_RGBA8_ETC2_EAC]: \"COMPRESSED_RGBA8_ETC2_EAC\",\r\n    [GL.COMPRESSED_SRGB8_ETC2]: \"COMPRESSED_SRGB8_ETC2\",\r\n    [GL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: \"COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\",\r\n    [GL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: \"COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\",\r\n    [GL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: \"COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\",\r\n    [GL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG]: \"COMPRESSED_RGB_PVRTC_4BPPV1_IMG\",\r\n    [GL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG]: \"COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\",\r\n    [GL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG]: \"COMPRESSED_RGB_PVRTC_2BPPV1_IMG\",\r\n    [GL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG]: \"COMPRESSED_RGBA_PVRTC_2BPPV1_IMG\",\r\n    [GL.COMPRESSED_RGB_ETC1_WEBGL]: \"COMPRESSED_RGB_ETC1_WEBGL\",\r\n    // [GL.COMPRESSED_RGB_ATC_WEBGL]: \"COMPRESSED_RGB_ATC_WEBGL\",\r\n    // [GL.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL]: \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\",\r\n    // [GL.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL]: \"COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL\",\r\n} as const;\r\ntype TextureFormatCompressed = keyof typeof textureFormatCompressed;\r\n\r\nconst textureFormatInternal = {\r\n    ...textureFormatUncompressed,\r\n    ...textureFormatCompressed,\r\n    // [GL.DEPTH_COMPONENT16]: \"DEPTH_COMPONENT16\",\r\n    // [GL.DEPTH_COMPONENT24]: \"DEPTH_COMPONENT24\",\r\n    // [GL.DEPTH_COMPONENT32F]: \"DEPTH_COMPONENT32F\",\r\n    // [GL.DEPTH32F_STENCIL8]: \"DEPTH32F_STENCIL8\",\r\n} as const;\r\ntype TextureFormatInternal = keyof typeof textureFormatInternal;\r\n\r\nfunction parseHeader(ktx: Uint8Array) {\r\n    const idDataView = new DataView(ktx.buffer, ktx.byteOffset, 12);\r\n    for (let i = 0; i < identifier.length; i++) {\r\n        if (idDataView.getUint8(i) != identifier[i]) {\r\n            throw new Error(\"texture missing KTX identifier\");\r\n        }\r\n    }\r\n\r\n    // load the rest of the header in native 32 bit uint\r\n    const dataSize = Uint32Array.BYTES_PER_ELEMENT;\r\n    const headerDataView = new DataView(ktx.buffer, 12 + ktx.byteOffset, 13 * dataSize);\r\n    const endianness = headerDataView.getUint32(0, true);\r\n    const littleEndian = endianness === 0x04030201;\r\n\r\n    return {\r\n        glType: headerDataView.getUint32(1 * dataSize, littleEndian) as 0 | TextureDataType,// must be 0 for compressed textures\r\n        glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian), // must be 1 for compressed textures\r\n        glFormat: headerDataView.getUint32(3 * dataSize, littleEndian) as 0 | TextureFormatBase, // must be 0 for compressed textures\r\n        glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian) as TextureFormatInternal, // the value of arg passed to gl.texImage2D() or gl.compressedTexImage2D(,,x,,,,)\r\n        glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian) as TextureFormatBase, // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\r\n        pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\r\n        pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\r\n        pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian), // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\r\n        numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian), // used for texture arrays\r\n        numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian), // used for cubemap textures, should either be 1 or 6\r\n        numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian), // number of levels; disregard possibility of 0 for compressed textures\r\n        bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian), // the amount of space after the header for meta-data\r\n        littleEndian,\r\n    };\r\n}\r\n\r\ntype Header = ReturnType<typeof parseHeader>;\r\n\r\nfunction* getImages(header: Header, ktx: Uint8Array, littleEndian: boolean) {\r\n    const mips = Math.max(1, header.numberOfMipmapLevels);\r\n    const elements = Math.max(1, header.numberOfArrayElements);\r\n    const faces = header.numberOfFaces;\r\n    const depth = Math.max(1, header.pixelDepth);\r\n    let dataOffset = HEADER_LEN + header.bytesOfKeyValueData;\r\n    const imageSizeDenom = (faces == 6 && header.numberOfArrayElements == 0) ? 1 : elements * faces * depth;\r\n    const dataView = new DataView(ktx.buffer, ktx.byteOffset);\r\n\r\n    for (let mip = 0; mip < mips; mip++) {\r\n        const width = header.pixelWidth >> mip;\r\n        const height = header.pixelHeight >> mip;\r\n        const imageSize = dataView.getInt32(dataOffset, littleEndian);\r\n        dataOffset += 4;\r\n        const imageStride = imageSize / imageSizeDenom;\r\n        console.assert(imageStride % 4 == 0);\r\n        for (let element = 0; element < elements; element++) {\r\n            for (let face = 0; face < faces; face++) {\r\n                for (let z_slice = 0; z_slice < depth; z_slice++) {\r\n                    // const target = faces == 6 ? GL.TEXTURE_CUBE_MAP_POSITIVE_X + face : GL.TEXTURE_2D;\r\n                    const begin = dataOffset;\r\n                    dataOffset += imageStride;\r\n                    const end = dataOffset;\r\n                    const image = { mip, element, face, width, height, blobRange: [begin, end], buffer: ktx.subarray(begin, end) } as const;\r\n                    yield image;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    console.assert(dataOffset == ktx.byteLength);\r\n}\r\n\r\n/** @internal */\r\nexport function parseKTX(ktx: Uint8Array): TextureParams {\r\n    const header = parseHeader(ktx);\r\n    const { littleEndian } = header;\r\n    const baseFormat = textureFormatBase[header.glBaseInternalFormat]; // we don't really need this here (but may be useful for debugging).\r\n    const isArray = header.numberOfArrayElements > 0;\r\n    const isCube = header.numberOfFaces == 6;\r\n    const is3D = header.pixelDepth > 0;\r\n    const hasMips = header.numberOfMipmapLevels > 1;\r\n    const numMips = Math.max(1, header.numberOfMipmapLevels);\r\n    const internalFormat = textureFormatInternal[header.glInternalFormat];\r\n    const kind = isArray ? \"TEXTURE_ARRAY\" : isCube ? \"TEXTURE_CUBE_MAP\" : is3D ? \"TEXTURE_3D\" : \"TEXTURE_2D\";\r\n    const type = header.glType ? textureDataType[header.glType] : undefined;\r\n    const dim = { width: header.pixelWidth, height: header.pixelHeight, ...(is3D ? { depth: header.pixelDepth } : undefined) };\r\n    let mips: CubeImages[] | BufferSource[] = undefined!;\r\n    if (isCube) {\r\n        const images = new Array(numMips).fill(null).map(_ => ([] as any[]));\r\n        for (const image of getImages(header, ktx, littleEndian)) {\r\n            images[image.mip][image.face] = image.buffer;\r\n        }\r\n        mips = images as unknown as CubeImages[];\r\n    } else {\r\n        mips = new Array<BufferSource>(numMips);\r\n        for (const image of getImages(header, ktx, littleEndian)) {\r\n            mips[image.mip] = image.buffer;\r\n        }\r\n    }\r\n    const imageData = hasMips ? { mipMaps: mips } as const : { image: mips[0] } as const;\r\n    return {\r\n        kind,\r\n        internalFormat,\r\n        type: type,\r\n        ...dim,\r\n        ...imageData,\r\n    } as TextureParams;\r\n    // throw new Error(\"UnsupportedKTX format!\");\r\n}\r\n", "// this file is auto generated - do not edit!\r\nimport { BufferReader } from \"./util.js\";\r\nimport type { EnumArray, U8, U16, U32, I8, I16, I32, F16, F32, F64 } from \"./util.js\";\r\n\r\nexport const version = \"2.1\";\r\n\r\n// Type of GL render primitive.\r\nexport const enum PrimitiveType {\r\n    points = 0,\r\n    lines = 1,\r\n    line_loops = 2,\r\n    line_strip = 3,\r\n    triangles = 4,\r\n    triangle_strip = 5,\r\n    triangle_fan = 6,\r\n};\r\n\r\n// Bitwise flags for which vertex attributes will be used in geometry.\r\nexport const enum OptionalVertexAttribute {\r\n    normal = 1,\r\n    color = 2,\r\n    texCoord = 4,\r\n    projectedPos = 8,\r\n};\r\n\r\n// Type of material.\r\nexport const enum MaterialType {\r\n    opaque = 0,\r\n    opaqueDoubleSided = 1,\r\n    transparent = 2,\r\n    elevation = 3,\r\n};\r\n\r\n// Texture semantic/purpose.\r\nexport const enum TextureSemantic {\r\n    baseColor = 0,\r\n};\r\n\r\n// Hash bytes\r\nexport interface HashRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Range into submesh projection.\r\nexport interface SubMeshProjectionRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Range into descendantObjectIdsRange.\r\nexport interface DescendantObjectIdsRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Mesh vertices\r\nexport interface VertexRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Mesh vertex indices\r\nexport interface VertexIndexRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Mesh Textures\r\nexport interface TextureInfoRange { readonly start: U8; readonly count: U8; };\r\n\r\n// Range into texture pixel blob.\r\nexport interface PixelRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Information about child nodes.\r\nexport interface ChildInfo {\r\n    readonly length: number;\r\n    readonly hash: HashRange; // Byte range into Hash bytes array. The hash, formatted as hex, is used for the filename of the child node.\r\n    readonly childIndex: U8;\r\n    readonly childMask: U32; // Set of bits (max 32) for which child indices are referenced by geometry.\r\n    readonly tolerance: I8; // A power of two exponent describing the error tolerance of this node, which is used to determine LOD.\r\n    readonly totalByteSize: U32; // # uncompressed bytes total for child binary file.\r\n    readonly offset: Double3; // Model -> world space translation vector.\r\n    readonly scale: F32; // Model -> world space uniform scale factor (from unit [-1,1] vectors).\r\n    readonly bounds: Bounds; // Bounding volume (in model space).\r\n    readonly subMeshes: SubMeshProjectionRange;\r\n    readonly descendantObjectIds: DescendantObjectIdsRange;\r\n};\r\n\r\nexport interface Double3 {\r\n    readonly length: number;\r\n    readonly x: F64;\r\n    readonly y: F64;\r\n    readonly z: F64;\r\n};\r\n\r\n// Node bounding volume.\r\nexport interface Bounds {\r\n    readonly length: number;\r\n    readonly box: AABB;\r\n    readonly sphere: BoundingSphere;\r\n};\r\n\r\n// Axis aligned bounding box.\r\nexport interface AABB {\r\n    readonly length: number;\r\n    readonly min: Float3;\r\n    readonly max: Float3;\r\n};\r\n\r\nexport interface Float3 {\r\n    readonly length: number;\r\n    readonly x: F32;\r\n    readonly y: F32;\r\n    readonly z: F32;\r\n};\r\n\r\n// Bounding sphere.\r\nexport interface BoundingSphere {\r\n    readonly length: number;\r\n    readonly origo: Float3;\r\n    readonly radius: F32;\r\n};\r\n\r\n// Information about child sub meshes used to predict cost before loading.\r\nexport interface SubMeshProjection {\r\n    readonly length: number;\r\n    readonly objectId: U32;\r\n    readonly primitiveType: EnumArray<PrimitiveType>;\r\n    readonly attributes: EnumArray<OptionalVertexAttribute>;\r\n    readonly numDeviations: U8; // # of deviation vertex attributes (0-3)\r\n    readonly numIndices: U32; // zero if no index buffer\r\n    readonly numVertices: U32;\r\n    readonly numTextureBytes: U32;\r\n};\r\n\r\n// Groups of 3D primitives with common attributes. These can further be split up to form e.g. 64K chunks for 16 bit indexing, i.e. there can be many submeshes with the same attributes. Groups are ordered by child, object and material indices.\r\nexport interface SubMesh {\r\n    readonly length: number;\r\n    readonly childIndex: U8;\r\n    readonly objectId: U32;\r\n    readonly materialIndex: U8;\r\n    readonly primitiveType: EnumArray<PrimitiveType>;\r\n    readonly materialType: EnumArray<MaterialType>;\r\n    readonly attributes: EnumArray<OptionalVertexAttribute>;\r\n    readonly numDeviations: U8; // # of deviation vertex attributes (0-4)\r\n    readonly vertices: VertexRange; // Vertices are local to each sub-mesh.\r\n    readonly primitiveVertexIndices: VertexIndexRange; // Triangle vertex index triplets, or line index pairs, if any, are 16-bit and relative to the local vertex range.\r\n    readonly edgeVertexIndices: VertexIndexRange; // \"Hard\" edge vertex index pairs, if any, are 16-bit and relative to the local vertex range.\r\n    readonly cornerVertexIndices: VertexIndexRange; // \"Hard\" corner vertex indices, if any, are 16-bit and relative to the local vertex range.\r\n    readonly textures: TextureInfoRange;\r\n};\r\n\r\nexport interface TextureInfo {\r\n    readonly length: number;\r\n    readonly semantic: EnumArray<TextureSemantic>;\r\n    readonly transform: Float3x3;\r\n    readonly pixelRange: PixelRange;\r\n};\r\n\r\n// 3x3 row major matrix\r\nexport interface Float3x3 {\r\n    readonly length: number;\r\n    readonly e00: F32;\r\n    readonly e01: F32;\r\n    readonly e02: F32;\r\n    readonly e10: F32;\r\n    readonly e11: F32;\r\n    readonly e12: F32;\r\n    readonly e20: F32;\r\n    readonly e21: F32;\r\n    readonly e22: F32;\r\n};\r\n\r\n// Mesh vertices\r\nexport interface Vertex {\r\n    readonly length: number;\r\n    readonly position: Int16_3;\r\n    readonly normal?: Int8_3;\r\n    readonly color?: RGBA_U8;\r\n    readonly texCoord?: Half2;\r\n    readonly projectedPos?: Int16_3;\r\n    readonly deviations: Deviations;\r\n};\r\n\r\nexport interface Int16_3 {\r\n    readonly length: number;\r\n    readonly x: I16;\r\n    readonly y: I16;\r\n    readonly z: I16;\r\n};\r\n\r\nexport interface Int8_3 {\r\n    readonly length: number;\r\n    readonly x: I8;\r\n    readonly y: I8;\r\n    readonly z: I8;\r\n};\r\n\r\nexport interface RGBA_U8 {\r\n    readonly length: number;\r\n    readonly red: U8;\r\n    readonly green: U8;\r\n    readonly blue: U8;\r\n    readonly alpha: U8;\r\n};\r\n\r\nexport interface Half2 {\r\n    readonly length: number;\r\n    readonly x: F16;\r\n    readonly y: F16;\r\n};\r\n\r\n// Mesh deviations vertex attributes\r\nexport interface Deviations {\r\n    readonly length: number;\r\n    readonly a?: F16;\r\n    readonly b?: F16;\r\n    readonly c?: F16;\r\n    readonly d?: F16;\r\n};\r\n\r\n// Mesh triangles\r\nexport interface Triangle {\r\n    readonly length: number;\r\n    readonly topologyFlags?: U8; // Bits [0-2] are edge flags (vertex pairs ab, bc, ca), and [3-5] are corner flags. True = edge/corner is a \"hard\", or true topological feature and should be rendered and/or snapped to.\r\n};\r\n\r\nexport function readSchema(r: BufferReader) {\r\n    const sizes = r.u32(10);\r\n    const flags = r.u8(10);\r\n    const schema = {\r\n        version: \"2.1\",\r\n        childInfo: {\r\n            length: sizes[0],\r\n            hash: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) } as HashRange,\r\n            childIndex: r.u8(sizes[0]),\r\n            childMask: r.u32(sizes[0]),\r\n            tolerance: r.i8(sizes[0]),\r\n            totalByteSize: r.u32(sizes[0]),\r\n            offset: {\r\n                length: sizes[0],\r\n                x: r.f64(sizes[0]),\r\n                y: r.f64(sizes[0]),\r\n                z: r.f64(sizes[0]),\r\n            } as Double3,\r\n            scale: r.f32(sizes[0]),\r\n            bounds: {\r\n                length: sizes[0],\r\n                box: {\r\n                    length: sizes[0],\r\n                    min: {\r\n                        length: sizes[0],\r\n                        x: r.f32(sizes[0]),\r\n                        y: r.f32(sizes[0]),\r\n                        z: r.f32(sizes[0]),\r\n                    } as Float3,\r\n                    max: {\r\n                        length: sizes[0],\r\n                        x: r.f32(sizes[0]),\r\n                        y: r.f32(sizes[0]),\r\n                        z: r.f32(sizes[0]),\r\n                    } as Float3,\r\n                } as AABB,\r\n                sphere: {\r\n                    length: sizes[0],\r\n                    origo: {\r\n                        length: sizes[0],\r\n                        x: r.f32(sizes[0]),\r\n                        y: r.f32(sizes[0]),\r\n                        z: r.f32(sizes[0]),\r\n                    } as Float3,\r\n                    radius: r.f32(sizes[0]),\r\n                } as BoundingSphere,\r\n            } as Bounds,\r\n            subMeshes: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) } as SubMeshProjectionRange,\r\n            descendantObjectIds: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) } as DescendantObjectIdsRange,\r\n        } as ChildInfo,\r\n        hashBytes: r.u8(sizes[1]),\r\n        descendantObjectIds: r.u32(sizes[2]),\r\n        subMeshProjection: {\r\n            length: sizes[3],\r\n            objectId: r.u32(sizes[3]),\r\n            primitiveType: r.u8(sizes[3]) as EnumArray<PrimitiveType>,\r\n            attributes: r.u8(sizes[3]) as EnumArray<OptionalVertexAttribute>,\r\n            numDeviations: r.u8(sizes[3]),\r\n            numIndices: r.u32(sizes[3]),\r\n            numVertices: r.u32(sizes[3]),\r\n            numTextureBytes: r.u32(sizes[3]),\r\n        } as SubMeshProjection,\r\n        subMesh: {\r\n            length: sizes[4],\r\n            childIndex: r.u8(sizes[4]),\r\n            objectId: r.u32(sizes[4]),\r\n            materialIndex: r.u8(sizes[4]),\r\n            primitiveType: r.u8(sizes[4]) as EnumArray<PrimitiveType>,\r\n            materialType: r.u8(sizes[4]) as EnumArray<MaterialType>,\r\n            attributes: r.u8(sizes[4]) as EnumArray<OptionalVertexAttribute>,\r\n            numDeviations: r.u8(sizes[4]),\r\n            vertices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) } as VertexRange,\r\n            primitiveVertexIndices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) } as VertexIndexRange,\r\n            edgeVertexIndices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) } as VertexIndexRange,\r\n            cornerVertexIndices: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) } as VertexIndexRange,\r\n            textures: { start: r.u8(sizes[4]), count: r.u8(sizes[4]) } as TextureInfoRange,\r\n        } as SubMesh,\r\n        textureInfo: {\r\n            length: sizes[5],\r\n            semantic: r.u8(sizes[5]) as EnumArray<TextureSemantic>,\r\n            transform: {\r\n                length: sizes[5],\r\n                e00: r.f32(sizes[5]),\r\n                e01: r.f32(sizes[5]),\r\n                e02: r.f32(sizes[5]),\r\n                e10: r.f32(sizes[5]),\r\n                e11: r.f32(sizes[5]),\r\n                e12: r.f32(sizes[5]),\r\n                e20: r.f32(sizes[5]),\r\n                e21: r.f32(sizes[5]),\r\n                e22: r.f32(sizes[5]),\r\n            } as Float3x3,\r\n            pixelRange: { start: r.u32(sizes[5]), count: r.u32(sizes[5]) } as PixelRange,\r\n        } as TextureInfo,\r\n        vertex: {\r\n            length: sizes[6],\r\n            position: {\r\n                length: sizes[6],\r\n                x: r.i16(sizes[6]),\r\n                y: r.i16(sizes[6]),\r\n                z: r.i16(sizes[6]),\r\n            } as Int16_3,\r\n            normal: !flags[0] ? undefined : {\r\n                length: sizes[6],\r\n                x: r.i8(sizes[6]),\r\n                y: r.i8(sizes[6]),\r\n                z: r.i8(sizes[6]),\r\n            } as Int8_3,\r\n            color: !flags[1] ? undefined : {\r\n                length: sizes[6],\r\n                red: r.u8(sizes[6]),\r\n                green: r.u8(sizes[6]),\r\n                blue: r.u8(sizes[6]),\r\n                alpha: r.u8(sizes[6]),\r\n            } as RGBA_U8,\r\n            texCoord: !flags[2] ? undefined : {\r\n                length: sizes[6],\r\n                x: r.f16(sizes[6]),\r\n                y: r.f16(sizes[6]),\r\n            } as Half2,\r\n            projectedPos: !flags[3] ? undefined : {\r\n                length: sizes[6],\r\n                x: r.i16(sizes[6]),\r\n                y: r.i16(sizes[6]),\r\n                z: r.i16(sizes[6]),\r\n            } as Int16_3,\r\n            deviations: {\r\n                length: sizes[6],\r\n                a: !flags[4] ? undefined : r.f16(sizes[6]),\r\n                b: !flags[5] ? undefined : r.f16(sizes[6]),\r\n                c: !flags[6] ? undefined : r.f16(sizes[6]),\r\n                d: !flags[7] ? undefined : r.f16(sizes[6]),\r\n            } as Deviations,\r\n        } as Vertex,\r\n        triangle: {\r\n            length: sizes[7],\r\n            topologyFlags: !flags[8] ? undefined : r.u8(sizes[7]),\r\n        } as Triangle,\r\n        vertexIndex: !flags[9] ? undefined : r.u16(sizes[8]),\r\n        texturePixels: r.u8(sizes[9]),\r\n    } as const;\r\n    console.assert(r.eof);\r\n    return schema;\r\n}\r\n\r\nexport type Schema = ReturnType<typeof readSchema>;\r\n", "// this file is auto generated - do not edit!\r\nimport { BufferReader } from \"./util.js\";\r\nimport type { EnumArray, U8, U16, U32, I8, I16, I32, F16, F32, F64 } from \"./util.js\";\r\n\r\nexport const version = \"2.0\";\r\n\r\n// Type of GL render primitive.\r\nexport const enum PrimitiveType {\r\n    points = 0,\r\n    lines = 1,\r\n    line_loops = 2,\r\n    line_strip = 3,\r\n    triangles = 4,\r\n    triangle_strip = 5,\r\n    triangle_fan = 6,\r\n};\r\n\r\n// Bitwise flags for which vertex attributes will be used in geometry.\r\nexport const enum OptionalVertexAttribute {\r\n    normal = 1,\r\n    color = 2,\r\n    texCoord = 4,\r\n    projectedPos = 8,\r\n};\r\n\r\n// Type of material.\r\nexport const enum MaterialType {\r\n    opaque = 0,\r\n    opaqueDoubleSided = 1,\r\n    transparent = 2,\r\n    elevation = 3,\r\n};\r\n\r\n// Texture semantic/purpose.\r\nexport const enum TextureSemantic {\r\n    baseColor = 0,\r\n};\r\n\r\n// Hash bytes\r\nexport interface HashRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Range into submesh projection.\r\nexport interface SubMeshProjectionRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Mesh vertices\r\nexport interface VertexRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Mesh vertex indices\r\nexport interface VertexIndexRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Mesh Textures\r\nexport interface TextureInfoRange { readonly start: U8; readonly count: U8; };\r\n\r\n// Range into texture pixel blob.\r\nexport interface PixelRange { readonly start: U32; readonly count: U32; };\r\n\r\n// Information about child nodes.\r\nexport interface ChildInfo {\r\n    readonly length: number;\r\n    readonly hash: HashRange; // Byte range into Hash bytes array. The hash, formatted as hex, is used for the filename of the child node.\r\n    readonly childIndex: U8;\r\n    readonly childMask: U32; // Set of bits (max 32) for which child indices are referenced by geometry.\r\n    readonly tolerance: I8; // A power of two exponent describing the error tolerance of this node, which is used to determine LOD.\r\n    readonly totalByteSize: U32; // # uncompressed bytes total for child binary file.\r\n    readonly offset: Double3; // Model -> world space translation vector.\r\n    readonly scale: F32; // Model -> world space uniform scale factor (from unit [-1,1] vectors).\r\n    readonly bounds: Bounds; // Bounding volume (in model space).\r\n    readonly subMeshes: SubMeshProjectionRange;\r\n};\r\n\r\nexport interface Double3 {\r\n    readonly length: number;\r\n    readonly x: F64;\r\n    readonly y: F64;\r\n    readonly z: F64;\r\n};\r\n\r\n// Node bounding volume.\r\nexport interface Bounds {\r\n    readonly length: number;\r\n    readonly box: AABB;\r\n    readonly sphere: BoundingSphere;\r\n};\r\n\r\n// Axis aligned bounding box.\r\nexport interface AABB {\r\n    readonly length: number;\r\n    readonly min: Float3;\r\n    readonly max: Float3;\r\n};\r\n\r\nexport interface Float3 {\r\n    readonly length: number;\r\n    readonly x: F32;\r\n    readonly y: F32;\r\n    readonly z: F32;\r\n};\r\n\r\n// Bounding sphere.\r\nexport interface BoundingSphere {\r\n    readonly length: number;\r\n    readonly origo: Float3;\r\n    readonly radius: F32;\r\n};\r\n\r\n// Information about child sub meshes used to predict cost before loading.\r\nexport interface SubMeshProjection {\r\n    readonly length: number;\r\n    readonly objectId: U32;\r\n    readonly primitiveType: EnumArray<PrimitiveType>;\r\n    readonly attributes: EnumArray<OptionalVertexAttribute>;\r\n    readonly numDeviations: U8; // # of deviation vertex attributes (0-3)\r\n    readonly numIndices: U32; // zero if no index buffer\r\n    readonly numVertices: U32;\r\n    readonly numTextureBytes: U32;\r\n};\r\n\r\n// Groups of 3D primitives with common attributes. These can further be split up to form e.g. 64K chunks for 16 bit indexing, i.e. there can be many submeshes with the same attributes. Groups are ordered by child, object and material indices.\r\nexport interface SubMesh {\r\n    readonly length: number;\r\n    readonly childIndex: U8;\r\n    readonly objectId: U32;\r\n    readonly materialIndex: U8;\r\n    readonly primitiveType: EnumArray<PrimitiveType>;\r\n    readonly materialType: EnumArray<MaterialType>;\r\n    readonly attributes: EnumArray<OptionalVertexAttribute>;\r\n    readonly numDeviations: U8; // # of deviation vertex attributes (0-4)\r\n    readonly vertices: VertexRange; // Vertices are local to each sub-mesh.\r\n    readonly primitiveVertexIndices: VertexIndexRange; // Triangle vertex index triplets, or line index pairs, if any, are 16-bit and relative to the local vertex range.\r\n    readonly edgeVertexIndices: VertexIndexRange; // \"Hard\" edge vertex index pairs, if any, are 16-bit and relative to the local vertex range.\r\n    readonly cornerVertexIndices: VertexIndexRange; // \"Hard\" corner vertex indices, if any, are 16-bit and relative to the local vertex range.\r\n    readonly textures: TextureInfoRange;\r\n};\r\n\r\nexport interface TextureInfo {\r\n    readonly length: number;\r\n    readonly semantic: EnumArray<TextureSemantic>;\r\n    readonly transform: Float3x3;\r\n    readonly pixelRange: PixelRange;\r\n};\r\n\r\n// 3x3 row major matrix\r\nexport interface Float3x3 {\r\n    readonly length: number;\r\n    readonly e00: F32;\r\n    readonly e01: F32;\r\n    readonly e02: F32;\r\n    readonly e10: F32;\r\n    readonly e11: F32;\r\n    readonly e12: F32;\r\n    readonly e20: F32;\r\n    readonly e21: F32;\r\n    readonly e22: F32;\r\n};\r\n\r\n// Mesh vertices\r\nexport interface Vertex {\r\n    readonly length: number;\r\n    readonly position: Int16_3;\r\n    readonly normal?: Int8_3;\r\n    readonly color?: RGBA_U8;\r\n    readonly texCoord?: Half2;\r\n    readonly projectedPos?: Int16_3;\r\n    readonly deviations: Deviations;\r\n};\r\n\r\nexport interface Int16_3 {\r\n    readonly length: number;\r\n    readonly x: I16;\r\n    readonly y: I16;\r\n    readonly z: I16;\r\n};\r\n\r\nexport interface Int8_3 {\r\n    readonly length: number;\r\n    readonly x: I8;\r\n    readonly y: I8;\r\n    readonly z: I8;\r\n};\r\n\r\nexport interface RGBA_U8 {\r\n    readonly length: number;\r\n    readonly red: U8;\r\n    readonly green: U8;\r\n    readonly blue: U8;\r\n    readonly alpha: U8;\r\n};\r\n\r\nexport interface Half2 {\r\n    readonly length: number;\r\n    readonly x: F16;\r\n    readonly y: F16;\r\n};\r\n\r\n// Mesh deviations vertex attributes\r\nexport interface Deviations {\r\n    readonly length: number;\r\n    readonly a?: F16;\r\n    readonly b?: F16;\r\n    readonly c?: F16;\r\n    readonly d?: F16;\r\n};\r\n\r\n// Mesh triangles\r\nexport interface Triangle {\r\n    readonly length: number;\r\n    readonly topologyFlags?: U8; // Bits [0-2] are edge flags (vertex pairs ab, bc, ca), and [3-5] are corner flags. True = edge/corner is a \"hard\", or true topological feature and should be rendered and/or snapped to.\r\n};\r\n\r\nexport function readSchema(r: BufferReader) {\r\n    const sizes = r.u32(9);\r\n    const flags = r.u8(10);\r\n    const schema = {\r\n        version: \"2.0\",\r\n        childInfo: {\r\n            length: sizes[0],\r\n            hash: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) } as HashRange,\r\n            childIndex: r.u8(sizes[0]),\r\n            childMask: r.u32(sizes[0]),\r\n            tolerance: r.i8(sizes[0]),\r\n            totalByteSize: r.u32(sizes[0]),\r\n            offset: {\r\n                length: sizes[0],\r\n                x: r.f64(sizes[0]),\r\n                y: r.f64(sizes[0]),\r\n                z: r.f64(sizes[0]),\r\n            } as Double3,\r\n            scale: r.f32(sizes[0]),\r\n            bounds: {\r\n                length: sizes[0],\r\n                box: {\r\n                    length: sizes[0],\r\n                    min: {\r\n                        length: sizes[0],\r\n                        x: r.f32(sizes[0]),\r\n                        y: r.f32(sizes[0]),\r\n                        z: r.f32(sizes[0]),\r\n                    } as Float3,\r\n                    max: {\r\n                        length: sizes[0],\r\n                        x: r.f32(sizes[0]),\r\n                        y: r.f32(sizes[0]),\r\n                        z: r.f32(sizes[0]),\r\n                    } as Float3,\r\n                } as AABB,\r\n                sphere: {\r\n                    length: sizes[0],\r\n                    origo: {\r\n                        length: sizes[0],\r\n                        x: r.f32(sizes[0]),\r\n                        y: r.f32(sizes[0]),\r\n                        z: r.f32(sizes[0]),\r\n                    } as Float3,\r\n                    radius: r.f32(sizes[0]),\r\n                } as BoundingSphere,\r\n            } as Bounds,\r\n            subMeshes: { start: r.u32(sizes[0]), count: r.u32(sizes[0]) } as SubMeshProjectionRange,\r\n        } as ChildInfo,\r\n        hashBytes: r.u8(sizes[1]),\r\n        subMeshProjection: {\r\n            length: sizes[2],\r\n            objectId: r.u32(sizes[2]),\r\n            primitiveType: r.u8(sizes[2]) as EnumArray<PrimitiveType>,\r\n            attributes: r.u8(sizes[2]) as EnumArray<OptionalVertexAttribute>,\r\n            numDeviations: r.u8(sizes[2]),\r\n            numIndices: r.u32(sizes[2]),\r\n            numVertices: r.u32(sizes[2]),\r\n            numTextureBytes: r.u32(sizes[2]),\r\n        } as SubMeshProjection,\r\n        subMesh: {\r\n            length: sizes[3],\r\n            childIndex: r.u8(sizes[3]),\r\n            objectId: r.u32(sizes[3]),\r\n            materialIndex: r.u8(sizes[3]),\r\n            primitiveType: r.u8(sizes[3]) as EnumArray<PrimitiveType>,\r\n            materialType: r.u8(sizes[3]) as EnumArray<MaterialType>,\r\n            attributes: r.u8(sizes[3]) as EnumArray<OptionalVertexAttribute>,\r\n            numDeviations: r.u8(sizes[3]),\r\n            vertices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) } as VertexRange,\r\n            primitiveVertexIndices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) } as VertexIndexRange,\r\n            edgeVertexIndices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) } as VertexIndexRange,\r\n            cornerVertexIndices: { start: r.u32(sizes[3]), count: r.u32(sizes[3]) } as VertexIndexRange,\r\n            textures: { start: r.u8(sizes[3]), count: r.u8(sizes[3]) } as TextureInfoRange,\r\n        } as SubMesh,\r\n        textureInfo: {\r\n            length: sizes[4],\r\n            semantic: r.u8(sizes[4]) as EnumArray<TextureSemantic>,\r\n            transform: {\r\n                length: sizes[4],\r\n                e00: r.f32(sizes[4]),\r\n                e01: r.f32(sizes[4]),\r\n                e02: r.f32(sizes[4]),\r\n                e10: r.f32(sizes[4]),\r\n                e11: r.f32(sizes[4]),\r\n                e12: r.f32(sizes[4]),\r\n                e20: r.f32(sizes[4]),\r\n                e21: r.f32(sizes[4]),\r\n                e22: r.f32(sizes[4]),\r\n            } as Float3x3,\r\n            pixelRange: { start: r.u32(sizes[4]), count: r.u32(sizes[4]) } as PixelRange,\r\n        } as TextureInfo,\r\n        vertex: {\r\n            length: sizes[5],\r\n            position: {\r\n                length: sizes[5],\r\n                x: r.i16(sizes[5]),\r\n                y: r.i16(sizes[5]),\r\n                z: r.i16(sizes[5]),\r\n            } as Int16_3,\r\n            normal: !flags[0] ? undefined : {\r\n                length: sizes[5],\r\n                x: r.i8(sizes[5]),\r\n                y: r.i8(sizes[5]),\r\n                z: r.i8(sizes[5]),\r\n            } as Int8_3,\r\n            color: !flags[1] ? undefined : {\r\n                length: sizes[5],\r\n                red: r.u8(sizes[5]),\r\n                green: r.u8(sizes[5]),\r\n                blue: r.u8(sizes[5]),\r\n                alpha: r.u8(sizes[5]),\r\n            } as RGBA_U8,\r\n            texCoord: !flags[2] ? undefined : {\r\n                length: sizes[5],\r\n                x: r.f16(sizes[5]),\r\n                y: r.f16(sizes[5]),\r\n            } as Half2,\r\n            projectedPos: !flags[3] ? undefined : {\r\n                length: sizes[5],\r\n                x: r.i16(sizes[5]),\r\n                y: r.i16(sizes[5]),\r\n                z: r.i16(sizes[5]),\r\n            } as Int16_3,\r\n            deviations: {\r\n                length: sizes[5],\r\n                a: !flags[4] ? undefined : r.f16(sizes[5]),\r\n                b: !flags[5] ? undefined : r.f16(sizes[5]),\r\n                c: !flags[6] ? undefined : r.f16(sizes[5]),\r\n                d: !flags[7] ? undefined : r.f16(sizes[5]),\r\n            } as Deviations,\r\n        } as Vertex,\r\n        triangle: {\r\n            length: sizes[6],\r\n            topologyFlags: !flags[8] ? undefined : r.u8(sizes[6]),\r\n        } as Triangle,\r\n        vertexIndex: !flags[9] ? undefined : r.u16(sizes[7]),\r\n        texturePixels: r.u8(sizes[8]),\r\n    } as const;\r\n    console.assert(r.eof);\r\n    return schema;\r\n}\r\n\r\nexport type Schema = ReturnType<typeof readSchema>;\r\n", "import { type ReadonlyVec3, vec3 } from \"gl-matrix\";\r\nimport type { AABB, BoundingSphere } from \"core3d/state\";\r\nimport { BufferReader, Float16Array } from \"./util\";\r\nimport type { ComponentType, ShaderAttributeType, TextureParams } from \"webgl2\";\r\nimport { parseKTX } from \"core3d/ktx\";\r\nimport type { Mutex } from \"../mutex\";\r\nimport * as Current from \"./2_1\";\r\nimport * as Previous from \"./2_0\";\r\nimport type { WasmInstance } from \"./wasm_loader\";\r\n\r\nconst { MaterialType, OptionalVertexAttribute, PrimitiveType, TextureSemantic } = Current;\r\ntype Current = typeof Current;\r\ntype Previous = typeof Previous;\r\n// extract common types and ensure that current and previous binary format versions of them are 100% overlapping\r\ntype Float3 = Current.Float3 | Previous.Float3;\r\ntype Double3 = Current.Double3 | Previous.Double3;\r\ntype Schema = Current.Schema | Previous.Schema;\r\ntype SubMeshProjection = Current.SubMeshProjection | Previous.SubMeshProjection;\r\ntype MaterialType = Current.MaterialType | Previous.MaterialType;\r\ntype TextureSemantic = Current.TextureSemantic | Previous.TextureSemantic;\r\ntype PrimitiveType = Current.PrimitiveType | Previous.PrimitiveType;\r\ntype OptionalVertexAttribute = Current.OptionalVertexAttribute | Previous.OptionalVertexAttribute;\r\n\r\nfunction isCurrentSchema(schema: Schema): schema is Current.Schema {\r\n    return schema.version == Current.version;\r\n}\r\n\r\nexport function isSupportedVersion(version: string) {\r\n    return version == Current.version || version == Previous.version;\r\n}\r\n\r\n/** @internal */\r\nexport interface MeshDrawRange {\r\n    readonly childIndex: number;\r\n    readonly byteOffset: number; // in bytes\r\n    readonly first: number; // # indices\r\n    readonly count: number; // # indices\r\n}\r\n\r\n/** @internal */\r\nexport interface MeshObjectRange {\r\n    readonly objectId: number;\r\n    readonly beginVertex: number;\r\n    readonly endVertex: number;\r\n    readonly beginTriangle: number;\r\n    readonly endTriangle: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface Highlights {\r\n    readonly indices: Uint8Array;\r\n    readonly mutex: Mutex;\r\n}\r\n\r\nconst primitiveTypeStrings = [\"POINTS\", \"LINES\", \"LINE_LOOP\", \"LINE_STRIP\", \"TRIANGLES\", \"TRIANGLE_STRIP\", \"TRIANGLE_FAN\"] as const;\r\n/** @internal */\r\nexport type PrimitiveTypeString = typeof primitiveTypeStrings[number];\r\n\r\n/** @internal */\r\nexport interface NodeBounds {\r\n    readonly box: AABB;\r\n    readonly sphere: BoundingSphere;\r\n};\r\n\r\n// node data contains everything needed to create a new node, except its geometry and textures\r\n// this data comes from the parent node and is used to determine visibility and whether to load node geometry or not\r\n/** @internal */\r\nexport interface NodeData {\r\n    readonly id: string;\r\n    readonly childIndex: number; // octant # (not mask, but index)\r\n    readonly childMask: number; // 32-bit mask for what child indices (octants) have geometry\r\n    readonly descendantObjectIds?: readonly number[]; // optional array of all object ids found in descendant nodes for filter optimization\r\n    readonly tolerance: number;\r\n    readonly byteSize: number; // uncompressed byte size of node file\r\n    readonly offset: ReadonlyVec3;\r\n    readonly scale: number;\r\n    readonly bounds: NodeBounds;\r\n    // readonly primitiveType: PrimitiveTypeString;\r\n    // Used to predict the cost of creating geometry, potentially with filtering. Note that this does not consider the cost of loading, which ideally is a streaming process with low memory footprint\r\n    readonly primitives: number;\r\n    readonly primitivesDelta: number; // # new primitives introduced compared to parent\r\n    readonly gpuBytes: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface VertexAttributeData {\r\n    readonly kind: ShaderAttributeType;\r\n    readonly componentType: ComponentType;\r\n    readonly buffer: number; // index into buffer array\r\n    readonly componentCount: 1 | 2 | 3 | 4;\r\n    readonly normalized: boolean;\r\n    readonly byteStride: number;\r\n    readonly byteOffset?: number;\r\n};\r\n\r\n/** @internal */\r\nexport interface VertexAttributes {\r\n    readonly position: VertexAttributeData;\r\n    readonly normal: VertexAttributeData | null;\r\n    readonly material: VertexAttributeData | null;\r\n    readonly objectId: VertexAttributeData | null;\r\n    readonly texCoord: VertexAttributeData | null;\r\n    readonly color: VertexAttributeData | null;\r\n    readonly projectedPos: VertexAttributeData | null;\r\n    readonly deviations: VertexAttributeData | null;\r\n    readonly triangles0: VertexAttributeData | null;\r\n    readonly triangles1: VertexAttributeData | null;\r\n    readonly triangles2: VertexAttributeData | null;\r\n    readonly trianglesObjId: VertexAttributeData | null;\r\n    readonly highlight: VertexAttributeData | null;\r\n    readonly highlightTri: VertexAttributeData | null;\r\n}\r\n\r\n/** @internal */\r\nexport const enum VertexAttribIndex {\r\n    triangles, position, normal, material, objectId, texCoord, color, projectedPos, deviations, highlight, highlightTri\r\n};\r\n\r\n/** @internal */\r\nexport interface NodeSubMesh {\r\n    readonly materialType: MaterialType;\r\n    readonly primitiveType: PrimitiveTypeString;\r\n    readonly vertexAttributes: VertexAttributes;\r\n    readonly numVertices: number;\r\n    readonly numTriangles: number;\r\n    readonly objectRanges: readonly MeshObjectRange[];\r\n    // either index range (if index buffer is defined) for use with drawElements(), or vertex range for use with drawArray()\r\n    readonly drawRanges: readonly MeshDrawRange[];\r\n    readonly vertexBuffers: readonly ArrayBuffer[];\r\n    readonly indices: Uint16Array | Uint32Array | number; // Index buffer, or # vertices of none\r\n    readonly baseColorTexture: number | undefined; // texture index\r\n}\r\n\r\n/** @internal */\r\nexport interface NodeTexture {\r\n    readonly semantic: TextureSemantic;\r\n    readonly transform: readonly number[]; // 3x3 matrix\r\n    readonly params: TextureParams;\r\n}\r\n\r\n// node geometry and textures\r\n/** @internal */\r\nexport interface NodeGeometry {\r\n    readonly subMeshes: readonly NodeSubMesh[];\r\n    readonly textures: readonly (NodeTexture | undefined)[];\r\n}\r\n\r\nfunction getVec3(v: Float3 | Double3, i: number) {\r\n    return vec3.fromValues(v.x[i], v.y[i], v.z[i]);\r\n}\r\n\r\ntype Range = readonly [begin: number, end: number];\r\ntype DeviationsCount = 0 | 1 | 2 | 3 | 4;\r\n\r\nfunction getRange(v: { readonly start: ArrayLike<number>, count: ArrayLike<number>; }, i: number): Range {\r\n    const begin = v.start[i];\r\n    const end = begin + v.count[i];\r\n    return [begin, end] as const;\r\n}\r\n\r\nfunction computePrimitiveCount(primitiveType: PrimitiveType, numIndices: number) {\r\n    switch (primitiveType) {\r\n        case PrimitiveType.points:\r\n            return numIndices;\r\n        case PrimitiveType.lines:\r\n            return numIndices / 2;\r\n        case PrimitiveType.line_loops:\r\n            return numIndices;\r\n        case PrimitiveType.line_strip:\r\n            return numIndices - 1;\r\n        case PrimitiveType.triangles:\r\n            return numIndices / 3;\r\n        case PrimitiveType.triangle_strip:\r\n            return numIndices - 2;\r\n        case PrimitiveType.triangle_fan:\r\n            return numIndices - 2;\r\n        default:\r\n            console.warn(`Unknown primitive type: ${primitiveType}!`);\r\n    }\r\n}\r\n\r\nfunction getVertexAttribs(deviations: number) {\r\n    return {\r\n        position: { type: Uint16Array, components: [\"x\", \"y\", \"z\"] },\r\n        normal: { type: Int8Array, components: [\"x\", \"y\", \"z\"] },\r\n        texCoord: { type: Float16Array, components: [\"x\", \"y\"] },\r\n        color: { type: Uint8Array, components: [\"red\", \"green\", \"blue\", \"alpha\"] },\r\n        projectedPos: { type: Uint16Array, components: [\"x\", \"y\", \"z\"] },\r\n        deviations: { type: Float16Array, components: [\"a\", \"b\", \"c\", \"d\"].slice(0, deviations) },\r\n        materialIndex: { type: Uint8Array },\r\n        objectId: { type: Uint32Array },\r\n    } as const;\r\n}\r\ntype VertexAttribs = ReturnType<typeof getVertexAttribs>;\r\ntype VertexAttribNames = keyof VertexAttribs;\r\ntype VertexAttrib = { readonly type: VertexAttribs[VertexAttribNames][\"type\"], readonly components?: readonly string[]; };\r\n\r\nfunction computeVertexOffsets(attribs: readonly VertexAttribNames[], deviations = 0) {\r\n    let offset = 0;\r\n    let offsets: any = {};\r\n    function alignOffset(alignment: number) {\r\n        const padding = alignment - 1 - (offset + alignment - 1) % alignment;\r\n        offset += padding; // pad offset to be memory aligned.\r\n    }\r\n    let maxAlign = 1;\r\n    const vertexAttribs = getVertexAttribs(deviations);\r\n    for (const attrib of attribs) {\r\n        const { type, components } = vertexAttribs[attrib] as VertexAttrib;\r\n        const count = components?.length ?? 1;\r\n        maxAlign = Math.max(maxAlign, type.BYTES_PER_ELEMENT);\r\n        alignOffset(type.BYTES_PER_ELEMENT);\r\n        offsets[attrib] = offset;\r\n        offset += type.BYTES_PER_ELEMENT * count;\r\n    }\r\n    alignOffset(maxAlign); // align stride to largest typed array\r\n    offsets.stride = offset;\r\n    return offsets as { readonly [P in VertexAttribNames]?: number; } & { readonly stride: number; };\r\n}\r\n\r\nfunction getVertexAttribNames(optionalAttributes: OptionalVertexAttribute, deviations: DeviationsCount, hasMaterials: boolean, hasObjectIds: boolean) {\r\n    const attribNames: VertexAttribNames[] = [\"position\"];\r\n    if (optionalAttributes & OptionalVertexAttribute.normal) attribNames.push(\"normal\");\r\n    if (optionalAttributes & OptionalVertexAttribute.texCoord) attribNames.push(\"texCoord\");\r\n    if (optionalAttributes & OptionalVertexAttribute.color) attribNames.push(\"color\");\r\n    if (optionalAttributes & OptionalVertexAttribute.projectedPos) attribNames.push(\"projectedPos\");\r\n    if (deviations > 0) attribNames.push(\"deviations\");\r\n    if (hasMaterials) {\r\n        attribNames.push(\"materialIndex\");\r\n    }\r\n    if (hasObjectIds) {\r\n        attribNames.push(\"objectId\");\r\n    }\r\n    return attribNames;\r\n}\r\n\r\n/** @internal */\r\nexport function aggregateSubMeshProjections(subMeshProjection: SubMeshProjection, range: Range, separatePositionBuffer: boolean, predicate?: (objectId: number) => boolean) {\r\n    let primitives = 0;\r\n    let totalTextureBytes = 0;\r\n    let totalNumIndices = 0;\r\n    let totalNumVertices = 0;\r\n    let totalNumVertexBytes = 0;\r\n\r\n    const [begin, end] = range;\r\n    for (let i = begin; i < end; i++) {\r\n        const objectId = subMeshProjection.objectId[i];\r\n        if (predicate?.(objectId) ?? true) {\r\n            const indices = subMeshProjection.numIndices[i];\r\n            const vertices = subMeshProjection.numVertices[i];\r\n            const textureBytes = subMeshProjection.numTextureBytes[i]; // TODO: adjust by device profile/resolution\r\n            const attributes = subMeshProjection.attributes[i];\r\n            const deviations = subMeshProjection.numDeviations[i] as DeviationsCount;\r\n            const primitiveType = subMeshProjection.primitiveType[i];\r\n            // we assume that textured nodes are terrain with no material index (but object_id?).\r\n            // TODO: state these values explicitly in binary format instead\r\n            const hasMaterials = textureBytes == 0;\r\n            const hasObjectIds = true;\r\n            const [pos, ...rest] = getVertexAttribNames(attributes, deviations, hasMaterials, hasObjectIds);\r\n            const numBytesPerVertex = separatePositionBuffer ?\r\n                computeVertexOffsets([pos]).stride + computeVertexOffsets(rest, deviations).stride :\r\n                computeVertexOffsets([pos, ...rest], deviations).stride;\r\n            primitives += computePrimitiveCount(primitiveType, indices ? indices : vertices) ?? 0;\r\n            totalNumIndices += indices;\r\n            totalNumVertices += vertices;\r\n            totalNumVertexBytes += vertices * numBytesPerVertex;\r\n            totalTextureBytes += textureBytes;\r\n        } else {\r\n            // debugger;\r\n        }\r\n    }\r\n    const idxStride = totalNumVertices < 0xffff ? 2 : 4;\r\n    const gpuBytes = totalTextureBytes + totalNumVertexBytes + totalNumIndices * idxStride;\r\n    return { primitives, gpuBytes } as const;\r\n}\r\n\r\nfunction toHex(bytes: Uint8Array) {\r\n    return Array.prototype.map.call(bytes, x => ('00' + x.toString(16).toUpperCase()).slice(-2)).join('');\r\n}\r\n\r\n/** @internal */\r\nexport function getChildren(parentId: string, schema: Schema, separatePositionBuffer: boolean, predicate?: (objectId: number) => boolean): NodeData[] {\r\n    const { childInfo, hashBytes } = schema;\r\n    const children: NodeData[] = [];\r\n\r\n\r\n    // compute parent/current mesh primitive counts per child partition\r\n    const parentPrimitiveCounts: number[] = [];\r\n\r\n    for (let i = 0; i < childInfo.length; i++) {\r\n        const childIndex = childInfo.childIndex[i];\r\n        const childMask = childInfo.childMask[i];\r\n        const [hashBegin, hashEnd] = getRange(childInfo.hash, i);\r\n        const hash = hashBytes.slice(hashBegin, hashEnd);\r\n        const id = toHex(hash); // parentId + childIndex.toString(32); // use radix 32 (0-9, a-v) encoding, which allows for max 32 children per node\r\n        const tolerance = childInfo.tolerance[i];\r\n        const byteSize = childInfo.totalByteSize[i];\r\n        const offset = getVec3(childInfo.offset, i);\r\n        const scale = childInfo.scale[i];\r\n        const bounds: NodeBounds = {\r\n            box: {\r\n                min: getVec3(childInfo.bounds.box.min, i),\r\n                max: getVec3(childInfo.bounds.box.max, i),\r\n            },\r\n            sphere: {\r\n                center: getVec3(childInfo.bounds.sphere.origo, i),\r\n                radius: childInfo.bounds.sphere.radius[i],\r\n            }\r\n        };\r\n        // offset bounds\r\n        const { sphere, box } = bounds;\r\n        vec3.add(sphere.center as vec3, sphere.center, offset);\r\n        vec3.add(box.min as vec3, box.min, offset);\r\n        vec3.add(box.max as vec3, box.max, offset);\r\n\r\n        const subMeshProjectionRange = getRange(childInfo.subMeshes, i);\r\n        const parentPrimitives = parentPrimitiveCounts[childIndex];\r\n        const { primitives, gpuBytes } = aggregateSubMeshProjections(schema.subMeshProjection, subMeshProjectionRange, separatePositionBuffer, predicate);\r\n        const primitivesDelta = primitives - (parentPrimitives ?? 0);\r\n        let descendantObjectIds: number[] | undefined;\r\n        if (isCurrentSchema(schema)) {\r\n            const [idsBegin, idsEnd] = getRange(schema.childInfo.descendantObjectIds, i);\r\n            if (idsBegin != idsEnd) {\r\n                descendantObjectIds = [...schema.descendantObjectIds.slice(idsBegin, idsEnd)];\r\n            }\r\n        }\r\n        // console.assert(parentId == \"0\" || primitivesDelta >= 0, \"negative primitive delta\");\r\n        children.push({ id, childIndex, childMask, tolerance, byteSize, offset, scale, bounds, primitives, primitivesDelta, gpuBytes, descendantObjectIds });\r\n    }\r\n    return children;\r\n}\r\n\r\n/** @internal */\r\nexport function* getSubMeshes(schema: Schema, predicate?: (objectId: number) => boolean) {\r\n    const { subMesh } = schema;\r\n    for (let i = 0; i < subMesh.length; i++) {\r\n        const objectId = subMesh.objectId[i];\r\n        const primitive = subMesh.primitiveType[i];\r\n        if (predicate?.(objectId) ?? true) {\r\n            const childIndex = subMesh.childIndex[i];\r\n            const objectId = subMesh.objectId[i];\r\n            const materialIndex = subMesh.materialIndex[i];\r\n            const materialType = materialIndex ==\r\n                0xff && subMesh.textures.count[i] == 0 && (primitive == PrimitiveType.triangle_strip || primitive == PrimitiveType.triangles) ?\r\n                MaterialType.elevation :\r\n                subMesh.materialType[i];\r\n            const primitiveType = subMesh.primitiveType[i];\r\n            const attributes = subMesh.attributes[i];\r\n            const deviations = subMesh.numDeviations[i] as DeviationsCount;\r\n            const vertexRange = getRange(subMesh.vertices, i);\r\n            const indexRange = getRange(subMesh.primitiveVertexIndices, i);\r\n            const textureRange = getRange(subMesh.textures, i);\r\n            yield { childIndex, objectId, materialIndex, materialType, primitiveType, attributes, deviations, vertexRange, indexRange, textureRange };\r\n        }\r\n    }\r\n}\r\ntype TypedArray = Uint8Array | Uint16Array | Uint32Array | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\r\n\r\n// Candidates for wasm implementation?\r\nfunction copyToInterleavedArray<T extends TypedArray>(wasm: WasmInstance, dst: T, src: T, byteOffset: number, byteStride: number, begin: number, end: number) {\r\n    const offset = byteOffset / dst.BYTES_PER_ELEMENT;\r\n    const stride = byteStride / dst.BYTES_PER_ELEMENT;\r\n    console.assert(Math.round(offset) == offset);\r\n    console.assert(Math.round(stride) == stride);\r\n    let j = offset;\r\n    for (let i = begin; i < end; i++) {\r\n        dst[j] = src[i];\r\n        j += stride;\r\n    }\r\n}\r\n\r\nfunction fillToInterleavedArray<T extends TypedArray>(wasm: WasmInstance, dst: T, src: number, byteOffset: number, byteStride: number, begin: number, end: number) {\r\n    const offset = byteOffset / dst.BYTES_PER_ELEMENT;\r\n    const stride = byteStride / dst.BYTES_PER_ELEMENT;\r\n    console.assert(Math.round(offset) == offset);\r\n    console.assert(Math.round(stride) == stride);\r\n    let j = offset;\r\n    for (let i = begin; i < end; i++) {\r\n        dst[j] = src;\r\n        j += stride;\r\n    }\r\n}\r\n\r\nfunction getGeometry(wasm: WasmInstance, schema: Schema, separatePositionBuffer: boolean, enableOutlines: boolean, highlights: Highlights, predicate?: (objectId: number) => boolean): NodeGeometry {\r\n    const { vertex, vertexIndex } = schema;\r\n\r\n    const filteredSubMeshes = [...getSubMeshes(schema, predicate)];\r\n\r\n    let subMeshes: NodeSubMesh[] = [];\r\n    const referencedTextures = new Set<number>();\r\n\r\n    // group submeshes into drawable meshes (with common attributes)\r\n    type Group = {\r\n        readonly materialType: number;\r\n        readonly primitiveType: number;\r\n        readonly attributes: number;\r\n        readonly deviations: DeviationsCount;\r\n        readonly subMeshIndices: number[];\r\n    };\r\n    const groups = new Map<string, Group>();\r\n    for (let i = 0; i < filteredSubMeshes.length; i++) {\r\n        const { materialType, primitiveType, attributes, deviations, childIndex } = filteredSubMeshes[i];\r\n        const key = `${materialType}_${primitiveType}_${attributes}_${deviations}_${childIndex}`;\r\n        let group = groups.get(key);\r\n        if (!group) {\r\n            group = { materialType, primitiveType, attributes, deviations, subMeshIndices: [] };\r\n            groups.set(key, group);\r\n        }\r\n        group.subMeshIndices.push(i);\r\n    }\r\n\r\n    // we don't want highlights to change during parsing, so we hold the lock for the entire file\r\n    highlights.mutex.lockSync();\r\n\r\n    // create drawable meshes\r\n    for (const { materialType, primitiveType, attributes, deviations, subMeshIndices } of groups.values()) {\r\n        if (subMeshIndices.length == 0)\r\n            continue;\r\n        const groupMeshes = subMeshIndices.map(i => filteredSubMeshes[i]);\r\n        const hasMaterials = groupMeshes.some(m => m.materialIndex != 0xff);\r\n        const hasObjectIds = groupMeshes.some(m => m.objectId != 0xffffffff);\r\n\r\n        const allAttribNames = getVertexAttribNames(attributes, deviations, hasMaterials, hasObjectIds);\r\n        const [posName, ...extraAttribNames] = allAttribNames; // pop off positions since we're potentially putting them in a separate buffer\r\n        const attribNames = separatePositionBuffer ? extraAttribNames : allAttribNames;\r\n        const positionStride = computeVertexOffsets([posName], deviations).stride;\r\n        const trianglePosStride = positionStride * 3;\r\n        const attribOffsets = computeVertexOffsets(attribNames, deviations);\r\n        const vertexStride = attribOffsets.stride;\r\n\r\n        const childIndices = [...new Set<number>(groupMeshes.map(sm => sm.childIndex))].sort();\r\n        let numVertices = 0;\r\n        let numIndices = 0;\r\n        let numTriangles = 0;\r\n        for (let i = 0; i < groupMeshes.length; i++) {\r\n            const sm = groupMeshes[i];\r\n            const vtxCnt = sm.vertexRange[1] - sm.vertexRange[0];\r\n            const idxCnt = sm.indexRange[1] - sm.indexRange[0];\r\n            numVertices += vtxCnt;\r\n            numIndices += idxCnt;\r\n            if (primitiveType == PrimitiveType.triangles) {\r\n                numTriangles += Math.round((idxCnt > 0 ? idxCnt : vtxCnt) / 3);\r\n            }\r\n        }\r\n        const vertexBuffer = new ArrayBuffer(numVertices * vertexStride);\r\n        let trianglePosBuffer: Int16Array | undefined;\r\n        let triangleObjectIdBuffer: Uint32Array | undefined;\r\n        let highlightBufferTri: Uint8Array | undefined;\r\n        if (enableOutlines && primitiveType == PrimitiveType.triangles) { // TODO: support triangle strips and fans too\r\n            trianglePosBuffer = new Int16Array(new ArrayBuffer(numTriangles * trianglePosStride));\r\n            triangleObjectIdBuffer = new Uint32Array(numTriangles);\r\n            highlightBufferTri = new Uint8Array(numTriangles);\r\n        }\r\n        const positionBuffer = separatePositionBuffer ? new ArrayBuffer(numVertices * positionStride) : undefined;\r\n        let indexBuffer: Uint32Array | Uint16Array | undefined;\r\n        if (vertexIndex) {\r\n            indexBuffer = new (numVertices < 0xffff ? Uint16Array : Uint32Array)(numIndices);\r\n        }\r\n        const highlightBuffer = new Uint8Array(numVertices);\r\n        let indexOffset = 0;\r\n        let vertexOffset = 0;\r\n        let triangleOffset = 0;\r\n        let drawRanges: MeshDrawRange[] = [];\r\n        type Mutable<T> = { -readonly [P in keyof T]: T[P] };\r\n        const objectRanges: Mutable<MeshObjectRange>[] = [];\r\n\r\n        function enumerateBuffers<K extends string>(possibleBuffers: { readonly [P in K]: ArrayBuffer | undefined }) {\r\n            const buffers: ArrayBuffer[] = [];\r\n            const indices = {} as { readonly [P in K]: number };\r\n            for (const [key, value] of Object.entries(possibleBuffers)) {\r\n                const buffer = value as ArrayBuffer | undefined;\r\n                let index = -1;\r\n                if (buffer) {\r\n                    index = buffers.indexOf(buffer);\r\n                    if (index < 0) {\r\n                        index = buffers.length;\r\n                        buffers.push(buffer);\r\n                    }\r\n                }\r\n                Reflect.set(indices, key, index);\r\n            }\r\n            return [buffers, indices] as const;\r\n        }\r\n\r\n        const [vertexBuffers, bufIdx] = enumerateBuffers({\r\n            primary: vertexBuffer,\r\n            highlight: highlightBuffer?.buffer,\r\n            pos: positionBuffer,\r\n            triPos: trianglePosBuffer?.buffer,\r\n            triId: triangleObjectIdBuffer?.buffer,\r\n            highlightTri: highlightBufferTri?.buffer,\r\n        });\r\n\r\n        for (const childIndex of childIndices) {\r\n            const meshes = groupMeshes.filter(sm => sm.childIndex == childIndex);\r\n            if (meshes.length == 0)\r\n                continue;\r\n\r\n            const drawRangeBegin = indexBuffer ? indexOffset : vertexOffset;\r\n\r\n            for (const subMesh of meshes) {\r\n                const { vertexRange, indexRange, materialIndex, deviations, objectId } = subMesh;\r\n                const context = { materialIndex, objectId };\r\n                const [beginVtx, endVtx] = vertexRange;\r\n                const [beginIdx, endIdx] = indexRange;\r\n\r\n                // initialize vertex buffer\r\n                const vertexAttribs = getVertexAttribs(deviations);\r\n                for (const attribName of attribNames) {\r\n                    const { type, components } = vertexAttribs[attribName] as VertexAttrib;\r\n                    const dst = new type(vertexBuffer, vertexOffset * vertexStride);\r\n                    const count = components?.length ?? 1;\r\n                    for (var c = 0; c < count; c++) {\r\n                        const offs = attribOffsets[attribName]! + c * type.BYTES_PER_ELEMENT;\r\n                        if (attribName in vertex) {\r\n                            let src = Reflect.get(vertex, attribName) as typeof dst;\r\n                            if (components) {\r\n                                src = Reflect.get(src, components[c]);\r\n                            }\r\n                            copyToInterleavedArray(wasm, dst, src, offs, vertexStride, beginVtx, endVtx);\r\n                        } else {\r\n                            const src = Reflect.get(context, attribName) as number;\r\n                            fillToInterleavedArray(wasm, dst, src, offs, vertexStride, beginVtx, endVtx);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // initialize triangle vertex buffer for clipping intersection\r\n                let numTrianglesInSubMesh = 0;\r\n                if (trianglePosBuffer && triangleObjectIdBuffer) {\r\n                    const { x, y, z } = vertex.position;\r\n                    let j = triangleOffset * 3 * 3;\r\n                    if (vertexIndex && indexBuffer) {\r\n                        numTrianglesInSubMesh = (endIdx - beginIdx) / 3;\r\n                        for (let i = beginIdx; i < endIdx; i++) {\r\n                            // TODO: Add support for triangle strips and fans as well...\r\n                            const idx = vertexIndex[i] + beginVtx;\r\n                            trianglePosBuffer[j++] = x[idx];\r\n                            trianglePosBuffer[j++] = y[idx];\r\n                            trianglePosBuffer[j++] = z[idx];\r\n                        }\r\n                    } else {\r\n                        numTrianglesInSubMesh = (endVtx - beginVtx) / 3;\r\n                        for (let i = beginVtx; i < endVtx; i++) {\r\n                            const idx = i;\r\n                            trianglePosBuffer[j++] = x[idx];\r\n                            trianglePosBuffer[j++] = y[idx];\r\n                            trianglePosBuffer[j++] = z[idx];\r\n                        }\r\n                    }\r\n                    triangleObjectIdBuffer.fill(objectId, triangleOffset, triangleOffset + numTrianglesInSubMesh);\r\n                }\r\n\r\n                if (positionBuffer) {\r\n                    // initialize separate positions buffer\r\n                    const i16 = new Int16Array(positionBuffer, vertexOffset * positionStride);\r\n                    copyToInterleavedArray(wasm, i16, vertex.position.x, 0, positionStride, beginVtx, endVtx);\r\n                    copyToInterleavedArray(wasm, i16, vertex.position.y, 2, positionStride, beginVtx, endVtx);\r\n                    copyToInterleavedArray(wasm, i16, vertex.position.z, 4, positionStride, beginVtx, endVtx);\r\n                }\r\n\r\n                // initialize index buffer (if any)\r\n                if (vertexIndex && indexBuffer) {\r\n                    for (let i = beginIdx; i < endIdx; i++) {\r\n                        indexBuffer[indexOffset++] = vertexIndex[i] + vertexOffset;\r\n                    }\r\n                }\r\n\r\n                const endVertex = vertexOffset + (endVtx - beginVtx);\r\n                const endTriangle = triangleOffset + (endIdx - beginIdx) / 3;\r\n                // initialize highlight buffer\r\n                const highlightIndex = highlights.indices[objectId] ?? 0;\r\n                if (highlightIndex) {\r\n                    highlightBuffer.fill(highlightIndex, vertexOffset, endVertex);\r\n                    highlightBufferTri?.fill(highlightIndex, triangleOffset, endTriangle);\r\n                }\r\n\r\n                // update object ranges\r\n                const prev = objectRanges.length - 1;\r\n                if (prev >= 0 && objectRanges[prev].objectId == objectId) {\r\n                    // merge with previous entry\r\n                    objectRanges[prev].endVertex = endVertex;\r\n                    objectRanges[prev].endTriangle = endTriangle;\r\n                } else {\r\n                    objectRanges.push({ objectId, beginVertex: vertexOffset, endVertex, beginTriangle: triangleOffset, endTriangle });\r\n                }\r\n                triangleOffset += numTrianglesInSubMesh;\r\n                vertexOffset += endVtx - beginVtx;\r\n            }\r\n\r\n            const drawRangeEnd = indexBuffer ? indexOffset : vertexOffset;\r\n            const byteOffset = drawRangeBegin * (indexBuffer ? indexBuffer.BYTES_PER_ELEMENT : vertexStride);\r\n            const count = drawRangeEnd - drawRangeBegin;\r\n            drawRanges.push({ childIndex, byteOffset, first: drawRangeBegin, count });\r\n        }\r\n\r\n        console.assert(vertexOffset == numVertices);\r\n        console.assert(indexOffset == numIndices);\r\n        console.assert(triangleOffset == (triangleObjectIdBuffer?.length ?? 0));\r\n        const indices = indexBuffer ?? numVertices;\r\n\r\n        const [beginTexture, endTexture] = groupMeshes[0].textureRange;\r\n        let baseColorTexture: number | undefined;\r\n        if (endTexture > beginTexture) {\r\n            baseColorTexture = beginTexture;\r\n        }\r\n\r\n        if (baseColorTexture != undefined) {\r\n            referencedTextures.add(baseColorTexture);\r\n        }\r\n\r\n        const stride = vertexStride;\r\n        const deviationsKind = deviations == 0 || deviations == 1 ? \"FLOAT\" as const : `FLOAT_VEC${deviations}` as const;\r\n        const vertexAttributes = {\r\n            position: { kind: \"FLOAT_VEC4\", buffer: bufIdx.pos, componentCount: 3, componentType: \"SHORT\", normalized: true, byteOffset: attribOffsets[\"position\"], byteStride: separatePositionBuffer ? 0 : stride },\r\n            normal: (attributes & OptionalVertexAttribute.normal) != 0 ? { kind: \"FLOAT_VEC3\", buffer: bufIdx.primary, componentCount: 3, componentType: \"BYTE\", normalized: true, byteOffset: attribOffsets[\"normal\"], byteStride: stride } : null,\r\n            material: hasMaterials ? { kind: \"UNSIGNED_INT\", buffer: bufIdx.primary, componentCount: 1, componentType: \"UNSIGNED_BYTE\", normalized: false, byteOffset: attribOffsets[\"materialIndex\"], byteStride: stride } : null,\r\n            objectId: hasObjectIds ? { kind: \"UNSIGNED_INT\", buffer: bufIdx.primary, componentCount: 1, componentType: \"UNSIGNED_INT\", normalized: false, byteOffset: attribOffsets[\"objectId\"], byteStride: stride } : null,\r\n            texCoord: (attributes & OptionalVertexAttribute.texCoord) != 0 ? { kind: \"FLOAT_VEC2\", buffer: bufIdx.primary, componentCount: 2, componentType: \"HALF_FLOAT\", normalized: false, byteOffset: attribOffsets[\"texCoord\"], byteStride: stride } : null,\r\n            color: (attributes & OptionalVertexAttribute.color) != 0 ? { kind: \"FLOAT_VEC4\", buffer: bufIdx.primary, componentCount: 4, componentType: \"UNSIGNED_BYTE\", normalized: true, byteOffset: attribOffsets[\"color\"], byteStride: stride } : null,\r\n            projectedPos: (attributes & OptionalVertexAttribute.projectedPos) != 0 ? { kind: \"FLOAT_VEC4\", buffer: bufIdx.primary, componentCount: 3, componentType: \"SHORT\", normalized: true, byteOffset: attribOffsets[\"projectedPos\"], byteStride: stride } : null,\r\n            deviations: deviations != 0 ? { kind: deviationsKind, buffer: bufIdx.primary, componentCount: deviations, componentType: \"HALF_FLOAT\", normalized: false, byteOffset: attribOffsets[\"deviations\"], byteStride: stride } : null,\r\n            triangles0: trianglePosBuffer ? { kind: \"FLOAT_VEC4\", buffer: bufIdx.triPos, componentCount: 3, componentType: \"SHORT\", normalized: true, byteOffset: 0, byteStride: 18 } : null,\r\n            triangles1: trianglePosBuffer ? { kind: \"FLOAT_VEC4\", buffer: bufIdx.triPos, componentCount: 3, componentType: \"SHORT\", normalized: true, byteOffset: 6, byteStride: 18 } : null,\r\n            triangles2: trianglePosBuffer ? { kind: \"FLOAT_VEC4\", buffer: bufIdx.triPos, componentCount: 3, componentType: \"SHORT\", normalized: true, byteOffset: 12, byteStride: 18 } : null,\r\n            trianglesObjId: trianglePosBuffer ? { kind: \"UNSIGNED_INT\", buffer: bufIdx.triId, componentCount: 1, componentType: \"UNSIGNED_INT\", normalized: false, byteOffset: 0, byteStride: 4 } : null,\r\n            highlight: { kind: \"UNSIGNED_INT\", buffer: bufIdx.highlight, componentCount: 1, componentType: \"UNSIGNED_BYTE\", normalized: false, byteOffset: 0, byteStride: 0 },\r\n            highlightTri: { kind: \"UNSIGNED_INT\", buffer: bufIdx.highlightTri, componentCount: 1, componentType: \"UNSIGNED_BYTE\", normalized: false, byteOffset: 0, byteStride: 0 },\r\n        } as const satisfies VertexAttributes;\r\n\r\n        objectRanges.sort((a, b) => (a.objectId - b.objectId));\r\n\r\n        subMeshes.push({\r\n            materialType,\r\n            primitiveType: primitiveTypeStrings[primitiveType],\r\n            numVertices,\r\n            numTriangles,\r\n            objectRanges,\r\n            vertexAttributes,\r\n            vertexBuffers,\r\n            indices,\r\n            baseColorTexture,\r\n            drawRanges\r\n        });\r\n    }\r\n\r\n    highlights.mutex.unlock();\r\n\r\n    const textures = new Array<NodeTexture | undefined>(schema.textureInfo.length);\r\n    const { textureInfo } = schema;\r\n    for (const i of referencedTextures) {\r\n        const [begin, end] = getRange(textureInfo.pixelRange, i);\r\n        const semantic = textureInfo.semantic[i];\r\n        const transform = [\r\n            textureInfo.transform.e00[i],\r\n            textureInfo.transform.e01[i],\r\n            textureInfo.transform.e02[i],\r\n            textureInfo.transform.e10[i],\r\n            textureInfo.transform.e11[i],\r\n            textureInfo.transform.e12[i],\r\n            textureInfo.transform.e20[i],\r\n            textureInfo.transform.e21[i],\r\n            textureInfo.transform.e22[i],\r\n        ] as const;\r\n        const ktx = schema.texturePixels.subarray(begin, end);\r\n        const params = parseKTX(ktx);\r\n        textures[i] = { semantic, transform, params };\r\n    }\r\n\r\n\r\n    return { subMeshes, textures } as const satisfies NodeGeometry;\r\n}\r\n\r\nexport function parseNode(wasm: WasmInstance, id: string, separatePositionBuffer: boolean, enableOutlines: boolean, version: string, buffer: ArrayBuffer, highlights: Highlights, applyFilter: boolean) {\r\n    console.assert(isSupportedVersion(version));\r\n    const r = new BufferReader(buffer);\r\n    var schema = version == Current.version ? Current.readSchema(r) : Previous.readSchema(r);\r\n    let predicate: ((objectId: number) => boolean) | undefined;\r\n    predicate = applyFilter ? (objectId =>\r\n        highlights.indices[objectId] != 0xff\r\n    ) : undefined;\r\n    const childInfos = getChildren(id, schema, separatePositionBuffer, predicate);\r\n    const geometry = getGeometry(wasm, schema, separatePositionBuffer, enableOutlines, highlights, predicate);\r\n    return { childInfos, geometry } as const;\r\n}\r\n", "let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n*/\nexport function init() {\n    wasm.init();\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n/**\n* @param {Uint8Array} dst\n* @param {Uint8Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_u8(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray8ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\nlet cachedUint16Memory0 = null;\n\nfunction getUint16Memory0() {\n    if (cachedUint16Memory0 === null || cachedUint16Memory0.byteLength === 0) {\n        cachedUint16Memory0 = new Uint16Array(wasm.memory.buffer);\n    }\n    return cachedUint16Memory0;\n}\n\nfunction passArray16ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 2, 2) >>> 0;\n    getUint16Memory0().set(arg, ptr / 2);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Uint16Array} dst\n* @param {Uint16Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_u16(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Uint32Array} dst\n* @param {Uint32Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_u32(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray32ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Int8Array} dst\n* @param {Int8Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_i8(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray8ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Int16Array} dst\n* @param {Int16Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_i16(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray16ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Int32Array} dst\n* @param {Int32Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_i32(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArray32ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Float32Array} dst\n* @param {Float32Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_f32(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArrayF32ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF32ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_f32(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nfunction passArrayF64ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 8, 8) >>> 0;\n    getFloat64Memory0().set(arg, ptr / 8);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Float64Array} dst\n* @param {Float64Array} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function copy_to_interleaved_array_f64(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArrayF64ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    const ptr1 = passArrayF64ToWasm0(src, wasm.__wbindgen_malloc);\n    const len1 = WASM_VECTOR_LEN;\n    wasm.copy_to_interleaved_array_f64(ptr0, len0, addHeapObject(dst), ptr1, len1, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Uint8Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_u8(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Uint16Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_u16(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Uint32Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_u32(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Int8Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_i8(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray8ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_i8(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Int16Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_i16(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray16ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_i16(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Int32Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_i32(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArray32ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_i32(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Float32Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_f32(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArrayF32ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_f32(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\n/**\n* @param {Float64Array} dst\n* @param {number} src\n* @param {number} byte_offset\n* @param {number} byte_stride\n* @param {number} begin\n* @param {number} end\n*/\nexport function fill_to_interleaved_array_f64(dst, src, byte_offset, byte_stride, begin, end) {\n    var ptr0 = passArrayF64ToWasm0(dst, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.fill_to_interleaved_array_f64(ptr0, len0, addHeapObject(dst), src, byte_offset, byte_stride, begin, end);\n}\n\nexport function __wbindgen_copy_to_typed_array(arg0, arg1, arg2) {\n    new Uint8Array(getObject(arg2).buffer, getObject(arg2).byteOffset, getObject(arg2).byteLength).set(getArrayU8FromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\n", "import type * as WasmNamespace from \"@novorender/wasm-parser\";\r\n// @ts-ignore\r\nimport * as wasmWrapper from \"@novorender/wasm-parser/wasm_parser_bg\";\r\n\r\nexport type WasmInstance = typeof WasmNamespace;\r\n\r\n/** @internal */\r\nexport async function esbuildWasmInstance(wasmData: ArrayBuffer): Promise<WasmInstance> {\r\n    let imports = {\r\n        [\"./wasm_parser_bg.js\"]: wasmWrapper,\r\n    };\r\n    const { instance } = await WebAssembly.instantiate(wasmData, imports);\r\n    wasmWrapper.__wbg_set_wasm(instance.exports);\r\n    return wasmWrapper;\r\n}", "import { AbortableDownload, Downloader } from \"./download\";\r\nimport { Mutex } from \"../mutex\";\r\nimport { parseNode } from \"./parser\";\r\nimport type { AbortAllMessage, AbortMessage, AbortedAllMessage, AbortedMessage, ParseMessage, ErrorMessage, LoadMessage, ReadyMessage, MessageRequest, MessageResponse, ParseParams, BufferSet, InitMessage } from \"./messages\";\r\nimport { esbuildWasmInstance, type WasmInstance } from \"./wasm_loader\";\r\n\r\nexport interface HighlightsBuffer {\r\n    readonly buffer: SharedArrayBuffer;\r\n    readonly indices: Uint8Array;\r\n    readonly mutex: Mutex;\r\n}\r\n/** @internal */\r\nexport class LoaderHandler {\r\n    readonly downloader = new Downloader();\r\n    readonly downloads = new Map<string, AbortableDownload>();\r\n    highlights: HighlightsBuffer = undefined!; // will be set right after construction by \"buffer\" message\r\n    wasm: WasmInstance | undefined;\r\n\r\n    constructor(readonly send: (msg: MessageResponse, transfer?: Transferable[]) => void) {\r\n    }\r\n\r\n    receive(msg: MessageRequest) {\r\n        switch (msg.kind) {\r\n            case \"init\":\r\n                this.init(msg);\r\n                break;\r\n            case \"parse\":\r\n                this.parse(msg);\r\n                break;\r\n            case \"load\":\r\n                this.load(msg);\r\n                break;\r\n            case \"abort\":\r\n                this.abort(msg);\r\n                break;\r\n            case \"abort_all\":\r\n                this.abortAll(msg);\r\n                break;\r\n            // default:\r\n            //     console.warn(`Unknown load message: ${msg}!`);\r\n            //     break;\r\n        }\r\n    }\r\n\r\n    private async init(msg: InitMessage) {\r\n        const {wasmData, buffer} = msg;\r\n\r\n        this.wasm = await esbuildWasmInstance(wasmData);\r\n\r\n        const indices = new Uint8Array(buffer, 4);\r\n        const mutex = new Mutex(buffer);\r\n        this.highlights = { buffer, indices, mutex };\r\n        const setBufferMsg = { kind: \"buffer\" } as BufferSet;\r\n        this.send(setBufferMsg);\r\n    }\r\n\r\n    private parseBuffer(buffer: ArrayBuffer, params: ParseParams) {\r\n        if(this.wasm) {\r\n            const { highlights } = this;\r\n            const { id, version, separatePositionsBuffer, enableOutlines, applyFilter } = params;\r\n            const { childInfos, geometry } = parseNode(this.wasm, id, separatePositionsBuffer, enableOutlines, version, buffer, highlights, applyFilter);\r\n            const readyMsg: ReadyMessage = { kind: \"ready\", id, childInfos, geometry };\r\n            const transfer: Transferable[] = [];\r\n            for (const { vertexBuffers, indices } of geometry.subMeshes) {\r\n                transfer.push(...vertexBuffers);\r\n                if (typeof indices != \"number\") {\r\n                    transfer.push(indices.buffer);\r\n                }\r\n            }\r\n            this.send(readyMsg, transfer);\r\n        }else{\r\n            console.error(\"Wasm is not initialized yet\");\r\n        }\r\n    }\r\n\r\n    private async parse(params: ParseMessage) {\r\n        const { id, buffer } = params;\r\n        try {\r\n            this.parseBuffer(buffer, params);\r\n        } catch (error) {\r\n            this.error(id, error);\r\n        }\r\n    }\r\n\r\n    private async load(params: LoadMessage) {\r\n        const { downloader, downloads } = this;\r\n        const { url, id, byteSize } = params;\r\n        try {\r\n            const download = downloader.downloadArrayBufferAbortable(url, new ArrayBuffer(byteSize));\r\n            downloads.set(id, download);\r\n            const buffer = await download.result;\r\n            downloads.delete(id);\r\n            if (buffer) {\r\n                this.parseBuffer(buffer, params);\r\n            } else {\r\n                const abortedMsg: AbortedMessage = { kind: \"aborted\", id };\r\n                this.send(abortedMsg);\r\n            }\r\n        } catch (error) {\r\n            this.error(id, error);\r\n        }\r\n    }\r\n\r\n    private removeNode(id: string) {\r\n        const { downloads } = this;\r\n        const download = downloads.get(id);\r\n        downloads.delete(id);\r\n        return { download };\r\n    }\r\n\r\n    private error(id: string, error: any) {\r\n        const { download } = this.removeNode(id);\r\n        const errorMsg = { kind: \"error\", id, error } as ErrorMessage;\r\n        this.send(errorMsg);\r\n    }\r\n\r\n    private abort(params: AbortMessage) {\r\n        const { id } = params;\r\n        const { download } = this.removeNode(id);\r\n        download?.abort();\r\n    }\r\n\r\n    private async abortAll(params: AbortAllMessage) {\r\n        const { downloads, downloader } = this;\r\n        for (const download of downloads.values()) {\r\n            download.abort();\r\n        }\r\n        await downloader.complete();\r\n        console.assert(downloads.size == 0);\r\n        const abortedAllMsg = { kind: \"aborted_all\" } as AbortedAllMessage;\r\n        this.send(abortedAllMsg);\r\n    }\r\n}", "import { LoaderHandler } from \"./handler\";\r\nimport type { MessageResponse, MessageRequest } from \"./messages\";\r\nimport { esbuildWasmInstance } from \"./wasm_loader\";\r\nexport type * from \"./parser\";\r\nexport type * from \"./messages\";\r\n\r\n\r\nconst handler = new LoaderHandler((msg: MessageResponse, transfer?: Transferable[]) => {\r\n    postMessage(msg, { transfer });\r\n});\r\n\r\nonmessage = e => {\r\n    const msg = e.data as MessageRequest;\r\n    if (msg.kind == \"close\") {\r\n        close();\r\n    } else {\r\n        handler.receive(msg);\r\n    }\r\n};\r\n"],
  "mappings": "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",
  "names": ["self", "scale", "len", "PrimitiveType", "OptionalVertexAttribute", "MaterialType", "TextureSemantic", "version", "readSchema", "MaterialType", "OptionalVertexAttribute", "PrimitiveType", "TextureSemantic", "version", "PrimitiveType", "OptionalVertexAttribute", "scale", "objectId", "MaterialType", "wasm", "enumerateBuffers", "indices", "deviations", "count", "version", "readSchema", "len", "version"]
}
